2025-08-10 09:35:41.599 [main] INFO  com.yizhaoqi.smartpai.SmartPaiApplication - Starting SmartPaiApplication using Java 17.0.16 with PID 17856 (E:\JavaProject\PaiSmart-main\PaiSmart-main\target\classes started by SongYu in E:\JavaProject\PaiSmart-main)
2025-08-10 09:35:41.600 [main] INFO  com.yizhaoqi.smartpai.SmartPaiApplication - No active profile set, falling back to 1 default profile: "default"
2025-08-10 09:35:42.663 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port 8081 (http)
2025-08-10 09:35:42.668 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8081"]
2025-08-10 09:35:42.669 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2025-08-10 09:35:42.671 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.34]
2025-08-10 09:35:42.726 [main] INFO  o.a.c.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-08-10 09:35:42.727 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 1103 ms
2025-08-10 09:35:43.034 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-08-10 09:35:43.122 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@51eafec0
2025-08-10 09:35:43.122 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-08-10 09:35:43.148 [main] WARN  org.hibernate.orm.deprecation - HHH90000025: MySQL8Dialect does not need to be specified explicitly using 'hibernate.dialect' (remove the property setting and it will be selected by default)
2025-08-10 09:35:43.148 [main] WARN  org.hibernate.orm.deprecation - HHH90000026: MySQL8Dialect has been deprecated; use org.hibernate.dialect.MySQLDialect instead
2025-08-10 09:35:44.281 [main] DEBUG o.s.web.filter.ServerHttpObservationFilter - Filter 'webMvcObservationFilter' configured for use
2025-08-10 09:35:44.829 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-08-10 09:35:44.851 [main] INFO  o.s.s.c.a.a.c.InitializeUserDetailsBeanManagerConfigurer$InitializeUserDetailsManagerConfigurer - Global AuthenticationManager configured with UserDetailsService bean with name customUserDetailsService
2025-08-10 09:35:44.896 [main] DEBUG o.s.w.s.server.support.WebSocketHandlerMapping - Patterns [/chat/{token}] in 'webSocketHandlerMapping'
2025-08-10 09:35:44.940 [main] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - 40 mappings in 'requestMappingHandlerMapping'
2025-08-10 09:35:44.966 [main] DEBUG o.s.web.servlet.handler.SimpleUrlHandlerMapping - Patterns [/webjars/**, /**, /static/**] in 'resourceHandlerMapping'
2025-08-10 09:35:45.073 [main] INFO  o.s.b.actuate.endpoint.web.EndpointLinksResolver - Exposing 1 endpoint beneath base path '/actuator'
2025-08-10 09:35:45.108 [main] INFO  com.yizhaoqi.smartpai.config.SecurityConfig - Security configuration loaded successfully.
2025-08-10 09:35:45.123 [main] DEBUG o.s.security.web.DefaultSecurityFilterChain - Will secure any request with filters: DisableEncodeUrlFilter, WebAsyncManagerIntegrationFilter, SecurityContextHolderFilter, HeaderWriterFilter, LogoutFilter, JwtAuthenticationFilter, OrgTagAuthorizationFilter, RequestCacheAwareFilter, SecurityContextHolderAwareRequestFilter, AnonymousAuthenticationFilter, SessionManagementFilter, ExceptionTranslationFilter, AuthorizationFilter
2025-08-10 09:35:45.187 [main] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerAdapter - ControllerAdvice beans: 0 @ModelAttribute, 0 @InitBinder, 1 RequestBodyAdvice, 1 ResponseBodyAdvice
2025-08-10 09:35:45.223 [main] DEBUG o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - ControllerAdvice beans: 0 @ExceptionHandler, 1 ResponseBodyAdvice
2025-08-10 09:35:45.476 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8081"]
2025-08-10 09:35:45.482 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port 8081 (http) with context path '/'
2025-08-10 09:35:45.652 [main] INFO  com.yizhaoqi.smartpai.SmartPaiApplication - Started SmartPaiApplication in 4.379 seconds (process running for 4.728)
2025-08-10 09:35:45.657 [main] INFO  com.yizhaoqi.smartpai.config.AdminUserInitializer - 检查管理员账号是否存在: admin
2025-08-10 09:35:45.735 [main] INFO  com.yizhaoqi.smartpai.config.AdminUserInitializer - 管理员账号 'admin' 已存在，跳过创建步骤
2025-08-10 09:35:45.737 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 检查组织标签是否存在: default
2025-08-10 09:35:45.741 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 组织标签 'default' 已存在，跳过创建步骤
2025-08-10 09:35:45.741 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 检查组织标签是否存在: admin
2025-08-10 09:35:45.742 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 组织标签 'admin' 已存在，跳过创建步骤
2025-08-10 09:35:45.742 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 组织标签初始化完成
2025-08-10 09:35:45.781 [main] INFO  com.yizhaoqi.smartpai.config.EsIndexInitializer - 索引 'knowledge_base' 已存在
2025-08-10 09:35:46.302 [RMI TCP Connection(3)-192.168.1.3] INFO  o.a.c.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-08-10 09:35:46.302 [RMI TCP Connection(3)-192.168.1.3] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-08-10 09:35:46.302 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected StandardServletMultipartResolver
2025-08-10 09:35:46.302 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected AcceptHeaderLocaleResolver
2025-08-10 09:35:46.302 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected FixedThemeResolver
2025-08-10 09:35:46.303 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator@6cc45cf2
2025-08-10 09:35:46.303 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected org.springframework.web.servlet.support.SessionFlashMapManager@182c3b79
2025-08-10 09:35:46.303 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - enableLoggingRequestDetails='false': request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data
2025-08-10 09:35:46.303 [RMI TCP Connection(3)-192.168.1.3] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 1 ms
2025-08-10 09:36:22.681 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /test.html
2025-08-10 09:36:22.691 [http-nio-8081-exec-1] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.693 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /test.html
2025-08-10 09:36:22.695 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/test.html", parameters={}
2025-08-10 09:36:22.696 [http-nio-8081-exec-1] DEBUG o.s.web.servlet.handler.SimpleUrlHandlerMapping - Mapped to ResourceHttpRequestHandler [classpath [static/], classpath [public/], classpath [resources/], classpath [META-INF/resources/]]
2025-08-10 09:36:22.785 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 09:36:22.833 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:36:22.835 [http-nio-8081-exec-4] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.836 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/upload-orgs
2025-08-10 09:36:22.836 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/documents/uploads
2025-08-10 09:36:22.836 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:36:22.836 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs", parameters={}
2025-08-10 09:36:22.836 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 09:36:22.836 [http-nio-8081-exec-4] DEBUG o.s.w.s.server.support.WebSocketHandlerMapping - Mapped to org.springframework.web.socket.server.support.WebSocketHttpRequestHandler@59e0cb10
2025-08-10 09:36:22.839 [http-nio-8081-exec-4] DEBUG o.s.w.s.server.support.WebSocketHttpRequestHandler - GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:36:22.856 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /favicon.ico
2025-08-10 09:36:22.862 [http-nio-8081-exec-5] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.864 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /favicon.ico
2025-08-10 09:36:22.864 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/favicon.ico", parameters={}
2025-08-10 09:36:22.864 [http-nio-8081-exec-5] DEBUG o.s.web.servlet.handler.SimpleUrlHandlerMapping - Mapped to ResourceHttpRequestHandler [classpath [static/], classpath [public/], classpath [resources/], classpath [META-INF/resources/]]
2025-08-10 09:36:22.865 [http-nio-8081-exec-5] DEBUG o.s.w.servlet.resource.ResourceHttpRequestHandler - Resource not found
2025-08-10 09:36:22.868 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.support.DefaultHandlerExceptionResolver - Resolved [org.springframework.web.servlet.resource.NoResourceFoundException: No static resource favicon.ico.]
2025-08-10 09:36:22.868 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 404 NOT_FOUND
2025-08-10 09:36:22.870 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 101 SWITCHING_PROTOCOLS
2025-08-10 09:36:22.884 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:36:22.885 [http-nio-8081-exec-5] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.889 [http-nio-8081-exec-5] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:36:22.894 [http-nio-8081-exec-4] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - New StandardWebSocketSession[id=68d41e6a-bfe1-cba5-917c-d6a0462662ff, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs]
2025-08-10 09:36:22.896 [http-nio-8081-exec-4] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - WebSocket连接已建立，用户ID: sy，会话ID: 68d41e6a-bfe1-cba5-917c-d6a0462662ff，URI路径: /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:36:22.913 [http-nio-8081-exec-7] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.913 [http-nio-8081-exec-6] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理获取用户文档请求: /api/v1/documents/uploads
2025-08-10 09:36:22.913 [http-nio-8081-exec-2] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.914 [http-nio-8081-exec-7] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:36:22.914 [http-nio-8081-exec-2] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:36:22.915 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:36:22.915 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:36:22.915 [http-nio-8081-exec-7] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.915 [http-nio-8081-exec-2] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.916 [http-nio-8081-exec-2] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:36:22.916 [http-nio-8081-exec-7] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:36:22.916 [http-nio-8081-exec-6] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.917 [http-nio-8081-exec-6] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:36:22.918 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:36:22.918 [http-nio-8081-exec-6] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:36:22.919 [http-nio-8081-exec-6] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:36:40.738 [http-nio-8081-exec-9] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - 接收到消息，用户ID: sy，会话ID: 68d41e6a-bfe1-cba5-917c-d6a0462662ff，消息长度: 6
2025-08-10 09:36:40.739 [http-nio-8081-exec-9] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 开始处理消息，用户ID: sy, 会话ID: 68d41e6a-bfe1-cba5-917c-d6a0462662ff
2025-08-10 09:36:40.749 [http-nio-8081-exec-9] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 获取到用户 sy 的现有会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5
2025-08-10 09:36:40.749 [http-nio-8081-exec-9] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5, 用户ID: sy
2025-08-10 09:36:40.751 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 会话 be50466b-3844-4160-b47f-c03bfbca5bf5 没有历史记录
2025-08-10 09:36:40.751 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 获取到 0 条历史对话
2025-08-10 09:36:40.751 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 开始带权限搜索，查询: 请解释VIT, 用户ID: sy
2025-08-10 09:36:40.751 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户有效组织标签，用户ID: sy
2025-08-10 09:36:40.751 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: sy
2025-08-10 09:36:40.755 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: sy
2025-08-10 09:36:40.765 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的有效组织标签: [PRIVATE_sy, DEFAULT]
2025-08-10 09:36:40.765 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的有效组织标签: [PRIVATE_sy, DEFAULT]
2025-08-10 09:36:40.765 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户数据库ID，用户ID: sy
2025-08-10 09:36:40.765 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: sy
2025-08-10 09:36:40.768 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: sy, ID: 2
2025-08-10 09:36:40.769 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的数据库ID: 2
2025-08-10 09:36:40.769 [http-nio-8081-exec-9] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 1
2025-08-10 09:36:40.802 [http-nio-8081-exec-9] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [71da893b] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 09:36:41.124 [reactor-http-nio-2] DEBUG org.springframework.web.HttpLogging - [71da893b] Encoding [{input=[请解释VIT], encoding_format=float, model=text-embedding-v4, dimension=2048}]
2025-08-10 09:36:41.304 [reactor-http-nio-2] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [71da893b] [0713a204-1] Response 200 OK
2025-08-10 09:36:41.324 [reactor-http-nio-2] DEBUG org.springframework.web.HttpLogging - [71da893b] [0713a204-1] Decoded "{"data":[{"embedding":[-0.01192111149430275,0.026192300021648407,-0.010178640484809875,0.02583074942 (truncated)..."
2025-08-10 09:36:41.340 [http-nio-8081-exec-9] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 成功生成向量，总数量: 1
2025-08-10 09:36:41.341 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 向量生成成功，开始执行混合搜索 KNN
2025-08-10 09:36:41.630 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - Elasticsearch查询执行完成，命中数量: 0, 最大分数: NaN
2025-08-10 09:36:41.632 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 返回搜索结果数量: 0
2025-08-10 09:36:41.632 [http-nio-8081-exec-9] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 搜索结果数量: 0
2025-08-10 09:36:41.632 [http-nio-8081-exec-9] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 调用DeepSeek API生成回复
2025-08-10 09:36:41.634 [http-nio-8081-exec-9] INFO  com.yizhaoqi.smartpai.client.DeepSeekClient - 构建请求，用户消息：请解释VIT，上下文长度：0，历史消息数：0
2025-08-10 09:36:41.635 [http-nio-8081-exec-9] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [6b57eec2] HTTP POST https://api.deepseek.com/v1/chat/completions
2025-08-10 09:36:41.730 [reactor-http-nio-3] DEBUG org.springframework.web.HttpLogging - [6b57eec2] Encoding [{top_p=0.9, stream=true, max_tokens=2000, temperature=0.3, messages=[{role=system, content=你是派聪明知识助手 (truncated)...]
2025-08-10 09:36:41.819 [reactor-http-nio-3] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [6b57eec2] [85c2381d-1] Response 401 UNAUTHORIZED
2025-08-10 09:36:41.826 [reactor-http-nio-3] DEBUG org.springframework.web.HttpLogging - [6b57eec2] [85c2381d-1] Read 148 bytes
2025-08-10 09:36:41.834 [reactor-http-nio-3] ERROR com.yizhaoqi.smartpai.service.ChatHandler - AI服务错误: 401 Unauthorized from POST https://api.deepseek.com/v1/chat/completions
org.springframework.web.reactive.function.client.WebClientResponseException$Unauthorized: 401 Unauthorized from POST https://api.deepseek.com/v1/chat/completions
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:322)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 401 UNAUTHORIZED from POST https://api.deepseek.com/v1/chat/completions [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:322)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 09:36:41.837 [reactor-http-nio-3] ERROR com.yizhaoqi.smartpai.service.ChatHandler - 发送错误消息到会话 68d41e6a-bfe1-cba5-917c-d6a0462662ff: {"error":"AI服务暂时不可用，请稍后重试"}
2025-08-10 09:36:41.839 [reactor-http-nio-3] ERROR com.yizhaoqi.smartpai.service.ChatHandler - 已发送错误消息到会话: 68d41e6a-bfe1-cba5-917c-d6a0462662ff
2025-08-10 09:36:41.839 [reactor-http-nio-3] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 发送完成通知到会话 68d41e6a-bfe1-cba5-917c-d6a0462662ff: {"type":"completion","date":"2025-08-10T09:36:41.839382600","timestamp":1754789801839,"message":"响应已完成","status":"finished"}
2025-08-10 09:36:41.839 [reactor-http-nio-3] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 已发送响应完成通知到会话: 68d41e6a-bfe1-cba5-917c-d6a0462662ff
2025-08-10 09:36:44.651 [Thread-35] WARN  com.yizhaoqi.smartpai.service.ChatHandler - 响应构建器为空，可能出现了错误，会话ID: 68d41e6a-bfe1-cba5-917c-d6a0462662ff
2025-08-10 09:36:44.652 [Thread-35] ERROR com.yizhaoqi.smartpai.service.ChatHandler - AI服务错误: 响应构建器为空
java.lang.RuntimeException: 响应构建器为空
	at com.yizhaoqi.smartpai.service.ChatHandler.lambda$processMessage$2(ChatHandler.java:196)
	at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 09:36:44.653 [Thread-35] ERROR com.yizhaoqi.smartpai.service.ChatHandler - 发送错误消息到会话 68d41e6a-bfe1-cba5-917c-d6a0462662ff: {"error":"AI服务暂时不可用，请稍后重试"}
2025-08-10 09:36:44.654 [Thread-35] ERROR com.yizhaoqi.smartpai.service.ChatHandler - 已发送错误消息到会话: 68d41e6a-bfe1-cba5-917c-d6a0462662ff
2025-08-10 09:37:34.436 [SpringApplicationShutdownHook] INFO  o.s.boot.web.embedded.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-08-10 09:37:34.527 [tomcat-shutdown] INFO  o.s.boot.web.embedded.tomcat.GracefulShutdown - Graceful shutdown complete
2025-08-10 09:57:43.028 [main] INFO  com.yizhaoqi.smartpai.SmartPaiApplication - Starting SmartPaiApplication using Java 17.0.16 with PID 24020 (E:\JavaProject\PaiSmart-main\PaiSmart-main\target\classes started by SongYu in E:\JavaProject\PaiSmart-main)
2025-08-10 09:57:43.029 [main] INFO  com.yizhaoqi.smartpai.SmartPaiApplication - No active profile set, falling back to 1 default profile: "default"
2025-08-10 09:57:44.094 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat initialized with port 8081 (http)
2025-08-10 09:57:44.100 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Initializing ProtocolHandler ["http-nio-8081"]
2025-08-10 09:57:44.101 [main] INFO  org.apache.catalina.core.StandardService - Starting service [Tomcat]
2025-08-10 09:57:44.101 [main] INFO  org.apache.catalina.core.StandardEngine - Starting Servlet engine: [Apache Tomcat/10.1.34]
2025-08-10 09:57:44.140 [main] INFO  o.a.c.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring embedded WebApplicationContext
2025-08-10 09:57:44.140 [main] INFO  o.s.b.w.s.c.ServletWebServerApplicationContext - Root WebApplicationContext: initialization completed in 1090 ms
2025-08-10 09:57:44.435 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Starting...
2025-08-10 09:57:44.522 [main] INFO  com.zaxxer.hikari.pool.HikariPool - HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@6d01f2e5
2025-08-10 09:57:44.522 [main] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Start completed.
2025-08-10 09:57:44.545 [main] WARN  org.hibernate.orm.deprecation - HHH90000025: MySQL8Dialect does not need to be specified explicitly using 'hibernate.dialect' (remove the property setting and it will be selected by default)
2025-08-10 09:57:44.545 [main] WARN  org.hibernate.orm.deprecation - HHH90000026: MySQL8Dialect has been deprecated; use org.hibernate.dialect.MySQLDialect instead
2025-08-10 09:57:45.669 [main] DEBUG o.s.web.filter.ServerHttpObservationFilter - Filter 'webMvcObservationFilter' configured for use
2025-08-10 09:57:46.170 [main] WARN  o.s.b.a.o.j.JpaBaseConfiguration$JpaWebConfiguration - spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-08-10 09:57:46.191 [main] INFO  o.s.s.c.a.a.c.InitializeUserDetailsBeanManagerConfigurer$InitializeUserDetailsManagerConfigurer - Global AuthenticationManager configured with UserDetailsService bean with name customUserDetailsService
2025-08-10 09:57:46.234 [main] DEBUG o.s.w.s.server.support.WebSocketHandlerMapping - Patterns [/chat/{token}] in 'webSocketHandlerMapping'
2025-08-10 09:57:46.312 [main] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - 40 mappings in 'requestMappingHandlerMapping'
2025-08-10 09:57:46.337 [main] DEBUG o.s.web.servlet.handler.SimpleUrlHandlerMapping - Patterns [/webjars/**, /**, /static/**] in 'resourceHandlerMapping'
2025-08-10 09:57:46.437 [main] INFO  o.s.b.actuate.endpoint.web.EndpointLinksResolver - Exposing 1 endpoint beneath base path '/actuator'
2025-08-10 09:57:46.468 [main] INFO  com.yizhaoqi.smartpai.config.SecurityConfig - Security configuration loaded successfully.
2025-08-10 09:57:46.484 [main] DEBUG o.s.security.web.DefaultSecurityFilterChain - Will secure any request with filters: DisableEncodeUrlFilter, WebAsyncManagerIntegrationFilter, SecurityContextHolderFilter, HeaderWriterFilter, LogoutFilter, JwtAuthenticationFilter, OrgTagAuthorizationFilter, RequestCacheAwareFilter, SecurityContextHolderAwareRequestFilter, AnonymousAuthenticationFilter, SessionManagementFilter, ExceptionTranslationFilter, AuthorizationFilter
2025-08-10 09:57:46.534 [main] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerAdapter - ControllerAdvice beans: 0 @ModelAttribute, 0 @InitBinder, 1 RequestBodyAdvice, 1 ResponseBodyAdvice
2025-08-10 09:57:46.564 [main] DEBUG o.s.w.s.m.m.a.ExceptionHandlerExceptionResolver - ControllerAdvice beans: 0 @ExceptionHandler, 1 ResponseBodyAdvice
2025-08-10 09:57:46.838 [main] INFO  org.apache.coyote.http11.Http11NioProtocol - Starting ProtocolHandler ["http-nio-8081"]
2025-08-10 09:57:46.844 [main] INFO  o.s.boot.web.embedded.tomcat.TomcatWebServer - Tomcat started on port 8081 (http) with context path '/'
2025-08-10 09:57:46.948 [main] INFO  com.yizhaoqi.smartpai.SmartPaiApplication - Started SmartPaiApplication in 4.239 seconds (process running for 4.604)
2025-08-10 09:57:46.953 [main] INFO  com.yizhaoqi.smartpai.config.AdminUserInitializer - 检查管理员账号是否存在: admin
2025-08-10 09:57:47.025 [main] INFO  com.yizhaoqi.smartpai.config.AdminUserInitializer - 管理员账号 'admin' 已存在，跳过创建步骤
2025-08-10 09:57:47.027 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 检查组织标签是否存在: default
2025-08-10 09:57:47.030 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 组织标签 'default' 已存在，跳过创建步骤
2025-08-10 09:57:47.030 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 检查组织标签是否存在: admin
2025-08-10 09:57:47.031 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 组织标签 'admin' 已存在，跳过创建步骤
2025-08-10 09:57:47.031 [main] INFO  com.yizhaoqi.smartpai.config.OrgTagInitializer - 组织标签初始化完成
2025-08-10 09:57:47.072 [main] INFO  com.yizhaoqi.smartpai.config.EsIndexInitializer - 索引 'knowledge_base' 已存在
2025-08-10 09:57:47.242 [RMI TCP Connection(3)-192.168.1.3] INFO  o.a.c.core.ContainerBase.[Tomcat].[localhost].[/] - Initializing Spring DispatcherServlet 'dispatcherServlet'
2025-08-10 09:57:47.242 [RMI TCP Connection(3)-192.168.1.3] INFO  org.springframework.web.servlet.DispatcherServlet - Initializing Servlet 'dispatcherServlet'
2025-08-10 09:57:47.242 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected StandardServletMultipartResolver
2025-08-10 09:57:47.242 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected AcceptHeaderLocaleResolver
2025-08-10 09:57:47.242 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected FixedThemeResolver
2025-08-10 09:57:47.242 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator@466aee52
2025-08-10 09:57:47.243 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - Detected org.springframework.web.servlet.support.SessionFlashMapManager@5cc6a1ec
2025-08-10 09:57:47.243 [RMI TCP Connection(3)-192.168.1.3] DEBUG org.springframework.web.servlet.DispatcherServlet - enableLoggingRequestDetails='false': request parameters and headers will be masked to prevent unsafe logging of potentially sensitive data
2025-08-10 09:57:47.243 [RMI TCP Connection(3)-192.168.1.3] INFO  org.springframework.web.servlet.DispatcherServlet - Completed initialization in 1 ms
2025-08-10 09:57:52.744 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /test.html
2025-08-10 09:57:52.751 [http-nio-8081-exec-2] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.753 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /test.html
2025-08-10 09:57:52.755 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/test.html", parameters={}
2025-08-10 09:57:52.756 [http-nio-8081-exec-2] DEBUG o.s.web.servlet.handler.SimpleUrlHandlerMapping - Mapped to ResourceHttpRequestHandler [classpath [static/], classpath [public/], classpath [resources/], classpath [META-INF/resources/]]
2025-08-10 09:57:52.762 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 09:57:52.867 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/upload-orgs
2025-08-10 09:57:52.867 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/documents/uploads
2025-08-10 09:57:52.867 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 09:57:52.867 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:57:52.869 [http-nio-8081-exec-5] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.870 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:57:52.870 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs", parameters={}
2025-08-10 09:57:52.870 [http-nio-8081-exec-5] DEBUG o.s.w.s.server.support.WebSocketHandlerMapping - Mapped to org.springframework.web.socket.server.support.WebSocketHttpRequestHandler@2dfab333
2025-08-10 09:57:52.872 [http-nio-8081-exec-5] DEBUG o.s.w.s.server.support.WebSocketHttpRequestHandler - GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:57:52.886 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 101 SWITCHING_PROTOCOLS
2025-08-10 09:57:52.893 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /favicon.ico
2025-08-10 09:57:52.894 [http-nio-8081-exec-4] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.894 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /favicon.ico
2025-08-10 09:57:52.894 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/favicon.ico", parameters={}
2025-08-10 09:57:52.894 [http-nio-8081-exec-4] DEBUG o.s.web.servlet.handler.SimpleUrlHandlerMapping - Mapped to ResourceHttpRequestHandler [classpath [static/], classpath [public/], classpath [resources/], classpath [META-INF/resources/]]
2025-08-10 09:57:52.895 [http-nio-8081-exec-4] DEBUG o.s.w.servlet.resource.ResourceHttpRequestHandler - Resource not found
2025-08-10 09:57:52.898 [http-nio-8081-exec-5] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - New StandardWebSocketSession[id=f8bcb0fe-52d6-d98b-2da5-62dcb57716d6, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs]
2025-08-10 09:57:52.898 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.support.DefaultHandlerExceptionResolver - Resolved [org.springframework.web.servlet.resource.NoResourceFoundException: No static resource favicon.ico.]
2025-08-10 09:57:52.898 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 404 NOT_FOUND
2025-08-10 09:57:52.900 [http-nio-8081-exec-5] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - WebSocket连接已建立，用户ID: sy，会话ID: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6，URI路径: /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs
2025-08-10 09:57:52.902 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:57:52.903 [http-nio-8081-exec-4] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.905 [http-nio-8081-exec-4] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:57:52.910 [http-nio-8081-exec-3] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.910 [http-nio-8081-exec-1] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.910 [http-nio-8081-exec-6] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理获取用户文档请求: /api/v1/documents/uploads
2025-08-10 09:57:52.910 [http-nio-8081-exec-1] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:57:52.910 [http-nio-8081-exec-3] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:57:52.911 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:57:52.911 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:57:52.911 [http-nio-8081-exec-3] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.911 [http-nio-8081-exec-1] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.911 [http-nio-8081-exec-3] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:57:52.911 [http-nio-8081-exec-1] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:57:52.912 [http-nio-8081-exec-6] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.913 [http-nio-8081-exec-6] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:57:52.913 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 09:57:52.913 [http-nio-8081-exec-6] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 09:57:52.914 [http-nio-8081-exec-6] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 09:58:18.390 [http-nio-8081-exec-8] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - 接收到消息，用户ID: sy，会话ID: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6，消息长度: 22
2025-08-10 09:58:18.391 [http-nio-8081-exec-8] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 开始处理消息，用户ID: sy, 会话ID: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6
2025-08-10 09:58:18.411 [http-nio-8081-exec-8] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 获取到用户 sy 的现有会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5
2025-08-10 09:58:18.411 [http-nio-8081-exec-8] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5, 用户ID: sy
2025-08-10 09:58:18.412 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 会话 be50466b-3844-4160-b47f-c03bfbca5bf5 没有历史记录
2025-08-10 09:58:18.412 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 获取到 0 条历史对话
2025-08-10 09:58:18.412 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 开始带权限搜索，查询: 请你解释一下community-社区论坛项目, 用户ID: sy
2025-08-10 09:58:18.412 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户有效组织标签，用户ID: sy
2025-08-10 09:58:18.412 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: sy
2025-08-10 09:58:18.416 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: sy
2025-08-10 09:58:18.433 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的有效组织标签: [PRIVATE_sy, DEFAULT]
2025-08-10 09:58:18.433 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的有效组织标签: [PRIVATE_sy, DEFAULT]
2025-08-10 09:58:18.433 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户数据库ID，用户ID: sy
2025-08-10 09:58:18.433 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: sy
2025-08-10 09:58:18.438 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: sy, ID: 2
2025-08-10 09:58:18.444 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的数据库ID: 2
2025-08-10 09:58:18.444 [http-nio-8081-exec-8] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 1
2025-08-10 09:58:18.480 [http-nio-8081-exec-8] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5a9f6e94] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 09:58:18.828 [reactor-http-nio-2] DEBUG org.springframework.web.HttpLogging - [5a9f6e94] Encoding [{input=[请你解释一下community-社区论坛项目], encoding_format=float, model=text-embedding-v4, dimension=2048}]
2025-08-10 09:58:19.042 [reactor-http-nio-2] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5a9f6e94] [a2eb55c5-1] Response 200 OK
2025-08-10 09:58:19.062 [reactor-http-nio-2] DEBUG org.springframework.web.HttpLogging - [5a9f6e94] [a2eb55c5-1] Decoded "{"data":[{"embedding":[-0.03293818235397339,0.004918383434414864,0.021461045369505882,-0.05480250716 (truncated)..."
2025-08-10 09:58:19.077 [http-nio-8081-exec-8] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 成功生成向量，总数量: 1
2025-08-10 09:58:19.078 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 向量生成成功，开始执行混合搜索 KNN
2025-08-10 09:58:19.223 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - Elasticsearch查询执行完成，命中数量: 0, 最大分数: NaN
2025-08-10 09:58:19.223 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 返回搜索结果数量: 0
2025-08-10 09:58:19.223 [http-nio-8081-exec-8] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 搜索结果数量: 0
2025-08-10 09:58:19.223 [http-nio-8081-exec-8] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 调用DeepSeek API生成回复
2025-08-10 09:58:19.224 [http-nio-8081-exec-8] INFO  com.yizhaoqi.smartpai.client.DeepSeekClient - 构建请求，用户消息：请你解释一下community-社区论坛项目，上下文长度：0，历史消息数：0
2025-08-10 09:58:19.225 [http-nio-8081-exec-8] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [126f182b] HTTP POST https://api.deepseek.com/v1/chat/completions
2025-08-10 09:58:19.359 [reactor-http-nio-3] DEBUG org.springframework.web.HttpLogging - [126f182b] Encoding [{top_p=0.9, stream=true, max_tokens=2000, temperature=0.3, messages=[{role=system, content=你是派聪明知识助手 (truncated)...]
2025-08-10 09:58:19.486 [reactor-http-nio-3] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [126f182b] [5dd45995-1] Response 200 OK
2025-08-10 09:58:21.887 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"暂无"}
2025-08-10 09:58:22.614 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"相关信息"}
2025-08-10 09:58:22.688 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:58:22.800 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:58:22.801 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"原因"}
2025-08-10 09:58:22.802 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:58:22.837 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"当前"}
2025-08-10 09:58:22.840 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"未"}
2025-08-10 09:58:22.955 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"提供"}
2025-08-10 09:58:22.957 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"关于"}
2025-08-10 09:58:22.986 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"该"}
2025-08-10 09:58:23.065 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"项目的"}
2025-08-10 09:58:23.138 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"具体"}
2025-08-10 09:58:23.140 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"背景"}
2025-08-10 09:58:23.213 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"、"}
2025-08-10 09:58:23.214 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"功能"}
2025-08-10 09:58:23.288 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"或"}
2025-08-10 09:58:23.362 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"技术"}
2025-08-10 09:58:23.362 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"细节"}
2025-08-10 09:58:23.438 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"等"}
2025-08-10 09:58:23.439 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"参考"}
2025-08-10 09:58:23.512 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"内容"}
2025-08-10 09:58:23.514 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:58:23.585 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"无法"}
2025-08-10 09:58:23.586 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"进行"}
2025-08-10 09:58:23.663 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"针对性"}
2025-08-10 09:58:23.664 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"分析"}
2025-08-10 09:58:23.733 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:58:23.734 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"建议"}
2025-08-10 09:58:23.811 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"补充"}
2025-08-10 09:58:23.812 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"项目"}
2025-08-10 09:58:23.884 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"描述"}
2025-08-10 09:58:23.959 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"、"}
2025-08-10 09:58:24.036 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"需求"}
2025-08-10 09:58:24.112 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"文档"}
2025-08-10 09:58:24.114 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"或"}
2025-08-10 09:58:24.197 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"相关"}
2025-08-10 09:58:24.198 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"材料"}
2025-08-10 09:58:24.235 [Thread-35] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 响应仍在继续，等待完成...
2025-08-10 09:58:24.262 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"以便"}
2025-08-10 09:58:24.263 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"进一步"}
2025-08-10 09:58:24.336 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"解答"}
2025-08-10 09:58:24.337 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:58:31.258 [Thread-35] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 发送完成通知到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"status":"finished","type":"completion","date":"2025-08-10T09:58:31.258722","timestamp":1754791111258,"message":"响应已完成"}
2025-08-10 09:58:31.258 [Thread-35] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 已发送响应完成通知到会话: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6
2025-08-10 09:58:31.260 [Thread-35] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 会话 be50466b-3844-4160-b47f-c03bfbca5bf5 没有历史记录
2025-08-10 09:58:31.320 [Thread-35] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 更新会话历史，会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5, 总消息数: 2
2025-08-10 09:58:31.320 [Thread-35] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 对话存储信息 - Redis键: user:sy:current_conversation, 值: be50466b-3844-4160-b47f-c03bfbca5bf5
2025-08-10 09:58:31.320 [Thread-35] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 消息处理完成，用户ID: sy
2025-08-10 09:59:27.353 [http-nio-8081-exec-5] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - 接收到消息，用户ID: sy，会话ID: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6，消息长度: 8
2025-08-10 09:59:27.353 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 开始处理消息，用户ID: sy, 会话ID: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6
2025-08-10 09:59:27.354 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 获取到用户 sy 的现有会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5
2025-08-10 09:59:27.354 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5, 用户ID: sy
2025-08-10 09:59:27.356 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 读取到会话 be50466b-3844-4160-b47f-c03bfbca5bf5 的 2 条历史记录
2025-08-10 09:59:27.356 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 获取到 2 条历史对话
2025-08-10 09:59:27.356 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 开始带权限搜索，查询: 请你解释下RAG, 用户ID: sy
2025-08-10 09:59:27.356 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户有效组织标签，用户ID: sy
2025-08-10 09:59:27.356 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: sy
2025-08-10 09:59:27.360 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: sy
2025-08-10 09:59:27.361 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的有效组织标签: [PRIVATE_sy, DEFAULT]
2025-08-10 09:59:27.361 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的有效组织标签: [PRIVATE_sy, DEFAULT]
2025-08-10 09:59:27.361 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户数据库ID，用户ID: sy
2025-08-10 09:59:27.362 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: sy
2025-08-10 09:59:27.365 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: sy, ID: 2
2025-08-10 09:59:27.365 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 sy 的数据库ID: 2
2025-08-10 09:59:27.365 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 1
2025-08-10 09:59:27.366 [http-nio-8081-exec-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [21bec470] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 09:59:27.368 [reactor-http-nio-2] DEBUG org.springframework.web.HttpLogging - [21bec470] Encoding [{input=[请你解释下RAG], encoding_format=float, model=text-embedding-v4, dimension=2048}]
2025-08-10 09:59:27.500 [reactor-http-nio-2] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [21bec470] [a2eb55c5-2] Response 200 OK
2025-08-10 09:59:27.504 [reactor-http-nio-2] DEBUG org.springframework.web.HttpLogging - [21bec470] [a2eb55c5-2] Decoded "{"data":[{"embedding":[-0.028784889727830887,-0.011884515173733234,0.022049307823181152,-0.025181660 (truncated)..."
2025-08-10 09:59:27.506 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 成功生成向量，总数量: 1
2025-08-10 09:59:27.506 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 向量生成成功，开始执行混合搜索 KNN
2025-08-10 09:59:27.522 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - Elasticsearch查询执行完成，命中数量: 0, 最大分数: NaN
2025-08-10 09:59:27.522 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 返回搜索结果数量: 0
2025-08-10 09:59:27.522 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 搜索结果数量: 0
2025-08-10 09:59:27.522 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 调用DeepSeek API生成回复
2025-08-10 09:59:27.522 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.client.DeepSeekClient - 构建请求，用户消息：请你解释下RAG，上下文长度：0，历史消息数：2
2025-08-10 09:59:27.522 [http-nio-8081-exec-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7ca15ad7] HTTP POST https://api.deepseek.com/v1/chat/completions
2025-08-10 09:59:27.523 [reactor-http-nio-3] DEBUG org.springframework.web.HttpLogging - [7ca15ad7] Encoding [{top_p=0.9, stream=true, max_tokens=2000, temperature=0.3, messages=[{role=system, content=你是派聪明知识助手 (truncated)...]
2025-08-10 09:59:27.581 [reactor-http-nio-3] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7ca15ad7] [5dd45995-2] Response 200 OK
2025-08-10 09:59:30.661 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:31.373 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"结论"}
2025-08-10 09:59:31.447 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:31.449 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:31.522 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:31.523 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"R"}
2025-08-10 09:59:31.596 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"AG"}
2025-08-10 09:59:31.597 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:31.669 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"Ret"}
2025-08-10 09:59:31.671 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"rie"}
2025-08-10 09:59:31.745 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"val"}
2025-08-10 09:59:31.746 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"-Aug"}
2025-08-10 09:59:31.817 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"mented"}
2025-08-10 09:59:31.818 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" Generation"}
2025-08-10 09:59:31.892 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:31.894 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"检索"}
2025-08-10 09:59:31.967 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"增强"}
2025-08-10 09:59:31.968 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"生成"}
2025-08-10 09:59:32.041 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"）"}
2025-08-10 09:59:32.042 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"是一种"}
2025-08-10 09:59:32.116 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"结合"}
2025-08-10 09:59:32.117 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"信息"}
2025-08-10 09:59:32.189 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"检索"}
2025-08-10 09:59:32.189 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"与"}
2025-08-10 09:59:32.264 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"文本"}
2025-08-10 09:59:32.341 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"生成"}
2025-08-10 09:59:32.342 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"的技术"}
2025-08-10 09:59:32.412 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:32.413 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"旨在"}
2025-08-10 09:59:32.489 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"提升"}
2025-08-10 09:59:32.489 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"生成"}
2025-08-10 09:59:32.543 [Thread-36] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 响应仍在继续，等待完成...
2025-08-10 09:59:32.563 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"内容的"}
2025-08-10 09:59:32.564 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"准确"}
2025-08-10 09:59:32.641 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"性和"}
2025-08-10 09:59:32.642 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"相关性"}
2025-08-10 09:59:32.715 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:59:32.789 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n\n"}
2025-08-10 09:59:32.790 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:32.790 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"论"}
2025-08-10 09:59:32.865 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"据"}
2025-08-10 09:59:32.867 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:32.942 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:33.018 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:33.018 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"1"}
2025-08-10 09:59:33.019 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"."}
2025-08-10 09:59:33.091 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:33.092 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"核心"}
2025-08-10 09:59:33.164 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"原理"}
2025-08-10 09:59:33.165 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:33.240 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:33.317 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:33.317 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  "}
2025-08-10 09:59:33.318 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" -"}
2025-08-10 09:59:33.394 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:33.395 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"检索"}
2025-08-10 09:59:33.467 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"阶段"}
2025-08-10 09:59:33.468 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:33.542 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:33.543 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"根据"}
2025-08-10 09:59:33.616 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"用户"}
2025-08-10 09:59:33.616 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"输入"}
2025-08-10 09:59:33.690 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"的问题"}
2025-08-10 09:59:33.766 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"或"}
2025-08-10 09:59:33.840 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"关键词"}
2025-08-10 09:59:33.840 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:33.916 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"从"}
2025-08-10 09:59:33.917 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"外部"}
2025-08-10 09:59:33.992 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"知识"}
2025-08-10 09:59:33.993 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"库"}
2025-08-10 09:59:34.068 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:34.069 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"如"}
2025-08-10 09:59:34.141 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"数据库"}
2025-08-10 09:59:34.141 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"、"}
2025-08-10 09:59:34.216 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"文档"}
2025-08-10 09:59:34.217 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"集"}
2025-08-10 09:59:34.289 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"）"}
2025-08-10 09:59:34.289 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"中"}
2025-08-10 09:59:34.364 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"检索"}
2025-08-10 09:59:34.364 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"相关"}
2025-08-10 09:59:34.439 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"片段"}
2025-08-10 09:59:34.440 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:59:34.513 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:34.513 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  "}
2025-08-10 09:59:34.589 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" -"}
2025-08-10 09:59:34.590 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:34.669 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"生成"}
2025-08-10 09:59:34.670 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"阶段"}
2025-08-10 09:59:34.739 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:34.740 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:34.813 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"将"}
2025-08-10 09:59:34.813 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"检索"}
2025-08-10 09:59:34.888 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"到的"}
2025-08-10 09:59:34.889 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"信息"}
2025-08-10 09:59:34.962 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"与"}
2025-08-10 09:59:35.038 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"输入"}
2025-08-10 09:59:35.113 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"结合"}
2025-08-10 09:59:35.195 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:35.195 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"通过"}
2025-08-10 09:59:35.263 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"生成"}
2025-08-10 09:59:35.340 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"模型"}
2025-08-10 09:59:35.341 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:35.416 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"如"}
2025-08-10 09:59:35.416 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"GPT"}
2025-08-10 09:59:35.513 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"）"}
2025-08-10 09:59:35.513 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"输出"}
2025-08-10 09:59:35.669 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"更"}
2025-08-10 09:59:35.670 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"精准"}
2025-08-10 09:59:35.670 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"的"}
2025-08-10 09:59:35.670 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"答案"}
2025-08-10 09:59:35.716 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:59:35.796 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n\n"}
2025-08-10 09:59:35.796 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"2"}
2025-08-10 09:59:35.796 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"."}
2025-08-10 09:59:35.871 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:35.871 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"优势"}
2025-08-10 09:59:35.945 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:35.946 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:36.022 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:36.022 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  "}
2025-08-10 09:59:36.097 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" -"}
2025-08-10 09:59:36.097 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:36.173 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"减少"}
2025-08-10 09:59:36.250 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"幻觉"}
2025-08-10 09:59:36.250 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:36.326 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:36.327 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"依赖"}
2025-08-10 09:59:36.403 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"检索"}
2025-08-10 09:59:36.404 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"到的"}
2025-08-10 09:59:36.495 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"真实"}
2025-08-10 09:59:36.496 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"数据"}
2025-08-10 09:59:36.554 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:36.554 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"降低"}
2025-08-10 09:59:36.632 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"模型"}
2025-08-10 09:59:36.706 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"编"}
2025-08-10 09:59:36.781 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"造"}
2025-08-10 09:59:36.781 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"信息的"}
2025-08-10 09:59:36.860 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"风险"}
2025-08-10 09:59:36.934 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:59:37.011 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:37.011 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  "}
2025-08-10 09:59:37.011 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" -"}
2025-08-10 09:59:37.087 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:37.088 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"动态"}
2025-08-10 09:59:37.163 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"更新"}
2025-08-10 09:59:37.163 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:37.241 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:37.241 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"知识"}
2025-08-10 09:59:37.314 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"库"}
2025-08-10 09:59:37.315 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"可"}
2025-08-10 09:59:37.391 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"独立"}
2025-08-10 09:59:37.391 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"更新"}
2025-08-10 09:59:37.465 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:37.466 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"无需"}
2025-08-10 09:59:37.540 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"重新"}
2025-08-10 09:59:37.542 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"训练"}
2025-08-10 09:59:37.616 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"生成"}
2025-08-10 09:59:37.691 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"模型"}
2025-08-10 09:59:37.691 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:59:37.782 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n\n"}
2025-08-10 09:59:37.782 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"3"}
2025-08-10 09:59:37.843 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"."}
2025-08-10 09:59:37.843 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:37.916 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"应用"}
2025-08-10 09:59:37.993 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"场景"}
2025-08-10 09:59:37.994 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:38.069 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:38.146 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:38.147 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  "}
2025-08-10 09:59:38.147 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" -"}
2025-08-10 09:59:38.219 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" "}
2025-08-10 09:59:38.220 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"客服"}
2025-08-10 09:59:38.296 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"系统"}
2025-08-10 09:59:38.370 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:38.370 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"基于"}
2025-08-10 09:59:38.446 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"文档"}
2025-08-10 09:59:38.520 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"生成"}
2025-08-10 09:59:38.596 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"回答"}
2025-08-10 09:59:38.596 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"）、"}
2025-08-10 09:59:38.672 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"教育"}
2025-08-10 09:59:38.745 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"问答"}
2025-08-10 09:59:38.823 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:38.823 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"引用"}
2025-08-10 09:59:38.896 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"权威"}
2025-08-10 09:59:38.977 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"资料"}
2025-08-10 09:59:38.978 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"）、"}
2025-08-10 09:59:39.049 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"医疗"}
2025-08-10 09:59:39.123 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"咨询"}
2025-08-10 09:59:39.198 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:39.198 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"结合"}
2025-08-10 09:59:39.273 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"最新"}
2025-08-10 09:59:39.273 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"研究"}
2025-08-10 09:59:39.348 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"）"}
2025-08-10 09:59:39.349 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"等"}
2025-08-10 09:59:39.432 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:59:39.499 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n\n"}
2025-08-10 09:59:39.500 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"4"}
2025-08-10 09:59:39.500 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"."}
2025-08-10 09:59:39.577 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" **"}
2025-08-10 09:59:39.577 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"技术"}
2025-08-10 09:59:39.650 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"实现"}
2025-08-10 09:59:39.724 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"**"}
2025-08-10 09:59:39.724 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:39.798 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n"}
2025-08-10 09:59:39.799 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  "}
2025-08-10 09:59:39.878 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" -"}
2025-08-10 09:59:39.880 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":" "}
2025-08-10 09:59:39.952 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"常用"}
2025-08-10 09:59:39.952 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"框架"}
2025-08-10 09:59:40.035 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"包括"}
2025-08-10 09:59:40.036 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"Lang"}
2025-08-10 09:59:40.101 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"Chain"}
2025-08-10 09:59:40.102 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"、"}
2025-08-10 09:59:40.177 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"Ll"}
2025-08-10 09:59:40.178 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"ama"}
2025-08-10 09:59:40.253 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"Index"}
2025-08-10 09:59:40.254 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"等"}
2025-08-10 09:59:40.327 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:40.327 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"支持"}
2025-08-10 09:59:40.404 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"对"}
2025-08-10 09:59:40.483 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"向量"}
2025-08-10 09:59:40.483 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"数据库"}
2025-08-10 09:59:40.554 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:40.629 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"如"}
2025-08-10 09:59:40.629 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"FA"}
2025-08-10 09:59:40.706 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"ISS"}
2025-08-10 09:59:40.707 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"）"}
2025-08-10 09:59:40.781 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"的"}
2025-08-10 09:59:40.781 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"检索"}
2025-08-10 09:59:40.855 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"与"}
2025-08-10 09:59:40.856 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"集成"}
2025-08-10 09:59:40.931 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。"}
2025-08-10 09:59:41.048 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"  \n\n"}
2025-08-10 09:59:41.048 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"（"}
2025-08-10 09:59:41.083 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"注"}
2025-08-10 09:59:41.085 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"："}
2025-08-10 09:59:41.168 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"若无"}
2025-08-10 09:59:41.169 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"具体"}
2025-08-10 09:59:41.236 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"项目"}
2025-08-10 09:59:41.237 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"或"}
2025-08-10 09:59:41.312 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"技术"}
2025-08-10 09:59:41.312 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"栈"}
2025-08-10 09:59:41.398 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"背景"}
2025-08-10 09:59:41.467 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"，"}
2025-08-10 09:59:41.468 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"分析"}
2025-08-10 09:59:41.538 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"基于"}
2025-08-10 09:59:41.538 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"通用"}
2025-08-10 09:59:41.613 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"R"}
2025-08-10 09:59:41.693 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"AG"}
2025-08-10 09:59:41.694 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"定义"}
2025-08-10 09:59:41.770 [reactor-http-nio-3] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"chunk":"。）"}
2025-08-10 09:59:46.567 [Thread-36] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 发送完成通知到会话 f8bcb0fe-52d6-d98b-2da5-62dcb57716d6: {"status":"finished","type":"completion","date":"2025-08-10T09:59:46.567875100","timestamp":1754791186567,"message":"响应已完成"}
2025-08-10 09:59:46.567 [Thread-36] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 已发送响应完成通知到会话: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6
2025-08-10 09:59:46.569 [Thread-36] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 读取到会话 be50466b-3844-4160-b47f-c03bfbca5bf5 的 2 条历史记录
2025-08-10 09:59:46.605 [Thread-36] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 更新会话历史，会话ID: be50466b-3844-4160-b47f-c03bfbca5bf5, 总消息数: 4
2025-08-10 09:59:46.605 [Thread-36] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 对话存储信息 - Redis键: user:sy:current_conversation, 值: be50466b-3844-4160-b47f-c03bfbca5bf5
2025-08-10 09:59:46.605 [Thread-36] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 消息处理完成，用户ID: sy
2025-08-10 10:00:19.172 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/search/hybrid?query=%E7%A4%BE%E5%8C%BA%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE&topK=10
2025-08-10 10:00:19.180 [http-nio-8081-exec-4] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理混合检索请求: /api/search/hybrid
2025-08-10 10:00:19.183 [http-nio-8081-exec-4] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 10:00:19.188 [http-nio-8081-exec-4] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 10:00:19.189 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error?query=%E7%A4%BE%E5%8C%BA%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE&topK=10
2025-08-10 10:00:19.189 [http-nio-8081-exec-4] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 10:00:19.189 [http-nio-8081-exec-4] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 10:00:33.326 [http-nio-8081-exec-1] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - StandardWebSocketSession[id=f8bcb0fe-52d6-d98b-2da5-62dcb57716d6, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiUFJJVkFURV9zeSIsIm9yZ1RhZ3MiOiJQUklWQVRFX3N5Iiwicm9sZSI6IlVTRVIiLCJ0b2tlbklkIjoiZjc5MzVkMTAyNTEwNDhiZWI3MjU0MjM2MzlhYzFmZGUiLCJ1c2VySWQiOiIyIiwic3ViIjoic3kiLCJleHAiOjE3NTQ3NTQ2NTN9.kmxNRnMrcXxUE0S5NhJTADKqaqNnsfHEIXF62xgzlUs] closed with CloseStatus[code=1000, reason=null]
2025-08-10 10:00:33.328 [http-nio-8081-exec-1] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - WebSocket连接已关闭，用户ID: sy，会话ID: f8bcb0fe-52d6-d98b-2da5-62dcb57716d6，状态: CloseStatus[code=1000, reason=null]
2025-08-10 10:40:14.927 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing POST /api/v1/users/login
2025-08-10 10:40:14.927 [http-nio-8081-exec-6] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 10:40:14.927 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Secured POST /api/v1/users/login
2025-08-10 10:40:14.928 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - POST "/api/v1/users/login", parameters={}
2025-08-10 10:40:14.928 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#login(UserRequest)
2025-08-10 10:40:14.956 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Read "application/json;charset=UTF-8" to [UserRequest[username=admin, password=admin123]]
2025-08-10 10:40:15.030 [http-nio-8081-exec-6] DEBUG com.yizhaoqi.smartpai.service.TokenCacheService - Token cached: 57b15c10f54c4f3b99718ab3f3cbac41 for user: admin
2025-08-10 10:40:15.030 [http-nio-8081-exec-6] INFO  com.yizhaoqi.smartpai.utils.JwtUtils - Token generated and cached for user: admin, tokenId: 57b15c10f54c4f3b99718ab3f3cbac41
2025-08-10 10:40:15.034 [http-nio-8081-exec-6] DEBUG com.yizhaoqi.smartpai.service.TokenCacheService - Refresh token cached: ee725a5ed9d24837915d8d67dd9aff0c for user: 1
2025-08-10 10:40:15.034 [http-nio-8081-exec-6] INFO  com.yizhaoqi.smartpai.utils.JwtUtils - Refresh token generated and cached for user: admin, refreshTokenId: ee725a5ed9d24837915d8d67dd9aff0c
2025-08-10 10:40:15.037 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:40:15.038 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={refreshToken=eyJhbGciOiJIUzI1NiJ9.eyJyZWZyZXNoVG9rZW5JZCI6ImVlNzI1YTVlZDlkMjQ4Mzc5M (truncated)...]
2025-08-10 10:40:15.040 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:40:15.045 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:40:15.052 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:40:15.052 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:40:15.052 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:40:15.058 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:40:15.058 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:40:15.061 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:40:15.073 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:40:15.375 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:40:15.375 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:40:15.375 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:40:15.379 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:40:15.379 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:40:15.380 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:40:15.393 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/conversation?start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:40:15.399 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/conversation?start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:40:15.399 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/conversation?start_date=2025-08-03&end_date=2025-08-11", parameters={masked}
2025-08-10 10:40:15.400 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.ConversationController#getConversations(String, String, String)
2025-08-10 10:40:15.405 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:40:15.405 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[], message=获取对话历史成功}]
2025-08-10 10:40:15.407 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:40:15.633 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:40:15.633 [http-nio-8081-exec-10] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 10:40:15.633 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:40:15.633 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g", parameters={}
2025-08-10 10:40:15.633 [http-nio-8081-exec-10] DEBUG o.s.w.s.server.support.WebSocketHandlerMapping - Mapped to org.springframework.web.socket.server.support.WebSocketHttpRequestHandler@2dfab333
2025-08-10 10:40:15.633 [http-nio-8081-exec-10] DEBUG o.s.w.s.server.support.WebSocketHttpRequestHandler - GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:40:15.635 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 101 SWITCHING_PROTOCOLS
2025-08-10 10:40:15.635 [http-nio-8081-exec-10] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - New StandardWebSocketSession[id=f283c965-4dac-b871-1f76-4db9e78213ed, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g]
2025-08-10 10:40:15.636 [http-nio-8081-exec-10] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - WebSocket连接已建立，用户ID: admin，会话ID: f283c965-4dac-b871-1f76-4db9e78213ed，URI路径: /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:40:44.527 [http-nio-8081-exec-2] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - 接收到消息，用户ID: admin，会话ID: f283c965-4dac-b871-1f76-4db9e78213ed，消息长度: 10
2025-08-10 10:40:44.528 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 开始处理消息，用户ID: admin, 会话ID: f283c965-4dac-b871-1f76-4db9e78213ed
2025-08-10 10:40:44.530 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 为用户 admin 创建新的会话ID: 0d179fd9-f726-4162-9b54-77919d099732
2025-08-10 10:40:44.530 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 会话ID: 0d179fd9-f726-4162-9b54-77919d099732, 用户ID: admin
2025-08-10 10:40:44.531 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 会话 0d179fd9-f726-4162-9b54-77919d099732 没有历史记录
2025-08-10 10:40:44.531 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 获取到 0 条历史对话
2025-08-10 10:40:44.531 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 开始带权限搜索，查询: 解释一下社区论坛项目, 用户ID: admin
2025-08-10 10:40:44.531 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户有效组织标签，用户ID: admin
2025-08-10 10:40:44.531 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: admin
2025-08-10 10:40:44.536 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: admin
2025-08-10 10:40:44.540 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 admin 的有效组织标签: [DEFAULT]
2025-08-10 10:40:44.540 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 admin 的有效组织标签: [DEFAULT]
2025-08-10 10:40:44.540 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户数据库ID，用户ID: admin
2025-08-10 10:40:44.540 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: admin
2025-08-10 10:40:44.544 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: admin, ID: 1
2025-08-10 10:40:44.544 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 admin 的数据库ID: 1
2025-08-10 10:40:44.544 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 1
2025-08-10 10:40:44.544 [http-nio-8081-exec-2] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [3d96dccb] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 10:40:44.636 [reactor-http-nio-4] DEBUG org.springframework.web.HttpLogging - [3d96dccb] Encoding [{input=[解释一下社区论坛项目], encoding_format=float, model=text-embedding-v4, dimension=2048}]
2025-08-10 10:40:44.800 [reactor-http-nio-4] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [3d96dccb] [1c4b7db5-1] Response 200 OK
2025-08-10 10:40:44.801 [reactor-http-nio-4] DEBUG org.springframework.web.HttpLogging - [3d96dccb] [1c4b7db5-1] Decoded "{"data":[{"embedding":[-0.039039939641952515,0.018346164375543594,0.01804184354841709,-0.04912598431 (truncated)..."
2025-08-10 10:40:44.803 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 成功生成向量，总数量: 1
2025-08-10 10:40:44.803 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 向量生成成功，开始执行混合搜索 KNN
2025-08-10 10:40:44.817 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - Elasticsearch查询执行完成，命中数量: 0, 最大分数: NaN
2025-08-10 10:40:44.817 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 返回搜索结果数量: 0
2025-08-10 10:40:44.817 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 搜索结果数量: 0
2025-08-10 10:40:44.817 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 调用DeepSeek API生成回复
2025-08-10 10:40:44.817 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.client.DeepSeekClient - 构建请求，用户消息：解释一下社区论坛项目，上下文长度：0，历史消息数：0
2025-08-10 10:40:44.818 [http-nio-8081-exec-2] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [2670d5a6] HTTP POST https://api.deepseek.com/v1/chat/completions
2025-08-10 10:40:44.890 [reactor-http-nio-5] DEBUG org.springframework.web.HttpLogging - [2670d5a6] Encoding [{top_p=0.9, stream=true, max_tokens=2000, temperature=0.3, messages=[{role=system, content=你是派聪明知识助手 (truncated)...]
2025-08-10 10:40:44.935 [reactor-http-nio-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [2670d5a6] [e7a3700c-1] Response 200 OK
2025-08-10 10:40:47.854 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"暂无"}
2025-08-10 10:40:48.820 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"相关信息"}
2025-08-10 10:40:48.901 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:40:48.901 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"由于"}
2025-08-10 10:40:48.983 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"未"}
2025-08-10 10:40:49.061 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"提供"}
2025-08-10 10:40:49.061 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"具体的"}
2025-08-10 10:40:49.142 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"社区"}
2025-08-10 10:40:49.143 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"论坛"}
2025-08-10 10:40:49.222 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"项目"}
2025-08-10 10:40:49.223 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"背景"}
2025-08-10 10:40:49.301 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"或"}
2025-08-10 10:40:49.301 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"需求"}
2025-08-10 10:40:49.381 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"描述"}
2025-08-10 10:40:49.460 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:40:49.540 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:40:49.540 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"功能"}
2025-08-10 10:40:49.621 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"定位"}
2025-08-10 10:40:49.621 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:40:49.700 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"技术"}
2025-08-10 10:40:49.700 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"架构"}
2025-08-10 10:40:49.780 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:40:49.780 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"用户"}
2025-08-10 10:40:49.829 [Thread-38] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 响应仍在继续，等待完成...
2025-08-10 10:40:49.858 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"群体"}
2025-08-10 10:40:49.858 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"等"}
2025-08-10 10:40:49.938 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"），"}
2025-08-10 10:40:49.938 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"无法"}
2025-08-10 10:40:50.015 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"给出"}
2025-08-10 10:40:50.017 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"针对性"}
2025-08-10 10:40:50.097 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"分析"}
2025-08-10 10:40:50.097 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:40:50.173 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"建议"}
2025-08-10 10:40:50.175 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"补充"}
2025-08-10 10:40:50.253 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"以下"}
2025-08-10 10:40:50.254 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"信息"}
2025-08-10 10:40:50.351 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"以便"}
2025-08-10 10:40:50.351 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"进一步"}
2025-08-10 10:40:50.412 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"解答"}
2025-08-10 10:40:50.493 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"：\n"}
2025-08-10 10:40:50.493 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"1"}
2025-08-10 10:40:50.494 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"."}
2025-08-10 10:40:50.587 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" "}
2025-08-10 10:40:50.587 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"项目"}
2025-08-10 10:40:50.651 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"类型"}
2025-08-10 10:40:50.652 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:40:50.732 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:40:50.732 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"兴趣"}
2025-08-10 10:40:50.811 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"社区"}
2025-08-10 10:40:50.890 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"/"}
2025-08-10 10:40:50.969 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"技术支持"}
2025-08-10 10:40:51.048 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"论坛"}
2025-08-10 10:40:51.183 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"/"}
2025-08-10 10:40:51.183 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"本地"}
2025-08-10 10:40:51.206 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"生活"}
2025-08-10 10:40:51.206 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"讨论"}
2025-08-10 10:40:51.286 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"等"}
2025-08-10 10:40:51.366 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）\n"}
2025-08-10 10:40:51.367 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"2"}
2025-08-10 10:40:51.367 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"."}
2025-08-10 10:40:51.446 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" "}
2025-08-10 10:40:51.446 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"核心"}
2025-08-10 10:40:51.527 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"功能"}
2025-08-10 10:40:51.527 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"需求"}
2025-08-10 10:40:51.606 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:40:51.607 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:40:51.687 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"发"}
2025-08-10 10:40:51.687 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"帖"}
2025-08-10 10:40:51.765 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"回"}
2025-08-10 10:40:51.766 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"帖"}
2025-08-10 10:40:51.848 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"/"}
2025-08-10 10:40:51.849 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"权限"}
2025-08-10 10:40:51.945 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"管理"}
2025-08-10 10:40:51.945 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"/"}
2025-08-10 10:40:52.006 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"内容"}
2025-08-10 10:40:52.006 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"审核"}
2025-08-10 10:40:52.087 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"等"}
2025-08-10 10:40:52.088 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:40:52.167 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"\n"}
2025-08-10 10:40:52.168 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"3"}
2025-08-10 10:40:52.253 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"."}
2025-08-10 10:40:52.253 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" "}
2025-08-10 10:40:52.324 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"技术"}
2025-08-10 10:40:52.325 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"栈"}
2025-08-10 10:40:52.404 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"倾向"}
2025-08-10 10:40:52.483 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:40:52.483 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:40:52.563 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"PHP"}
2025-08-10 10:40:52.564 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"/D"}
2025-08-10 10:40:52.642 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"isc"}
2025-08-10 10:40:52.642 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"ourse"}
2025-08-10 10:40:52.720 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"或"}
2025-08-10 10:40:52.721 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"Node"}
2025-08-10 10:40:52.801 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":".js"}
2025-08-10 10:40:52.801 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"等"}
2025-08-10 10:40:52.880 [reactor-http-nio-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:40:56.855 [Thread-38] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 发送完成通知到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"status":"finished","type":"completion","date":"2025-08-10T10:40:56.855413","timestamp":1754793656855,"message":"响应已完成"}
2025-08-10 10:40:56.855 [Thread-38] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 已发送响应完成通知到会话: f283c965-4dac-b871-1f76-4db9e78213ed
2025-08-10 10:40:56.856 [Thread-38] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 会话 0d179fd9-f726-4162-9b54-77919d099732 没有历史记录
2025-08-10 10:40:56.921 [Thread-38] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 更新会话历史，会话ID: 0d179fd9-f726-4162-9b54-77919d099732, 总消息数: 2
2025-08-10 10:40:56.922 [Thread-38] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 对话存储信息 - Redis键: user:admin:current_conversation, 值: 0d179fd9-f726-4162-9b54-77919d099732
2025-08-10 10:40:56.922 [Thread-38] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 消息处理完成，用户ID: admin
2025-08-10 10:42:08.981 [http-nio-8081-exec-5] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - 接收到消息，用户ID: admin，会话ID: f283c965-4dac-b871-1f76-4db9e78213ed，消息长度: 10
2025-08-10 10:42:08.981 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 开始处理消息，用户ID: admin, 会话ID: f283c965-4dac-b871-1f76-4db9e78213ed
2025-08-10 10:42:08.981 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 获取到用户 admin 的现有会话ID: 0d179fd9-f726-4162-9b54-77919d099732
2025-08-10 10:42:08.981 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 会话ID: 0d179fd9-f726-4162-9b54-77919d099732, 用户ID: admin
2025-08-10 10:42:08.982 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 读取到会话 0d179fd9-f726-4162-9b54-77919d099732 的 2 条历史记录
2025-08-10 10:42:08.982 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 获取到 2 条历史对话
2025-08-10 10:42:08.982 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 开始带权限搜索，查询: 解释一下社区论坛项目, 用户ID: admin
2025-08-10 10:42:08.982 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户有效组织标签，用户ID: admin
2025-08-10 10:42:08.982 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: admin
2025-08-10 10:42:08.984 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: admin
2025-08-10 10:42:08.984 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 admin 的有效组织标签: [DEFAULT]
2025-08-10 10:42:08.984 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 admin 的有效组织标签: [DEFAULT]
2025-08-10 10:42:08.984 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 获取用户数据库ID，用户ID: admin
2025-08-10 10:42:08.984 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户ID不是数字格式，作为用户名查找: admin
2025-08-10 10:42:08.987 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 通过用户名找到用户: admin, ID: 1
2025-08-10 10:42:08.987 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 用户 admin 的数据库ID: 1
2025-08-10 10:42:08.987 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 1
2025-08-10 10:42:08.987 [http-nio-8081-exec-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [3ef24556] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 10:42:08.988 [reactor-http-nio-4] DEBUG org.springframework.web.HttpLogging - [3ef24556] Encoding [{input=[解释一下社区论坛项目], encoding_format=float, model=text-embedding-v4, dimension=2048}]
2025-08-10 10:42:09.155 [reactor-http-nio-4] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [3ef24556] [1c4b7db5-2] Response 200 OK
2025-08-10 10:42:09.157 [reactor-http-nio-4] DEBUG org.springframework.web.HttpLogging - [3ef24556] [1c4b7db5-2] Decoded "{"data":[{"embedding":[-0.039039939641952515,0.018346164375543594,0.01804184354841709,-0.04912598431 (truncated)..."
2025-08-10 10:42:09.158 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 成功生成向量，总数量: 1
2025-08-10 10:42:09.158 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 向量生成成功，开始执行混合搜索 KNN
2025-08-10 10:42:09.172 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - Elasticsearch查询执行完成，命中数量: 0, 最大分数: NaN
2025-08-10 10:42:09.172 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.HybridSearchService - 返回搜索结果数量: 0
2025-08-10 10:42:09.172 [http-nio-8081-exec-5] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 搜索结果数量: 0
2025-08-10 10:42:09.172 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 调用DeepSeek API生成回复
2025-08-10 10:42:09.172 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.client.DeepSeekClient - 构建请求，用户消息：解释一下社区论坛项目，上下文长度：0，历史消息数：2
2025-08-10 10:42:09.173 [http-nio-8081-exec-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [4d13c3c7] HTTP POST https://api.deepseek.com/v1/chat/completions
2025-08-10 10:42:09.463 [reactor-http-nio-6] DEBUG org.springframework.web.HttpLogging - [4d13c3c7] Encoding [{top_p=0.9, stream=true, max_tokens=2000, temperature=0.3, messages=[{role=system, content=你是派聪明知识助手 (truncated)...]
2025-08-10 10:42:09.498 [reactor-http-nio-6] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [4d13c3c7] [dc216d45-1] Response 200 OK
2025-08-10 10:42:13.649 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"###"}
2025-08-10 10:42:14.107 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:14.181 [Thread-39] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 响应仍在继续，等待完成...
2025-08-10 10:42:14.190 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"结论"}
2025-08-10 10:42:14.190 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:14.271 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:14.271 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"社区"}
2025-08-10 10:42:14.353 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"论坛"}
2025-08-10 10:42:14.353 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"项目"}
2025-08-10 10:42:14.434 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"是一个"}
2025-08-10 10:42:14.435 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"基于"}
2025-08-10 10:42:14.518 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"互联网"}
2025-08-10 10:42:14.599 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"的"}
2025-08-10 10:42:14.599 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"在线"}
2025-08-10 10:42:14.705 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"交流"}
2025-08-10 10:42:14.705 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"平台"}
2025-08-10 10:42:14.761 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"，"}
2025-08-10 10:42:14.762 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"允许"}
2025-08-10 10:42:14.844 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"用户"}
2025-08-10 10:42:14.844 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"发布"}
2025-08-10 10:42:14.925 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"主题"}
2025-08-10 10:42:15.007 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:15.018 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"回复"}
2025-08-10 10:42:15.088 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"讨论"}
2025-08-10 10:42:15.088 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:15.171 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"分享"}
2025-08-10 10:42:15.171 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"信息"}
2025-08-10 10:42:15.255 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"，"}
2025-08-10 10:42:15.255 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"并"}
2025-08-10 10:42:15.336 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"形成"}
2025-08-10 10:42:15.336 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"特定"}
2025-08-10 10:42:15.418 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"兴趣"}
2025-08-10 10:42:15.418 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"或"}
2025-08-10 10:42:15.498 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"主题"}
2025-08-10 10:42:15.581 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"的"}
2025-08-10 10:42:15.581 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"社群"}
2025-08-10 10:42:15.662 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:15.744 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n\n"}
2025-08-10 10:42:15.745 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"###"}
2025-08-10 10:42:15.828 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:15.828 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"论"}
2025-08-10 10:42:15.909 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"据"}
2025-08-10 10:42:15.909 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:15.991 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:15.991 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"1"}
2025-08-10 10:42:16.069 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"."}
2025-08-10 10:42:16.069 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:16.151 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"核心"}
2025-08-10 10:42:16.151 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"功能"}
2025-08-10 10:42:16.234 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:16.315 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:16.315 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:16.315 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:16.473 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:16.474 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"发"}
2025-08-10 10:42:16.475 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"帖"}
2025-08-10 10:42:16.475 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"与"}
2025-08-10 10:42:16.677 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"回"}
2025-08-10 10:42:16.677 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"帖"}
2025-08-10 10:42:16.678 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:16.678 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:16.730 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"用户"}
2025-08-10 10:42:16.731 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"可"}
2025-08-10 10:42:16.873 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"创建"}
2025-08-10 10:42:16.874 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"主题"}
2025-08-10 10:42:16.883 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:16.965 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:16.965 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"问题"}
2025-08-10 10:42:17.170 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:17.171 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"分享"}
2025-08-10 10:42:17.171 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:17.172 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"讨论"}
2025-08-10 10:42:17.263 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"），"}
2025-08-10 10:42:17.316 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"其他"}
2025-08-10 10:42:17.316 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"用户"}
2025-08-10 10:42:17.372 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"可"}
2025-08-10 10:42:17.373 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"回复"}
2025-08-10 10:42:17.487 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"互动"}
2025-08-10 10:42:17.539 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:17.702 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:17.703 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:17.703 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:17.703 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:17.705 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"分类"}
2025-08-10 10:42:17.781 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"与"}
2025-08-10 10:42:17.921 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"标签"}
2025-08-10 10:42:17.943 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:17.943 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:18.112 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"内容"}
2025-08-10 10:42:18.112 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"按"}
2025-08-10 10:42:18.113 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"板块"}
2025-08-10 10:42:18.190 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:18.191 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:18.317 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"技术"}
2025-08-10 10:42:18.317 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:18.368 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"生活"}
2025-08-10 10:42:18.368 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:18.535 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"游戏"}
2025-08-10 10:42:18.536 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:42:18.536 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"或"}
2025-08-10 10:42:18.596 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"标签"}
2025-08-10 10:42:18.596 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"分类"}
2025-08-10 10:42:18.727 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"，"}
2025-08-10 10:42:18.727 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"便于"}
2025-08-10 10:42:18.758 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"检索"}
2025-08-10 10:42:18.758 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:18.932 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:18.932 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:18.932 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:18.932 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:19.001 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"用户"}
2025-08-10 10:42:19.001 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"管理"}
2025-08-10 10:42:19.083 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:19.083 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:19.164 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"注册"}
2025-08-10 10:42:19.245 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:19.245 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"登录"}
2025-08-10 10:42:19.327 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:19.328 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"权限"}
2025-08-10 10:42:19.409 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"分级"}
2025-08-10 10:42:19.409 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:19.490 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:19.490 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"普通"}
2025-08-10 10:42:19.572 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"用户"}
2025-08-10 10:42:19.572 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:19.656 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"版"}
2025-08-10 10:42:19.656 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"主"}
2025-08-10 10:42:19.735 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:19.735 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"管理员"}
2025-08-10 10:42:19.817 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）。"}
2025-08-10 10:42:19.897 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:19.897 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:19.897 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:19.998 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:19.999 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"内容"}
2025-08-10 10:42:20.058 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"审核"}
2025-08-10 10:42:20.058 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:20.141 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:20.141 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"敏感"}
2025-08-10 10:42:20.221 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"词"}
2025-08-10 10:42:20.221 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"过滤"}
2025-08-10 10:42:20.303 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:20.303 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"人工"}
2025-08-10 10:42:20.386 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"审核"}
2025-08-10 10:42:20.386 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"或"}
2025-08-10 10:42:20.466 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"举报"}
2025-08-10 10:42:20.466 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"机制"}
2025-08-10 10:42:20.547 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"，"}
2025-08-10 10:42:20.547 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"确保"}
2025-08-10 10:42:20.634 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"内容"}
2025-08-10 10:42:20.634 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"合规"}
2025-08-10 10:42:20.709 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:20.791 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n\n"}
2025-08-10 10:42:20.791 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"2"}
2025-08-10 10:42:20.791 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"."}
2025-08-10 10:42:20.870 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:20.870 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"典型"}
2025-08-10 10:42:20.951 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"应用"}
2025-08-10 10:42:20.951 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"场景"}
2025-08-10 10:42:21.033 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:21.113 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:21.113 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:21.113 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:21.194 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:21.195 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"兴趣"}
2025-08-10 10:42:21.274 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"社群"}
2025-08-10 10:42:21.356 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:21.356 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:21.438 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:21.438 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"摄影"}
2025-08-10 10:42:21.533 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"、"}
2025-08-10 10:42:21.533 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"动漫"}
2025-08-10 10:42:21.600 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:42:21.681 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:21.681 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:21.762 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:21.763 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:21.843 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"技术支持"}
2025-08-10 10:42:21.844 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"论坛"}
2025-08-10 10:42:21.924 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:21.924 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:22.006 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:22.006 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"开发者"}
2025-08-10 10:42:22.087 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"问答"}
2025-08-10 10:42:22.166 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:42:22.247 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:22.247 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:22.328 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:22.329 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:22.410 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"本地"}
2025-08-10 10:42:22.410 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"生活"}
2025-08-10 10:42:22.490 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"讨论"}
2025-08-10 10:42:22.491 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:22.572 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:22.572 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:22.653 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"城市"}
2025-08-10 10:42:22.653 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"信息"}
2025-08-10 10:42:22.735 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"交流"}
2025-08-10 10:42:22.815 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:42:22.897 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n\n"}
2025-08-10 10:42:22.897 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"3"}
2025-08-10 10:42:22.897 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"."}
2025-08-10 10:42:22.978 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:22.978 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"技术"}
2025-08-10 10:42:23.056 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"实现"}
2025-08-10 10:42:23.057 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:23.137 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:23.137 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:23.218 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:23.218 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:23.315 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"传统"}
2025-08-10 10:42:23.315 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"方案"}
2025-08-10 10:42:23.380 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:23.380 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:23.459 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"PHP"}
2025-08-10 10:42:23.459 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:23.539 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:23.621 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"Disc"}
2025-08-10 10:42:23.621 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"uz"}
2025-08-10 10:42:23.700 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"!"}
2025-08-10 10:42:23.700 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）、"}
2025-08-10 10:42:23.781 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"Python"}
2025-08-10 10:42:23.781 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:23.861 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"D"}
2025-08-10 10:42:23.862 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"jango"}
2025-08-10 10:42:23.961 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:42:24.026 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"等"}
2025-08-10 10:42:24.103 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:24.183 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:24.185 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:24.267 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:24.267 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:24.345 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"现代"}
2025-08-10 10:42:24.345 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"方案"}
2025-08-10 10:42:24.427 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:24.427 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:24.506 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"Node"}
2025-08-10 10:42:24.507 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":".js"}
2025-08-10 10:42:24.588 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:24.588 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:24.669 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"Node"}
2025-08-10 10:42:24.755 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"BB"}
2025-08-10 10:42:24.755 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）、"}
2025-08-10 10:42:24.831 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"Ruby"}
2025-08-10 10:42:24.912 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:24.992 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"Disc"}
2025-08-10 10:42:25.074 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"ourse"}
2025-08-10 10:42:25.074 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）"}
2025-08-10 10:42:25.152 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"或"}
2025-08-10 10:42:25.234 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"微"}
2025-08-10 10:42:25.313 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"服务"}
2025-08-10 10:42:25.313 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"架构"}
2025-08-10 10:42:25.394 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:25.474 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n\n"}
2025-08-10 10:42:25.474 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"4"}
2025-08-10 10:42:25.474 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"."}
2025-08-10 10:42:25.555 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:25.555 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"关键"}
2025-08-10 10:42:25.638 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"挑战"}
2025-08-10 10:42:25.718 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:25.799 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:25.799 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:25.799 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:25.879 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:25.880 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"用户"}
2025-08-10 10:42:25.962 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"活跃"}
2025-08-10 10:42:25.962 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"度"}
2025-08-10 10:42:26.040 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:26.041 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:26.119 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"需"}
2025-08-10 10:42:26.119 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"运营"}
2025-08-10 10:42:26.201 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"策略"}
2025-08-10 10:42:26.201 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"（"}
2025-08-10 10:42:26.295 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"如"}
2025-08-10 10:42:26.296 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"活动"}
2025-08-10 10:42:26.382 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"激励"}
2025-08-10 10:42:26.461 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"）。"}
2025-08-10 10:42:26.542 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n"}
2025-08-10 10:42:26.542 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  "}
2025-08-10 10:42:26.542 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" -"}
2025-08-10 10:42:26.622 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":" **"}
2025-08-10 10:42:26.623 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"垃圾"}
2025-08-10 10:42:26.703 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"信息"}
2025-08-10 10:42:26.703 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"管控"}
2025-08-10 10:42:26.783 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"**"}
2025-08-10 10:42:26.784 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"："}
2025-08-10 10:42:26.863 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"需"}
2025-08-10 10:42:26.864 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"自动化"}
2025-08-10 10:42:26.942 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"+"}
2025-08-10 10:42:27.022 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"人工"}
2025-08-10 10:42:27.022 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"审核"}
2025-08-10 10:42:27.108 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"结合"}
2025-08-10 10:42:27.186 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:27.265 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"  \n\n"}
2025-08-10 10:42:27.284 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"若"}
2025-08-10 10:42:27.284 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"需"}
2025-08-10 10:42:27.347 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"具体"}
2025-08-10 10:42:27.348 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"技术"}
2025-08-10 10:42:27.427 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"选"}
2025-08-10 10:42:27.507 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"型"}
2025-08-10 10:42:27.507 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"或"}
2025-08-10 10:42:27.588 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"功能"}
2025-08-10 10:42:27.670 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"设计"}
2025-08-10 10:42:27.670 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"建议"}
2025-08-10 10:42:27.749 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"，"}
2025-08-10 10:42:27.749 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"请"}
2025-08-10 10:42:27.831 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"补充"}
2025-08-10 10:42:27.832 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"项目"}
2025-08-10 10:42:27.912 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"细节"}
2025-08-10 10:42:27.913 [reactor-http-nio-6] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 发送响应块到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"chunk":"。"}
2025-08-10 10:42:35.201 [Thread-39] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 发送完成通知到会话 f283c965-4dac-b871-1f76-4db9e78213ed: {"status":"finished","type":"completion","date":"2025-08-10T10:42:35.201606400","timestamp":1754793755201,"message":"响应已完成"}
2025-08-10 10:42:35.201 [Thread-39] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 已发送响应完成通知到会话: f283c965-4dac-b871-1f76-4db9e78213ed
2025-08-10 10:42:35.202 [Thread-39] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 读取到会话 0d179fd9-f726-4162-9b54-77919d099732 的 2 条历史记录
2025-08-10 10:42:35.242 [Thread-39] DEBUG com.yizhaoqi.smartpai.service.ChatHandler - 更新会话历史，会话ID: 0d179fd9-f726-4162-9b54-77919d099732, 总消息数: 4
2025-08-10 10:42:35.242 [Thread-39] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 对话存储信息 - Redis键: user:admin:current_conversation, 值: 0d179fd9-f726-4162-9b54-77919d099732
2025-08-10 10:42:35.242 [Thread-39] INFO  com.yizhaoqi.smartpai.service.ChatHandler - 消息处理完成，用户ID: admin
2025-08-10 10:44:03.765 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:03.775 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:03.775 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:03.775 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:03.781 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:03.781 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:03.783 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:04.153 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:44:04.153 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=999&orgTag=default
2025-08-10 10:44:04.162 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:44:04.163 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11", parameters={masked}
2025-08-10 10:44:04.163 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getAllConversations(String, String, String, String)
2025-08-10 10:44:04.163 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/users/list?page=1&size=999&orgTag=default
2025-08-10 10:44:04.164 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/users/list?page=1&size=999&orgTag=default", parameters={masked}
2025-08-10 10:44:04.164 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getUserList(String, String, String, Integer, int, int)
2025-08-10 10:44:04.196 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:04.196 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{role=user, content=解释一下社区论坛项目, timestamp=2025-08-10T10:40:56, username=admin}, {ro (truncated)...]
2025-08-10 10:44:04.198 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:04.198 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:04.198 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={number=1, size=999, totalPages=1, content=[{primaryOrg=default, createdAt=2025-08-0 (truncated)...]
2025-08-10 10:44:04.200 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:06.581 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:06.590 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:06.590 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:06.591 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:06.597 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:06.597 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:06.599 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:07.686 [http-nio-8081-exec-8] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - StandardWebSocketSession[id=f283c965-4dac-b871-1f76-4db9e78213ed, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g] closed with CloseStatus[code=1000, reason=null]
2025-08-10 10:44:07.687 [http-nio-8081-exec-8] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - WebSocket连接已关闭，用户ID: admin，会话ID: f283c965-4dac-b871-1f76-4db9e78213ed，状态: CloseStatus[code=1000, reason=null]
2025-08-10 10:44:08.662 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:08.667 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:08.668 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:08.668 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:08.671 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:08.671 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:08.673 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:08.680 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:08.687 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:08.687 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:08.687 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:08.690 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:08.691 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:08.692 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:08.839 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=999&orgTag=default
2025-08-10 10:44:08.839 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:44:08.845 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:44:08.845 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11", parameters={masked}
2025-08-10 10:44:08.845 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/users/list?page=1&size=999&orgTag=default
2025-08-10 10:44:08.845 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getAllConversations(String, String, String, String)
2025-08-10 10:44:08.845 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/users/list?page=1&size=999&orgTag=default", parameters={masked}
2025-08-10 10:44:08.845 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getUserList(String, String, String, Integer, int, int)
2025-08-10 10:44:08.852 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:08.852 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{role=user, content=解释一下社区论坛项目, timestamp=2025-08-10T10:40:56, username=admin}, {ro (truncated)...]
2025-08-10 10:44:08.854 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:08.856 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:08.856 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={number=1, size=999, totalPages=1, content=[{primaryOrg=default, createdAt=2025-08-0 (truncated)...]
2025-08-10 10:44:08.857 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:09.184 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:44:09.185 [http-nio-8081-exec-5] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 10:44:09.185 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:44:09.185 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g", parameters={}
2025-08-10 10:44:09.185 [http-nio-8081-exec-5] DEBUG o.s.w.s.server.support.WebSocketHandlerMapping - Mapped to org.springframework.web.socket.server.support.WebSocketHttpRequestHandler@2dfab333
2025-08-10 10:44:09.185 [http-nio-8081-exec-5] DEBUG o.s.w.s.server.support.WebSocketHttpRequestHandler - GET /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:44:09.186 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 101 SWITCHING_PROTOCOLS
2025-08-10 10:44:09.186 [http-nio-8081-exec-5] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - New StandardWebSocketSession[id=476bbeca-570e-1667-e48d-dc06d7b13e68, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g]
2025-08-10 10:44:09.188 [http-nio-8081-exec-5] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - WebSocket连接已建立，用户ID: admin，会话ID: 476bbeca-570e-1667-e48d-dc06d7b13e68，URI路径: /chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g
2025-08-10 10:44:11.812 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:11.820 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:11.820 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:11.820 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:11.825 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:11.826 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:11.827 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:12.263 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/documents/uploads
2025-08-10 10:44:12.270 [http-nio-8081-exec-1] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理获取用户文档请求: /api/v1/documents/uploads
2025-08-10 10:44:12.272 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/documents/uploads
2025-08-10 10:44:12.272 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/documents/uploads", parameters={}
2025-08-10 10:44:12.273 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.DocumentController#getUserUploadedFiles(String)
2025-08-10 10:44:12.274 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.DocumentService - 获取用户上传的文件列表: userId=1
2025-08-10 10:44:12.277 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.DocumentService - 成功获取用户上传的文件列表: userId=1, fileCount=0
2025-08-10 10:44:12.278 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:12.278 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[], message=获取用户上传文件列表成功}]
2025-08-10 10:44:12.279 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:18.548 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:18.559 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:18.559 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:18.559 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:18.565 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:18.565 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:18.568 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:18.934 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:18.943 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:18.943 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/org-tags/tree", parameters={}
2025-08-10 10:44:18.944 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getOrganizationTagTree(String)
2025-08-10 10:44:18.959 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:18.959 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{tagId=admin, parentTag=null, name=管理员组织, description=管理员专用组织标签，具有管理权限}, {tagId=def (truncated)...]
2025-08-10 10:44:18.961 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:36.259 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:36.267 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:36.267 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/org-tags/tree", parameters={}
2025-08-10 10:44:36.267 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getOrganizationTagTree(String)
2025-08-10 10:44:36.280 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:36.280 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{tagId=admin, parentTag=null, name=管理员组织, description=管理员专用组织标签，具有管理权限}, {tagId=def (truncated)...]
2025-08-10 10:44:36.282 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:37.727 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:37.734 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:37.734 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:37.735 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:37.739 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:37.740 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:37.741 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:38.477 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:38.477 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 10:44:38.484 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 10:44:38.484 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:38.486 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/org-tags/tree", parameters={}
2025-08-10 10:44:38.486 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/users/list?page=1&size=20", parameters={masked}
2025-08-10 10:44:38.486 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getOrganizationTagTree(String)
2025-08-10 10:44:38.486 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getUserList(String, String, String, Integer, int, int)
2025-08-10 10:44:38.498 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:38.498 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{tagId=admin, parentTag=null, name=管理员组织, description=管理员专用组织标签，具有管理权限}, {tagId=def (truncated)...]
2025-08-10 10:44:38.499 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:38.502 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:38.502 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={number=1, size=20, totalPages=1, content=[{primaryOrg=PRIVATE_sy, createdAt=2025-08 (truncated)...]
2025-08-10 10:44:38.503 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:38.505 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 10:44:38.512 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 10:44:38.512 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/users/list?page=1&size=20", parameters={masked}
2025-08-10 10:44:38.512 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getUserList(String, String, String, Integer, int, int)
2025-08-10 10:44:38.526 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:38.526 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={number=1, size=20, totalPages=1, content=[{primaryOrg=PRIVATE_sy, createdAt=2025-08 (truncated)...]
2025-08-10 10:44:38.527 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:44.840 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:44.847 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/org-tags/tree
2025-08-10 10:44:44.847 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/org-tags/tree", parameters={}
2025-08-10 10:44:44.848 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getOrganizationTagTree(String)
2025-08-10 10:44:44.860 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:44.860 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{tagId=admin, parentTag=null, name=管理员组织, description=管理员专用组织标签，具有管理权限}, {tagId=def (truncated)...]
2025-08-10 10:44:44.862 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:46.865 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:46.878 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:46.878 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:46.878 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:46.885 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:46.885 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:46.887 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:47.269 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/org-tags
2025-08-10 10:44:47.276 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/org-tags
2025-08-10 10:44:47.276 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/org-tags", parameters={}
2025-08-10 10:44:47.276 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getUserOrgTags(String)
2025-08-10 10:44:47.282 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.OrgTagCacheService - Cached organization tags for user: admin
2025-08-10 10:44:47.283 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.OrgTagCacheService - Cached primary organization for user: admin
2025-08-10 10:44:47.288 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:47.288 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={primaryOrg=default, orgTags=[default, admin], orgTagDetails=[{tagId=default, name=默 (truncated)...]
2025-08-10 10:44:47.289 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:49.077 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 10:44:49.085 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 10:44:49.085 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 10:44:49.085 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 10:44:49.092 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:49.092 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 10:44:49.094 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 10:44:49.444 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/conversation?start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:44:49.455 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/conversation?start_date=2025-08-03&end_date=2025-08-11
2025-08-10 10:44:49.455 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/conversation?start_date=2025-08-03&end_date=2025-08-11", parameters={masked}
2025-08-10 10:44:49.455 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.ConversationController#getConversations(String, String, String)
2025-08-10 10:44:49.461 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 10:44:49.462 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{role=user, content=解释一下社区论坛项目, timestamp=2025-08-10T10:40:56}, {role=assistant, co (truncated)...]
2025-08-10 10:44:49.463 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:41:33.570 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 14:41:33.573 [http-nio-8081-exec-8] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.574 [http-nio-8081-exec-8] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:33.574 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error
2025-08-10 14:41:33.574 [http-nio-8081-exec-8] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.574 [http-nio-8081-exec-8] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:33.834 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 14:41:33.836 [http-nio-8081-exec-7] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.836 [http-nio-8081-exec-7] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:33.837 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 14:41:33.837 [http-nio-8081-exec-7] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.837 [http-nio-8081-exec-7] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:33.900 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=999&orgTag=
2025-08-10 14:41:33.900 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=999&orgTag=default
2025-08-10 14:41:33.900 [http-nio-8081-exec-9] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.900 [http-nio-8081-exec-9] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:33.900 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error?page=1&size=999&orgTag=
2025-08-10 14:41:33.901 [http-nio-8081-exec-9] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.901 [http-nio-8081-exec-9] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:33.902 [http-nio-8081-exec-10] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.902 [http-nio-8081-exec-10] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:33.903 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /error?page=1&size=999&orgTag=default
2025-08-10 14:41:33.903 [http-nio-8081-exec-10] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:33.903 [http-nio-8081-exec-10] DEBUG o.s.s.w.authentication.Http403ForbiddenEntryPoint - Pre-authenticated entry point called. Rejecting access
2025-08-10 14:41:36.380 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Securing POST /api/v1/users/login
2025-08-10 14:41:36.380 [http-nio-8081-exec-2] DEBUG o.s.s.w.a.AnonymousAuthenticationFilter - Set SecurityContextHolder to anonymous SecurityContext
2025-08-10 14:41:36.380 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Secured POST /api/v1/users/login
2025-08-10 14:41:36.380 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - POST "/api/v1/users/login", parameters={}
2025-08-10 14:41:36.381 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#login(UserRequest)
2025-08-10 14:41:36.382 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Read "application/json;charset=UTF-8" to [UserRequest[username=admin, password=admin123]]
2025-08-10 14:41:36.442 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.TokenCacheService - Token cached: 00850cd3ff8f424994251deb062cae1d for user: admin
2025-08-10 14:41:36.442 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.utils.JwtUtils - Token generated and cached for user: admin, tokenId: 00850cd3ff8f424994251deb062cae1d
2025-08-10 14:41:36.444 [http-nio-8081-exec-2] DEBUG com.yizhaoqi.smartpai.service.TokenCacheService - Refresh token cached: b67b26e6a88d4e8cb08c9aa7e321186a for user: 1
2025-08-10 14:41:36.444 [http-nio-8081-exec-2] INFO  com.yizhaoqi.smartpai.utils.JwtUtils - Refresh token generated and cached for user: admin, refreshTokenId: b67b26e6a88d4e8cb08c9aa7e321186a
2025-08-10 14:41:36.444 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:41:36.444 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={refreshToken=eyJhbGciOiJIUzI1NiJ9.eyJyZWZyZXNoVG9rZW5JZCI6ImI2N2IyNmU2YTg4ZDRlOGNiM (truncated)...]
2025-08-10 14:41:36.445 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:41:36.450 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 14:41:36.454 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 14:41:36.454 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 14:41:36.454 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 14:41:36.458 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:41:36.458 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 14:41:36.458 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:41:36.465 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 14:41:36.470 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 14:41:36.470 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 14:41:36.470 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 14:41:36.473 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:41:36.473 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 14:41:36.474 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:41:36.505 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/documents/uploads
2025-08-10 14:41:36.962 [http-nio-8081-exec-1] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理获取用户文档请求: /api/v1/documents/uploads
2025-08-10 14:41:36.963 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/documents/uploads
2025-08-10 14:41:36.963 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/documents/uploads", parameters={}
2025-08-10 14:41:36.963 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.DocumentController#getUserUploadedFiles(String)
2025-08-10 14:41:36.963 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.DocumentService - 获取用户上传的文件列表: userId=1
2025-08-10 14:41:36.965 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.DocumentService - 成功获取用户上传的文件列表: userId=1, fileCount=0
2025-08-10 14:41:36.965 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:41:36.965 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[], message=获取用户上传文件列表成功}]
2025-08-10 14:41:36.966 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:52:59.048 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 14:52:59.054 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 14:52:59.054 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 14:52:59.054 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 14:52:59.057 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:52:59.057 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 14:52:59.058 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:52:59.311 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/org-tags/tree
2025-08-10 14:52:59.316 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/org-tags/tree
2025-08-10 14:52:59.316 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/org-tags/tree", parameters={}
2025-08-10 14:52:59.316 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getOrganizationTagTree(String)
2025-08-10 14:52:59.323 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:52:59.323 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{tagId=admin, parentTag=null, name=管理员组织, description=管理员专用组织标签，具有管理权限}, {tagId=def (truncated)...]
2025-08-10 14:52:59.324 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:09.249 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 14:53:09.255 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 14:53:09.255 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 14:53:09.255 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 14:53:09.257 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:09.258 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 14:53:09.258 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:09.900 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 14:53:09.900 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/org-tags/tree
2025-08-10 14:53:09.904 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/org-tags/tree
2025-08-10 14:53:09.905 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/org-tags/tree", parameters={}
2025-08-10 14:53:09.904 [http-nio-8081-exec-7] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 14:53:09.905 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getOrganizationTagTree(String)
2025-08-10 14:53:09.905 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/users/list?page=1&size=20", parameters={masked}
2025-08-10 14:53:09.905 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getUserList(String, String, String, Integer, int, int)
2025-08-10 14:53:09.911 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:09.911 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{tagId=admin, parentTag=null, name=管理员组织, description=管理员专用组织标签，具有管理权限}, {tagId=def (truncated)...]
2025-08-10 14:53:09.912 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:09.914 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:09.914 [http-nio-8081-exec-7] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={number=1, size=20, totalPages=1, content=[{primaryOrg=PRIVATE_sy, createdAt=2025-08 (truncated)...]
2025-08-10 14:53:09.914 [http-nio-8081-exec-7] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:10.162 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 14:53:10.167 [http-nio-8081-exec-10] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/users/list?page=1&size=20
2025-08-10 14:53:10.167 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/users/list?page=1&size=20", parameters={masked}
2025-08-10 14:53:10.167 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getUserList(String, String, String, Integer, int, int)
2025-08-10 14:53:10.176 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:10.176 [http-nio-8081-exec-10] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={number=1, size=20, totalPages=1, content=[{primaryOrg=PRIVATE_sy, createdAt=2025-08 (truncated)...]
2025-08-10 14:53:10.177 [http-nio-8081-exec-10] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:13.226 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 14:53:13.233 [http-nio-8081-exec-2] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 14:53:13.233 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 14:53:13.233 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 14:53:13.236 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:13.236 [http-nio-8081-exec-2] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 14:53:13.237 [http-nio-8081-exec-2] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:13.880 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/documents/uploads
2025-08-10 14:53:13.884 [http-nio-8081-exec-5] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理获取用户文档请求: /api/v1/documents/uploads
2025-08-10 14:53:13.885 [http-nio-8081-exec-5] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/documents/uploads
2025-08-10 14:53:13.885 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/documents/uploads", parameters={}
2025-08-10 14:53:13.885 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.DocumentController#getUserUploadedFiles(String)
2025-08-10 14:53:13.886 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.DocumentService - 获取用户上传的文件列表: userId=1
2025-08-10 14:53:13.887 [http-nio-8081-exec-5] INFO  com.yizhaoqi.smartpai.service.DocumentService - 成功获取用户上传的文件列表: userId=1, fileCount=0
2025-08-10 14:53:13.887 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:13.887 [http-nio-8081-exec-5] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[], message=获取用户上传文件列表成功}]
2025-08-10 14:53:13.888 [http-nio-8081-exec-5] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:15.592 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/org-tags/tree
2025-08-10 14:53:15.596 [http-nio-8081-exec-4] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/org-tags/tree
2025-08-10 14:53:15.596 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/org-tags/tree", parameters={}
2025-08-10 14:53:15.596 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getOrganizationTagTree(String)
2025-08-10 14:53:15.603 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:15.603 [http-nio-8081-exec-4] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{tagId=admin, parentTag=null, name=管理员组织, description=管理员专用组织标签，具有管理权限}, {tagId=def (truncated)...]
2025-08-10 14:53:15.604 [http-nio-8081-exec-4] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:26.742 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Securing POST /api/v1/upload/chunk
2025-08-10 14:53:26.747 [http-nio-8081-exec-1] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理分片上传请求: /api/v1/upload/chunk
2025-08-10 14:53:26.748 [http-nio-8081-exec-1] DEBUG org.springframework.security.web.FilterChainProxy - Secured POST /api/v1/upload/chunk
2025-08-10 14:53:26.748 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - POST "/api/v1/upload/chunk", parameters={multipart}
2025-08-10 14:53:26.786 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UploadController#uploadChunk(String, int, long, String, Integer, String, boolean, MultipartFile, String)
2025-08-10 14:53:26.788 [http-nio-8081-exec-1] DEBUG c.y.smartpai.service.FileTypeValidationService - 开始验证文件类型: fileName=国家电网·必会考点-计算机类.pdf
2025-08-10 14:53:26.788 [http-nio-8081-exec-1] DEBUG c.y.smartpai.service.FileTypeValidationService - 文件类型识别结果: fileName=国家电网·必会考点-计算机类.pdf, extension=pdf, fileType=PDF文档
2025-08-10 14:53:26.788 [http-nio-8081-exec-1] INFO  c.y.smartpai.service.FileTypeValidationService - 文件类型验证通过: fileName=国家电网·必会考点-计算机类.pdf, extension=pdf, fileType=PDF文档
2025-08-10 14:53:26.789 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - [uploadChunk] 开始处理分片上传请求 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, chunkIndex: 0, totalSize: 1539783, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, contentType: application/octet-stream, fileSize: 1539783, orgTag: PRIVATE_sy, isPublic: false, userId: 1
2025-08-10 14:53:26.792 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 检查文件记录是否存在 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, exists: false
2025-08-10 14:53:26.792 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 创建新的文件记录 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, totalSize: 1539783, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:26.825 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件记录创建成功 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档
2025-08-10 14:53:26.825 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 检查分片是否已上传 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, chunkIndex: 0
2025-08-10 14:53:26.826 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片上传状态 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, chunkIndex: 0, isUploaded: false
2025-08-10 14:53:26.826 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 检查分片是否已上传 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0, isUploaded: false
2025-08-10 14:53:26.833 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 检查数据库中分片信息 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0, exists: false
2025-08-10 14:53:26.833 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 计算分片MD5 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0
2025-08-10 14:53:26.842 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片MD5计算完成 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0, chunkMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:26.842 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 构建分片存储路径 => fileName: 国家电网·必会考点-计算机类.pdf, path: chunks/efda0d8454f290ed66cbcdf9aa2ac5bf/0
2025-08-10 14:53:26.842 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 开始上传分片到MinIO => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, chunkIndex: 0, bucket: uploads, path: chunks/efda0d8454f290ed66cbcdf9aa2ac5bf/0, size: 1539783, contentType: application/octet-stream
2025-08-10 14:53:26.978 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 分片上传到MinIO成功 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, chunkIndex: 0
2025-08-10 14:53:26.978 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 标记分片为已上传 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0
2025-08-10 14:53:26.978 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 标记分片为已上传 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, chunkIndex: 0
2025-08-10 14:53:26.979 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片已标记为已上传 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, chunkIndex: 0
2025-08-10 14:53:26.979 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片标记完成 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0
2025-08-10 14:53:26.979 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 保存分片信息到数据库 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0, chunkMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, storagePath: chunks/efda0d8454f290ed66cbcdf9aa2ac5bf/0
2025-08-10 14:53:26.979 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 保存分片信息到数据库 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, chunkIndex: 0, chunkMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, storagePath: chunks/efda0d8454f290ed66cbcdf9aa2ac5bf/0
2025-08-10 14:53:26.985 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片信息已保存 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, chunkIndex: 0
2025-08-10 14:53:26.985 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 分片信息已保存到数据库 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, chunkIndex: 0
2025-08-10 14:53:26.985 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 分片处理完成 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, chunkIndex: 0
2025-08-10 14:53:26.985 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 获取已上传分片列表 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:26.985 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 计算文件总分片数 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:26.987 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件总分片数计算结果 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, totalSize: 1539783, chunkSize: 5242880, totalChunks: 1
2025-08-10 14:53:26.987 [http-nio-8081-exec-1] DEBUG com.yizhaoqi.smartpai.service.UploadService - 文件总分片数 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, totalChunks: 1
2025-08-10 14:53:27.001 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 获取到已上传分片列表 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, 已上传数量: 1, 总分片数: 1, 优化方式: 一次性获取
2025-08-10 14:53:27.001 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 计算文件总分片数 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:27.003 [http-nio-8081-exec-1] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件总分片数计算结果 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, totalSize: 1539783, chunkSize: 5242880, totalChunks: 1
2025-08-10 14:53:27.004 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:27.004 [http-nio-8081-exec-1] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={uploaded=[0], progress=100.0}, message=分片上传成功}]
2025-08-10 14:53:27.006 [http-nio-8081-exec-1] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:27.011 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Securing POST /api/v1/upload/merge
2025-08-10 14:53:27.015 [http-nio-8081-exec-3] INFO  c.y.smartpai.config.OrgTagAuthorizationFilter - 处理合并分片请求: /api/v1/upload/merge
2025-08-10 14:53:27.016 [http-nio-8081-exec-3] DEBUG org.springframework.security.web.FilterChainProxy - Secured POST /api/v1/upload/merge
2025-08-10 14:53:27.016 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - POST "/api/v1/upload/merge", parameters={}
2025-08-10 14:53:27.016 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UploadController#mergeFile(MergeRequest, String)
2025-08-10 14:53:27.019 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.a.RequestResponseBodyMethodProcessor - Read "application/json;charset=UTF-8" to [MergeRequest[fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, fileName=国家电网·必会考点-计算机类.pdf]]
2025-08-10 14:53:27.021 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 获取已上传分片列表 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:27.021 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 计算文件总分片数 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:27.022 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件总分片数计算结果 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, totalSize: 1539783, chunkSize: 5242880, totalChunks: 1
2025-08-10 14:53:27.022 [http-nio-8081-exec-3] DEBUG com.yizhaoqi.smartpai.service.UploadService - 文件总分片数 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, totalChunks: 1
2025-08-10 14:53:27.023 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 获取到已上传分片列表 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, 已上传数量: 1, 总分片数: 1, 优化方式: 一次性获取
2025-08-10 14:53:27.023 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 计算文件总分片数 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:27.024 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件总分片数计算结果 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, totalSize: 1539783, chunkSize: 5242880, totalChunks: 1
2025-08-10 14:53:27.024 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 开始合并文件分片 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档
2025-08-10 14:53:27.024 [http-nio-8081-exec-3] DEBUG com.yizhaoqi.smartpai.service.UploadService - 查询分片信息 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf
2025-08-10 14:53:27.024 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 查询到分片信息 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, 分片数量: 1
2025-08-10 14:53:27.024 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 计算文件总分片数 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:27.025 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件总分片数计算结果 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, totalSize: 1539783, chunkSize: 5242880, totalChunks: 1
2025-08-10 14:53:27.025 [http-nio-8081-exec-3] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片路径列表 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, 路径数量: 1
2025-08-10 14:53:27.025 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 开始检查每个分片是否存在 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档
2025-08-10 14:53:27.035 [http-nio-8081-exec-3] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片存在 => fileName: 国家电网·必会考点-计算机类.pdf, index: 0, path: chunks/efda0d8454f290ed66cbcdf9aa2ac5bf/0, size: 1539783
2025-08-10 14:53:27.037 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 分片检查完成，所有分片都存在 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档
2025-08-10 14:53:27.037 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 开始合并分片 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, 合并后路径: merged/国家电网·必会考点-计算机类.pdf
2025-08-10 14:53:27.037 [http-nio-8081-exec-3] DEBUG com.yizhaoqi.smartpai.service.UploadService - 构建合并请求 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, targetPath: merged/国家电网·必会考点-计算机类.pdf, sourcePaths: [chunks/efda0d8454f290ed66cbcdf9aa2ac5bf/0]
2025-08-10 14:53:27.064 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 分片合并成功 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, mergedPath: merged/国家电网·必会考点-计算机类.pdf
2025-08-10 14:53:27.071 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 合并文件信息 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, path: merged/国家电网·必会考点-计算机类.pdf, size: 1539783
2025-08-10 14:53:27.071 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 开始清理分片文件 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, 分片数量: 1
2025-08-10 14:53:27.080 [http-nio-8081-exec-3] DEBUG com.yizhaoqi.smartpai.service.UploadService - 分片文件已删除 => fileName: 国家电网·必会考点-计算机类.pdf, path: chunks/efda0d8454f290ed66cbcdf9aa2ac5bf/0
2025-08-10 14:53:27.080 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 分片文件清理完成 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档
2025-08-10 14:53:27.080 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 删除Redis中的分片状态记录 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf
2025-08-10 14:53:27.080 [http-nio-8081-exec-3] DEBUG com.yizhaoqi.smartpai.service.UploadService - 删除文件所有分片上传标记 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:27.080 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件分片上传标记已删除 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:27.080 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 分片状态记录已删除 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf
2025-08-10 14:53:27.080 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 更新文件状态为已完成 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档
2025-08-10 14:53:27.084 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 文件状态已更新为已完成 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档
2025-08-10 14:53:27.084 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 开始生成预签名URL => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, path: merged/国家电网·必会考点-计算机类.pdf
2025-08-10 14:53:27.085 [http-nio-8081-exec-3] INFO  com.yizhaoqi.smartpai.service.UploadService - 预签名URL已生成 => fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, fileName: 国家电网·必会考点-计算机类.pdf, fileType: PDF文档, URL: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:28.463 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Received task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
2025-08-10 14:53:28.464 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件权限信息: userId=1, orgTag=PRIVATE_sy, isPublic=false
2025-08-10 14:53:28.464 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Downloading file from storage: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:28.464 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Detected remote URL: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:28.478 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Successfully connected to URL, starting download...
2025-08-10 14:53:28.478 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 开始解析文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:28.481 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:53:28.481 [http-nio-8081-exec-3] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={object_url=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%9 (truncated)...]
2025-08-10 14:53:28.482 [http-nio-8081-exec-3] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:53:29.128 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] WARN  org.apache.pdfbox.pdmodel.font.PDCIDFontType2 - Found CFF/OTF but expected embedded TTF font THDZFH+AppleSDGothicNeo-Regular
2025-08-10 14:53:29.200 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文件元数据:
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:unmappedUnicodeCharsPerPage: 0
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:PDFVersion: 1.7
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmp:CreatorTool: WPS 文字
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXFA: false
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:modify_annotations: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print_degraded: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By-Full-Set: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:creator: Sky123.Org
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:num3DAnnotations: 0
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:format: application/pdf; version=1.7
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator_tool: WPS 文字
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:overallPercentageUnmappedUnicodeChars: 0.0
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:fill_in_form: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasCollection: false
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:encrypted: false
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsNonEmbeddedFont: false
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:custom:SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasMarkedContent: false
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - Content-Type: application/pdf
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator: Sky123.Org
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:totalUnmappedUnicodeChars: 0
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_for_accessibility: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:assemble_document: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmpTPg:NPages: 166
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXMP: false
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:charsPerPage: 15
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_content: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:trapped: False
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationTypes: null
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_modify: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationSubtypes: Link
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsDamagedFont: true
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 提取的文本内容长度: 44161
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换............................................................ 6知识点 2、常见数据编码....................................................8知识点 3、机器数.............................................................. 14知识点 4、补码溢出..........................................................19知识点 5、寻址方式..........................................................22知识点 6、存储芯片容量的计算..................................... 39知识点 7、DRAM 的刷新................................................ 40知识点 8、存储
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与 CPU 的扩展连接...........................43知识点 9、死锁.................................................................. 48知识点 10、处理机调度的层次....................................... 553知识点 11、调度算法........................................................57知识点 12、内存的连续分配........................................... 63知识点 13、基本的分页存储管理................................... 70知识点 14、基本的分段存储管理................................... 76知识点 15、虚拟存储器....................................................83知识点 16、页面置换算法....................
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ........................... 90知识点 17、线性表............................................................ 95知识点 18、栈和队列........................................................98知识点 19、树.................................................................. 102知识点 20、二叉树.......................................................... 105知识点 21、图.................................................................. 1104知识点 22、数据模型......................................................117知识点 23、概念模型................................
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ......................119知识点 24、关系模型......................................................125知识点 25、关系操作和完整性约束.............................127知识点 26、SQL 常用语句............................................ 132知识点 27、计算机网络分类......................................... 139知识点 28、网络地址......................................................144知识点 29、子网掩码......................................................148知识点 30、网络设备......................................................153知识点 31、信息加密技术...............................
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: .............. 158知识点 32、计算机病毒..................................................1645知识点 1、进制转换常用数制数制 数码 运算规则 尾符十进制 0—9 逢十进一 D或10二进制 0—1 逢二进一 B或2八进制 0—7 逢八进一 O或8十六进制 0—9，A—F 逢十六进一 H或16（ 一 ）非十进制数转换成十进制数方法每位上的数码×基的位次方，然后求和。（ 二 ）十进制数转换成非十进制数方法整数部分：除N 取余数，直至商为0，余数倒输出。小数部分：乘N 取整数，直至积为0（或满足精度），整数正输出。6（N 为进制数，N 可取2、8、16。）（ 三 ）二/八/十六进制数的互相转换方法由于一位八/十六进制数相当于三/四位二进制数，因此，要将八/十六进制数转换成二进制数时，只需以小数点为界，向左或向右每一位八/十六进制数用相应的三/四位二进制数取代即可。如果不足三/四位，可用零补足。反之，二进制数转换成相应的八/十六进制数，只是上述方法的逆过程，即以小数点为界，向左或向右，每三/四位二进制数用相应的一位八/十六进制数取代即可。【习题
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 演练】1.二进制数 1101.01 转换成十进制数是（ ）。A.17.256B.13.5C.13.25D.17.571.【答案】C。解析：（1101.01）2= 1 x23+1 x22+1+1 x 2—2 = 13.25。2.下列数中最大的数是（ ）。A.227OB.1FFHC. 10100001BD.1789D2.【答案】D。解析：将所有数都统一转换为十进制进行比较，227O=151D ， 1FFH=511D ，10100001B= 161D，对比可知应选D 选项。知识点 2、常见数据编码（ 一）ASCII码美国信息交换标准代码（American StrandardCode for Information Interchage，ASCII）是一种西8文机内码，是计算机中使用最广泛的字符编码，已经作为国际通用的信息交换标准代码。ASCII 码包括 0～9 十个数字，大小写英文字母和专用符号等95 种可打印字符，以及33 种控制字符（如回车、换行等），通常采用一个字节编码，由7 位二进制编码组成，字节的最高位一般规定为0，或用作校验码，可表示 128 个不同的字符。（ 二）汉字的编码1.国标码《信息交换用汉字编
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 码字符集·基本集》是我国于 1980 年制定的国家标准GB2312—80，简称国标码，是国家规定的用于汉字信息交换使用的代码的依据。GB2312—80 中规定了信息交换用的6763个汉字和682 个非汉字图形符号（包括外文字母、数字和符号）的代码。国标码用两个字节表示一个汉字，每个字节只使用低7 位，最高位为0。2.汉字机内码9汉字的机内码是供计算机系统内部进行存储、加工处理、传输统一使用的代码，又称为汉字内部码或汉字内码。汉字机内码是将国标码的两个字节的最高位分别置为 1 而得到的。其最大优点是机内码表示简单，同时也解决了中西文机内码存在的二义性的问题。3.汉字输入码汉字输入码是为了将汉字通过键盘输入计算机而设计的代码。汉字输入编码方案很多，其表示形式大多用字母、数字或符号。输入码的长度也不同，多数为四个字节。综合起来可分为流水码、音码、形码和音形码几大类。4.汉字字形码汉字字形码是汉字字库中存储的汉字字形的数字化信息，用于汉字的显示和打印。目前汉字字形的产生方式大多是数字式，即以点阵方式形成汉字。因此，汉字字形码主要是指汉字字形点阵的代码，10主要有 16×16 点阵、32×32 点阵、256×256 点
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 阵等。如 24×24 的点阵，每字需要72 字节；32×32的点阵，每字需要 128 字节。与每个汉字对应的这一串字节就是汉字的字形码。（ 三）二-十进制编码人们习惯于使用十进制数，而计算机内部多采用二进制数表示和处理数值数据，因此在计算机输入和输出数据时，就要进行由十进制到二进制和从二进制到十进制的转换处理，显然，这项事务性工作如果由人工来完成，势必造成大量时间浪费。因此，必须采用一种编码的方法，由计算机自己来完成这种识别和转换工作。人们通常采用把十进制数的每一位分别写成二进制数形式的编码，称为二-十进制编码或BCD 编码。BCD 编码方法很多，通常采用的是8421 编码。其方法是用四位二进制数表示一位十进制数，自左11至右每一位对应的位权分别是8，4，2，1。值得注意的是，四位二进制数有 0000～1111 十六种状态，这里只取了0000～1001 十种状态，而 1010～1111六种状态在这种编码中没有意义。如十进制数864，其BCD进制编码为 100001100100。8 6 4↓ ↓ ↓1000 0110 0100BCD 码有压缩和非压缩两种。上述的编码方法属于压缩BCD 码，特点是用 1 个字节表
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 示2 位BCD码；非压缩 BCD 码用 1 个字节的低 4 位表示 1 位BCD 码，高4 位为0（无意义）。如 13 的压缩BCD码为 0001 0011 ，非压缩 BCD 码为 0000000100000011。【习题演练】1.已知字符0 的ASCII码为48D，用ASCII 码（7 位）表示字符5 和7 是（ ）。12A.0110010 和0110111B.0100011 和0111011C. 1000101和1100011D.0110101 和01101111.【答案】D。解析：ASCII 码表中字符5 和7的码值分别为 53 和 55 ，转换为二进制表示为0110101 和 0110111。2.某数用压缩BCD 码表示为 10010101，其真值为（ ）。A.135B.95C.95HD. 10010101B2.【答案】B。解析：BCD码是二-十进制编码，1001 和0101 分别对应十进制的9 和5，故选择B选项。3.一个 16×16 点阵的汉字要占用（ ）。A.24 个字节13B.32 个字节C.48 个字节D.256 个字节3.【答案】B。解析：16×16 点阵的汉字要用16×16/8=32 个
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 字节。知识点 3、机器数对于数的符号“＋”和“－”，计算机是无法识别的，需要把符号数码化。通常，约定二进制数的最高位为符号位，“0”表示正号，“1”表示负号。这种在计算机中使用的表示数的形式称为机器数，常见的机器数有原码、反码、补码等。（ 一）原码原码表示法是机器数的一种简单的表示法。其符号位用0 表示正号，用 1 表示负号，数值一般用14二进制形式表示。设有一数用X 表示真值，则原码表示可记作[X]原，例如：X1=＋1010110X2=－1001010其原码记作：[X1]原=[＋1010110]原=01010110[X2]原=[－1001010]原= 11001010在原码表示法中，对 0 有两种表示形式：[＋0]原=00000000[－0]原=10000000（ 二）反码机器数的反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。假设有一数用X表示真值，那么X 的反码表示记作[X]反，例如：X1=＋101011015X2=－1001010那么[X1]原=01010110[X1]反=[X1]原=01010110[X2]
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 原=11001010[X2]反=10110101在反码表示法中，对 0 也有两种表示形式：[＋0]反=00000000[－0]反=11111111反码通常作为求补过程的中间形式，即在一个负数的反码的末位上加 1，就得到该负数的补码。（ 三）补码机器数的补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在末位加 1 而得到的。设有一数用X 表示真值，则X 的补码表示记作[X]补，例如：16X1=＋1010110X2= – 1001010那么[X1]原=01010110[X1]补= [X1]原=01010110[X2]原=11001010[X2]补= 10110101+1=10110110在补码表示法中，0 只有一种表示形式：[＋0]补=00000000[－0]补= 11111111＋1=00000000所以有[＋0]补=[－0]补=00000000。【习题演练】1.采用补码表示的 8 位二进制数真值范围是( )。A.- 127～+127B.- 127～+128C.- 128～+12717D.- 128～+1281.【答案】C。
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 解析：补码表示的8 位二进制数真值范围是- 128～+127 ，原码和反码的范围是- 127～+127。2.补码25H 的真值是（ ）。A.25B.-25C.-37D.372.【答案】D。解析：正数的原码、反码与补码都相同。3.在机器中，（ ）的零的表示形式是唯一的。A.原码B.补码C.反码D.原码和反码3.【答案】B。解析：补码零的表示形式唯一，而原码和反码不唯一。18知识点 4、补码溢出（一 ）补码溢出的产生在补码加减运算中，有时会遇到这样的情况：两个正数相加，而结果的符号位却为 1（结果为负）；两个负数相加，而结果的符号位却为0（结果为正）。发生这种错误的原因在于两数相加之和的数值已超过了机器允许的表示范围。字长为n+1 位的定点整数（其中一位为符号位），采用补码表示，当运算结果大于2n- 1 或小于-2n 时，就产生溢出。设参加运算的两数为X、Y，做加法运算：①若X、Y 异号，不会溢出；②若X、Y 同号，运算结果为正且大于所能表示的最大正数或运算结果为负且小于所能表示的最小负数时，产生溢出。将两正数相加产生的溢出称为正溢；反之，两负数相加产生的溢出称为负溢。19（ 二）补码溢出的检测设被操作数为[X]
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 补=XsX1X2…Xn，操作数为[Y]补=YsY1Y2…Yn，其和（差）为[S]补=SsS1S2…Sn，则判断溢出的方法有以下三种：1.采用一个符号位两正数相加，结果为负表明产生正溢；两负数相加，结果为正表明产生负溢。因此可得出采用一个符号位检测溢出的方法：当Xs=Ys=0，Ss=1 时，产生正溢；当Xs=Ys=1，Ss=0 时，产生负溢。2.采用进位位两数运算时，产生的进位为：CsC1C2…Cn，其中：Cs 为符号位产生的进位，C1 为最高数值位产生的进位。两正数相加，当最高有效位产生进位（C1= 1）而符号位不产生进位（Cs=0）时，发生正溢。20两负数相加，当最高有效位没有进位（C1=0）而符号位产生进位（Cs= 1）时，发生负溢。3.采用变形补码（双符号位补码）在双符号位的情况下，把左边的符号位 Ss1 叫做真符，因为它代表了该数真正的符号，两个符号位都作为数的一部分参加运算。这种编码又称为变形补码。双符号位的含义如下：Ss1Ss2=00，结果为正数，无溢出；Ss1Ss2=01，结果正溢；Ss1Ss2=10，结果负溢；Ss1Ss2= 11，结果为负数，无溢出。【习题演练】1.算式65H-3EH 的运算
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结果是否有溢出，结果的真值为（ ）。A.有、39B.有、27C.无、39D.无、27211.【答案】C。解析：65H-3EH=101D-62D=39D，无溢出。知识点 5、寻址方式存储器既可用来存放操作数，又可用来存放指令。当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。因此，寻址方式可以分为数据寻址和指令寻址。寻找操作数的地址称为数据寻址，数据寻址方式较多，其最终目的都是寻找所需要的操作数。寻找下一条将要执行的指令地址称为指令寻址。（ 一）指令寻址指令寻址比较简单，它又可以细分为顺序寻址和跳跃寻址。顺序寻址可通过程序计数器PC 加 1，22自动形成下一条指令的地址；跳跃寻址是程序转移执行时的指令寻址方式，它通过转移类指令实现。跳跃寻址的转移地址形成方式有三种：直接（绝对）、相对和间接寻址，它与数据寻址方式中的直接、相对和间接寻址是相同的，只不过寻找到的不是操作数的有效地址而是转移的有效地址而已。（ 二）数据寻址数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 真实地址称为有效地址，记作 EA，它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如下所示。操作码OP 寻址特征# 形式地址A寻址方式是根据指令中给出的地址码字段寻找真实操作数地址的方式。23指令中的形式地址A—（寻址方式）→有效地址EA1.立即寻址在取指令时，操作码和操作数被同时取出，不必再次访问存储器，从而提高了指令的执行速度，如下图所示。立即寻址的特点是操作数本身设在指令字内，即形式地址A 不是操作数的地址，而是操作数本身，也称立即数。由于操作数是指令的一部分，故立即数的大小将受到指令长度的限制。立即寻址示意图2.直接寻址指令中地址码字段给出的地址A 就是操作数的有效地址：EA=A，如下图所示。直接寻址的缺点在于A 的位数限制了操作数的寻址范围，且必须修改A 的值，才能修改操作数的地址。24直接寻址示意图3.间接寻址指令中给出的地址A 不是操作数的地址，而是存放操作数地址的地址：EA=（A），如下图所示。间接寻址要比直接寻址灵活得多，它的主要优点为：一是扩大了寻址范围，可用指令的短地址访问大的主存空间，二是可将主存单元作为程序的地址指针，用以指示操作数在主存中的位置。当操作数的地址需要改变时，
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 不必修改指令，只需修改存放有效地址的那个主存单元（间接地址单元）的内容就可以了。25一级间接寻址二级间接寻址26除去一级间接寻址外，还有多级间接寻址。多级间接寻址为取得操作数需要多次访问主存，即使在找到操作数有效地址后，还需再访问一次主存才可得到真正的操作数。4.寄存器寻址指令中地址码部分给出某一通用寄存器的编号，所指定的寄存器中存放着操作数，如下图所示。它有两个明显的优点：一是从寄存器存取数据比主存快得多；二是由于寄存器的数量较少，其地址码字段比主存单元地址字段短得多。寄存器寻址示意图5.寄存器间接寻址27寄存器间接寻址示意图指令中的地址码给出某一通用寄存器的编号，被指定的寄存器中存放操作数的有效地址，而操作数则存放在主存单元中，如上图所示。这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数。6.变址寻址把指令给出的形式地址A 与变址寄存器Rx 的内容相加，形成操作数有效地址：EA ＝ A +（Rx），Rx 的内容为变址值，如下图所示。28变址寻址是一种广泛采用的寻址方式，通常指令中的形式地址作为基准地址，而 Rx 的内容作为修改量。在遇到需要频繁修改地址时，无须修改指令，只要修改变址值就可以了
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。变址寻址示意图如要把一组连续存放在主存单元中的数据（首地址是A）依次传送到另一存储区（首地址为B）中去，则只需在指令中指明两个存储区的首地址A和B（形式地址），用同一变址寄存器提供修改量29K，即可实现（A＋K）→B＋K。变址寄存器的内容在每次传送之后自动地修改。7.基址寻址将基址寄存器Rb 的内容与形式地址A 相加，形成操作数有效地址：EA＝（Rb）＋ A，基址寄存器的内容称为基址值，如下图所示。基址寻址示意图工30基址寻址和变址寻址在形成有效地址时所用的算法是相同的，而且在一些计算机中，这两种寻址方式都是由同样的硬件来实现的。但这两种寻址方式应用的场合不同，变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改。8.相对寻址相对寻址是基址寻址的一种变通，由程序计数器PC 提供基准地址，即：EA＝（PC）＋ A，A 是操作数和现行指令之间的相对位置，如下图所示。3132相对寻址示意图相对寻址方式的特点是：操作数的地址不是固定的，
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 它随着PC 值的变化而变化，并且与指令地址之间总是相差一个固定值A。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC 相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。指令中给出的位移量A 可正、可负，通常用补码表示，故对于指令地址而言，操作数地址可能在指令地址之前或之后。9.隐含寻址隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。如一地址指令格式，只给出一个操作数的地址，另一个操作数隐含在累加器ACC 中，故累加器ACC对一地址指令格式来说是隐含地址，如下图所示。33隐含寻址示意图10.堆栈寻址在堆栈寻址的指令字中没有形式地址码字段，它是一种零地址指令。堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组来实现，也可利用主存的一部分空间作堆栈，前者称为硬堆栈，后者称为软堆栈。【习题演练】1. 对某个寄存器中操作数的寻址方式称为( ) 寻址。A.直接B.间接C.寄存器34D.寄存器间接1.【答案】C。解析：操作数在寄存器中的寻址方式为：“寄存器直接寻址”，也叫“寄存器寻址
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ”。当操作数的有效地址在寄存器中时叫“寄存器间接寻址”。2.操作数所处的位置，可以决定指令的寻址方式。操作数的地址在寄存器中，寻址方式为（ ）。A.相对寻址B.直接寻址C.寄存器寻址D.寄存器间接寻址2.【答案】D。解析：操作数包含在指令中的寻址方式为立即寻址；操作数在寄存器中的寻址方式为寄存器寻址；操作数的地址在寄存器中的寻址方式为寄存器间接寻址。3.变址寻址和基址寻址的有效地址形成方式类似，但（ ）。35A.变址寄存器的内容在程序执行过程巾是不能改变的B.基址寄存器的内容在程序执行过程中是可以改变的C.在程序执行过程中，变址寄存器的内容不能改变而基址寄存器的内容可变D.在程序执行过程中，基址寄存器的内容不能改变而变址寄存器的内容可变3.【答案】D。解析：基址寄存器的内容由操作系统确定，而变址寄存器的内容由用户确定，因此基址寄存器的内容不能改变而变址寄存器的内容可变。知识点 6、存储芯片容量的计算存储芯片的容量与地址线的位数、数据线的位数均有关。地址线和数据线的位数共同反映存储芯片的容量。其公式可写为：36存储芯片容量=2A×D位，其中，A 为地址线根数，D 为数据线根数。如地址线为 10 根，数据线为4根
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，则存储芯片容量为 210×4＝4K 位；又如地址线为 14 根，数据线为 1根，则其容量为214×1＝16K 位。【习题演练】1.某DRAM 芯片，其存储容量为512K×8 位，该芯片的地址线和数据线数目为（ ）。A.8，512B.512，8C.18，8D.19，81.【答案】D。解析：512K X8 = 219 X 8，所以地址线和数据线分别为 19 和8。37知识点 7、DRAM 的刷新动态随机存储器刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。DRAM 是靠电容来存储信息的，由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对DRAM 的全部基本单元电路必作一次刷新，一般取2ms（2000μs），这个时间称为刷新周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本电路的逐行刷新，才能保证DRAM 内的信息不会丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。38（ 一）集中刷新集中刷新是在规定的一个刷新周期内，对全部存
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。如对 128×128 矩阵的存储芯片进行刷新，刷新的时间相当于 128 个读周期。若读/写周期为 0.5μs，则对 128 行集中刷新共需 128×0.5 =64μs，其余的 1936μs（=2000－64）用来读/写或维持信息。由于在这 64μs 时间内不能进行读写操作，故称为“死时间”。（ 二）分散刷新分散刷新把对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期分成两段，前半段用来读/写或维持信息，后半段用来刷新。若读/写周期为 0.5μs，则存取周期为 1μs，那么每隔128μs 就可将 128 行的存储芯片全部刷新一遍，但39这比允许的 2ms 间隔要短得多，且存取周期长了，整个系统的速度降低。（ 三）异步刷新前两种方式的集合，既可缩短“死时间”，又充分利用最大刷新间隔为 2ms 的特点。如可在 2ms内对 128 行各刷新一遍，即每隔 15.6μs（2000/ 128）刷新一行，每行的刷新时间仍为 0.5μs，但对每行来说，刷新间隔仍为2ms，“死时间”缩短为0.5μs。【习题演练】1.动态RAM 的刷新是以（ ）为单位进行的
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。A.存储矩阵B.行C.列D.存储单元1.【答案】B。解析：动态RAM 的刷新以行为单位进行。40知识点 8、存储器与 CPU 的扩展连接（一 ）存储容量的扩展由于单片存储芯片的容量总是有限的，很难满足实际的需要，因此，必须将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有位扩展和字扩展。1.位扩展位扩展是指增加存储字长，只在位数方向扩展（加大字长）。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。位扩展组成容量 地址 数据41存储器 64K×8 16 位 8 位存储芯片 64K×1 16 位 1 位如用 64K×1 的SRAM 芯片组成64K×8 的存储器，需要8 个芯片，如上表所示。当CPU 访问该存储器时，其发出的地址和控制信号同时传给8个芯片，选中每个芯片的同一单元，其单元的内容被同时读至数据总线的相应位，或将数据总线上的内容分别同时写入相应单元。2.字扩展字扩展是指增加存储器字的数量，它仅在字数方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。如用 16K×8 的SRAM 组成64K
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ×8 的存储器，需要4 个芯片，如下表所示。字扩展组成容量 地址 数据42存储器 64K×8 16 位 8 位存储芯片 16K×8 14 位 8 位在同一时间内四个芯片中只能有一个芯片被选中。3.字和位同时扩展字和位同时扩展组成容量 地址 数据存储器 64K×8 16 位 8 位存储芯片 16K×4 14 位 4 位字和位同时扩展是指既增加存储字的数量，又增加存储字长。当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展，这将是前两种扩展的组合，实现起来也较为容易。如用16K×4 的SRAM 组成64K×8 的存储器，需要8 个芯片，如上表所示。43（ 二）存储器与 CPU 的连接存储芯片与CPU 芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。1.地址线的连接存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU 地址线的低位与存储芯片的地址线相连。CPU 地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。2.数据线的连接CPU 的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU 
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的数据线数相等。3.读/写命令线的连接CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。4.片选线的连接44片选线的连接是CPU 与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端---cs是否能接收到来自CPU 的片选有效信号。5.合理选择存储芯片合理选择存储芯片主要是指存储芯片类型（RAM 或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM 则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单方便。【习题演练】1.用存储容量为16K×1 位的存储器芯片来组成一个 64K×8 位的存储器，则在字方向和位方向上分别扩展了（ ）倍。A.4 和2B.8 和4C.2 和445D.4 和81.【答案】D。解析：用64K 除以16K等于4，用8 除以1 等于8。2.RAM 芯片并联时可以使（ ）。A.存储器存储字长增加B.存储器地址范围增加C.存储器速度增加D.降低存储器的平均价格2.【答案】A。解析：并联时可以增加存储器的存储字长。知识点 9、死锁死锁是指多个进程在运行过程中因争夺资源而造成
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。如下图所示，有两个资源R1 和R2 供进程P1和P2 共享，P1 已占用资源R1，P2 已占用资源R2，46此时若 P2 继续要求R1,P1 要求R2，则 P1 和 P2 之间便会形成僵局，它们都在等待对方释放自己所需的资源，但同时又不释放自己已占用的资源，从而进入死锁状态。P1R2P2死锁示例（一 ）死锁产生的原因产生死锁的原因可归结为如下两点：1.竞争资源47R1当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。2.进程间推进顺序非法进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。（ 二）死锁产生的必要条件死锁的发生必须具备下列四个必要条件：1.互斥条件指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。2.请求和保持条件指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此48时请求进程阻塞，但又对自己已获得
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的其它资源保持不放。3.不剥夺条件指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。4.环路等待条件指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的P0 正在等待一个P1 占用的资源；P1 正在等待P2 占用的资源，……，Pn正在等待已被P0 占用的资源。（ 三）死锁的处理为保证系统中各进程的正常运行，应事先采取必要的措施，来预防发生死锁。系统已经出现死锁后，则应及时检测到死锁的发生，并采取适当措施来解除死锁。目前，处理死锁的方法可归结为以下四种：1.预防死锁49这是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。2.避免死锁该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。3.检测死锁这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机制，及时地检测出死锁的发
2025-08-10 14:53:29.201 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 生，并精确地确定与死锁有关的进程和资源；然后，采取适当措施，从系统中将已发生的死锁清除掉。4.解除死锁这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱50出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。【习题演练】1.以下各种情况中，属于死锁现象的是（ ）。A.某进程执行了死循环B.某进程为了得到某资源，等待了很长的时间C.某进程为了得到某资源，等待了无限的时间D.操作系统故障1.【答案】C。解析：死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，它们都将无法再向前推进。由死锁概念可知，只有C 选项符合。2.死锁预防是保证系统不进入死锁状态的静态策略，其解决方法是破坏产生死锁的四个必要条件之一。下列方法中破坏了“循环等待”条件的是( )。51A.银行家算法B.一次性分配策略C.剥夺资源法D.资源有序分配法2.【答案】D。解析：资源有序分配法可以破坏“循环等待”条件。3.产生系统死锁的原因可能是由于（ ）。A.进程释放资源B.一个进程进入死循环C.多个进程竞争资源，出现了循环
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 等待D.多个进程竞争共享型设备3.【答案】C。解析：产生系统死锁的原因可能是多个进程竞争资源，从而出现了循环等待。52知识点 10、处理机调度的层次（ 一）作业调度作业调度又称高级调度，或宏观调度，根据某种算法，把外存上处于后备队列中的作业调入内存。（ 二）中级调度中级调度又称中程调度，将那些暂时不能运行的进程调至外存上去等待，此时的进程状态称为挂起状态。中级调度实际上就是存储器管理中的对换功能。（ 三）进程调度进程调度又称低级调度，或微观调度，它决定就绪队列中的哪个进程应获得处理机。53进程调度的方式有两种：非抢占方式和抢占方式。抢占方式基于的原则有三个：优先权原则、短作业/进程优先原则、时间片原则。【习题演练】1.操作系统中的高级调度是指（ ）。A.线程调度B.作业调度C.进程内、外存交换调D.进程调度1.【答案】B。解析：高级调度又称为作业调度、宏观调度或者长程调度，其主要任务是按照一定的原则从外存上处于后备状态的作业中选择一个或者多个，给它们分配内存、输入输出设备等必要的资源，并建立相应的进程，以使作业具有获得竞争处理器的权利。2.CPU 的调度分为高级、中级和低级三种，其中低级调度是指（ ）调度。5
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4A.作业B.交换C.进程D.线程2.【答案】C。解析：进程调度又称低级调度。知识点 11、调度算法（ 一 ）先来先服务调度算法先来先服务（First Come First Served，FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS 算法比较有利于长作业（进程），而不利于短作业（进程）。（ 二）短作业/进程优先调度算法短作业 / 进程优 先调度算法（ShortestJob/Process First，SJ/PF），是指对短作业或短进程55优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。需要注意的是短进程优先调度算法中，每次选择的是已进入系统的、要求服务时间最短的进程。SJ/PF 调度算法的缺点在于：该算法对长作业不利；完全未考虑作业的紧迫程度，因而不能保证紧迫性作业/进程会被及时处理；由于
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 作业/进程的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。56（ 三 ）高优先权优先调度算法作为作业调度算法，此算法常被用于批处理系统中，作为进程调度算法，还可用于实时系统中。对于最高优先权优先调度算法，其关键在于：它是使用静态优先权，还是用动态优先权，以及如何确定进程的优先权。1.静态优先权静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。确定进程优先权的依据：进程类型、进程对资源的需求和用户需求。2.动态优先权动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。动态优先权的变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间57= 响应时间/要求服务时间= 响应比这种算法即为高响应比优先调度算法（HighestResponse-ratio Next，HRN），它既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折中。但每次要进行调度之前，都须先做响应比的计算，这会增加系统开销。
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: （ 四 ）基于时间片的轮转调度算法1.时间片轮转法其基本思想是为每一个进程分配一个时间段，该时间段被称为时间片，即允许该进程运行的时间。每个进程只能依次循环轮流运行，如果时间片结束时进程还在运行，CPU 将剥夺该进程的使用权转而将CPU 分配给另一个进程。如果进程在时间片结束之前阻塞或结束，CPU 当即进行切换。为了实现进程的循环执行，将每次被中止运行的进程存入就绪58队列的末尾，同时将CPU 分配给就绪队列中的队首进程。该算法是一种简单而又公平的算法，使用非常广泛。2.多级反馈队列调度算法前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。【习题演练】1.为了对紧急进程或重要进程进行调度，调度算法应采用（ ）。A.先进先出调度算法B.优先数法59C.最短作业优先调度D.定时轮转法1.【答案】B。解析：为了对紧急进程或重要进程进行调度，可遵
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 循优先权准则，采用优先数法。2.按照作业到达的先后次序调度作业，排队等待时间最长的作业被优先调度，这是指（ ）调度算法。A.先来先服务B.最短作业优先C.定时轮转法D.优先数法2.【答案】A。解析：先来先服务按作业进入的先后次序安排。优点是实现简单，缺点是不利于运行时间短的作业。3.以下（ ）调度算法对CPU 繁忙型进程有利。A.FCFSB.时间片轮转60C.多级反馈队列D.短进程优先3.【答案】A。解析：CPU 繁忙型进程占用CPU时间比较多，更接近于长进程，故选A，FCFS 算法有利于长进程。知识点 12、内存的连续分配连续分配方式，是指为一个用户程序分配一个连续的内存空间。它又可进一步分为：单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配四种。（ 一）单一连续分配单一连续分配是最简单的一种存储管理方式，只能用于单用户、单任务的操作系统中。它将内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除61系统区以外的全部内存空间，提供给用户使用，其中仅能存放一道作业。（ 二）固定分区分配固定分区分配是最早的多道程序的存储管理方式，是指系统先把内存划分成若干个
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 大小固定的分区，一旦划分好，在系统运行期间便不再重新划分。为了满足不同程序的存储需求，各分区的大小可以不等，也可以相等，但在每个分区中只装入一道作业。采用固定分区分配方法存在以下缺点：（1）由于预先规定了分区的大小，使得大作业无法装入，用户不得不采取其他技术加以补救，增加了用户的负担；（2）内存利用率不高，作业很少能恰好填满分区；（3）固定分区无法实现动态扩充内存空间的要求；62（4）由于分区个数在系统初启时确定，因此会限制多道运行的程序个数，特别不适于分时系统交互型用户及内存变化很大的情形。（ 三）动态分区分配动态分区分配算法根据进程的实际需要，动态地分配内存空间。在实现可变分区分配时，涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作三个问题。常用的分配算法主要有以下几种：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。1.首次适应算法该算法将空闲分区按起始地址递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，直至找到第一个能满足要求的空闲分区为止，并按作业的大小从该分区中分割出一块内存空间分配给请求者，剩余的部分仍留在空闲分区表63或链中。该算法优先使用内存低
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 址部分的空闲分区，从而能在高址部分保留较大的空闲分区，但它会在内存的低端留下很多难以利用的小空闲分区，而每次分配时，对空闲分区的查找都必须经过这些分区，从而会增加查找的开销。2.循环首次适应算法该算法由首次适应算法演变而成，每次分配均从上次分配的位置之后开始查找，并将第一个能满足要求的空闲分区分割并分配出去。其特点是内存中的空闲分区分布得更均匀，从而减少查找空闲分区的开销，但它会使存储器中缺乏大的空闲分区。3.最佳适应算法该算法将空闲分区按大小递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，并将第一个能满足要求的空闲分区分割并分配出去。该算法尽管被称为“最佳”，但情况并非总是如此，因为每次分配后所切割下来的剩余部分总64是最小的，它会在内存中留下大量难以利用的小空闲分区。4.最坏适应算法该算法将空闲分区按大小递减的次序排列。当作业申请一个空闲区时，先检查空闲分区链（表）的第一个空闲区是否大于或等于所要求的内存长度，若该空闲区长度小于要求，则分配失败，否则分配相应的存储空间给用户，然后修改和调整空闲分区链（表）。该算法的优点是产生碎片的几率最小，缺点主要是使内存中缺乏大的空闲区。（四 ）可重定
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 位分区分配在动态分区分配方式中，经过一段时间的分配和回收后，内存中会产生很多小的空闲分区。此时，可能有用户程序因找不到足够大的空闲分区而难以装入，但所有空闲分区容量的总和却足以满足该程序的要求。65上述这些不能被利用的空闲分区可采用以下办法加以解决：将内存中的所有作业进行移动，从而将原来分散的多个空闲分区移到同一处拼接成一个大的空闲分区，以装入用户的作业。这种技术被称为“拼接”或“紧凑”。可重定位分区分配方式就是在动态分区分配方式的基础上增加紧凑功能，即在找不到足够大的空闲分区、而空闲分区总和却能满足用户的要求时，对内存空间进行紧凑。由于紧凑时，作业要在内存中移动位置，因此，它需要得到动态重定位技术的支持，这也是它被称为动态重定位分区分配的原因。【习题演练】1.分区存储管理中的首次适应算法，要求把空闲区按照（ ）的次序登记在空闲区表中。A.大小递减B.大小递增C.地址递减66D.地址递增1.【答案】D。解析：首次适应算法要求对空闲分区按地址从小到大的顺序排列。2.可重定位内存的分区分配目的为（ ）。A.解决碎片问题B.便于多作业共享内存C.回收空白区方便D.便于用户干预2.【答案】A。解析：可重定位内存的分区
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 增加了紧凑的功能，通常在找不到足够大的空闲分区来满足用户需求时使用，解决了碎片问题。3.在以下存储管理方案中，不适用于多道程序设计系统的是（ ）。A.单一连续分配B.固定式分区分配C.可变式分区分配D.页式存储管理673.【答案】A。解析：单一连续分配只能用于单用户、单任务的操作系统。知识点 13、基本的分页存储管理在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。（ 一）页面与页表基本的分页存储管理方式中，系统将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。相应地，将内存空间分成若干个与页面同样大小的块，称为物理块或页框。内存的分配以块为单位，并允许将一个进程的若干页分别装入到多个不相邻的物理块中。68为了地址映射的方便，页面的大小通常设置成2 的幂。如果页面的大小为2k 字节，逻辑地址的长度为 n 位，则分页系统的地址结构如下图所示，可将线性的逻辑地址分成两部分：右边的 k 位为页内位移量（即页内地址）W，左边的n-k 位为页号P。n-1 k k-1 0页号P 位移量W分页地址中的地址结构在进
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 程运行时，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页面映射表，简称页表，进程的每个页占页表的一个表项，其中记录了相应页对应的内存块的块号，以及用于分页保护的存取控制信息。下图给出了分页系统的一个内存分配实例，其中页面大小为4K，用户作业的大小为11K。由于进程的最后一页不足一块，因此造成了存放该页的物69理块中部分空间的浪费，这部分被浪费的空间被称为“页内碎片”。分页系统中的内存分配（ 二）地址变换机构页式存储管理系统中，逻辑地址到物理地址的转换是在进程执行的过程中，由硬件地址变换机构借助于页表自动进行的。1.基本的地址变换机构通常将作业的页表存放在内存中，而在系统中只设置一个页表寄存器PTR（Page-Table Register），当一进程因CPU 调度而转入执行状态时，其页表的70内存始址和长度将从该进程的 PCB 中装入页表寄存器。当进程要访问某个逻辑地址中的指令或数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号大于或等于页表长度，便产生越界中断，否则便以页号为索引去检索页表，从中得到该页的物理块号，送入物理地址寄存
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与页内地址拼接，形成对应的物理地址。2.具有快表的地址变换机构由于页表存放在内存中，故CPU 每存取一个指令或数据时都要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次才根据物理地址存取指令或数据，这使得计算机的处理速度降低近1/2。为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”或“快表”，用以存放当前访问的那些页表项。71在进行地址转换时，地址变换机构自动将逻辑地址中的页号并行地与快表中的所有页号进行比较，若其中有与此相匹配的页号，便可直接从快表中读出该页对应的物理块号，并送到物理地址寄存器中。如果在快表中未找到对应的页号，则仍需访问内存中的页表来进行地址转换，同时还必须将得到的页表项与页号—起装入到快表中，若快表已满，则还需根据置换算法淘汰某个快表项，以装入新的内容。（ 三）多级页表现代的大多数计算机系统都支持非常大的逻辑地址空间，此时，页表就变得非常大，要为它分配一大段连续的内存空间将变得十分困难。对于该问题，可利用将页表进行分页，并离散地将各个页表存放到内存块中的办法加以解决，此时，必须为离散分配的页表再建立一张页表，称为外层
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 页表，用来记录存放各页表页的内存块号，从72而形成了两级页表。在使用两级页表的分页系统中，每次访问一个数据需访问三次内存，故同样需增设快表来有效地提高访问速度。如果外层页表仍十分大，则可以将它再进行分页，并离散地存放到内存中，然后再通过一张第二级的外层页表来记录存放各外层页表页的内存块号，这样，便形成了三级页表，并可进一步形成更多级的页表。【习题演练】1.碎片现象的存在使得（ ）。A.内存空间利用率降低B.内存空间利用率提高C.内存空间利用率得以改善D.内存空间利用率不影响1.【答案】A。解析：碎片会占用计算机的内存，使部分内存空间不能满足程序运行的最低标准，从而不能被使用，降低内存的使用效率。732.基本分页存储管理中，若没有引入快表，则每次从主存取指令或取操作数，要（ ）访问主存。A.1 次B.2 次C.3 次D.4 次2.【答案】B。解析：要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次根据物理地址存取指令或操作数。知识点 14、基本的分段存储管理用户通常喜欢将自己的作业按逻辑关系划分成若干段，然后通过段名和段内地址来访问相应的程序或数据，还希望能以段为单位对程序和数据进行共享和保护，并
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 要求分段能动态增长。分页系统虽然能较好地解决动态分区的碎片问题，却难以满足74用户的上述要求，因此又引入了分段式存储管理方式。在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如主程序段、子程序段、数据段等。每个段都有自己的名字，都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，故各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，即其逻辑地址由段号和段内地址所组成。分段地址中的地址具有如下图的结构：段号 段内地址31 16 15 0分段地址中的地址结构在该地址结构中，允许一个作业最长有64K个段，每个段的最大长度为64KB。75（ 一）段表在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地放入内存不同的分区。系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，但更常多的是放在内存中。在配置了段表后，执行中的进程可通过查找段表找到每个段所对应的内存区。故段表是用于实现从逻辑段到物理内存区的映射。（ 二）地址变换机
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 构为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放正在执行进程的段表始址和长度。在进行地址转换时，地址变换机构将逻辑地址中的段号与段表寄存76器中的段表长度进行比较，若段号不小于段表长度，便产生越界中断；否则便以段号为索引去检索段表，从中得到该段的基址和长度；接着检查段内地址是否超过段长，若超过，则发出越界中断信号；若未超过，则将该段的基址与段内地址相加，从而得到对应的物理地址。（ 三 ）分页和分段的主要区别分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换，这是它们的相同之处，其不同主要表现在以下三个方面：①页是信息的物理单位，分页是为提高内存的利用率；段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。②页的大小固定且由系统决定，在系统中只能有一种大小的页面；而段的长度却不固定，取决于用户所编写的程序，通常由编译程序在编译时，根据信息的性质来划分。77③分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。（ 四）
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 段页式存储管理方式为了既能像分页系统那样有效地利用内存，又能像分段系统那样满足用户多方面的需要，操作系统中又引入了段页式存储管理方式。段页式系统的基本原理，是先将用户程序分成若干个段，再把每个段分成若干个页。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成。在段页式系统中，为获得一条指令或数据须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中78取出该页所在的物理块号，并将该块号与页内地址一起形成物理地址；第三次访问是取指令或数据。【习题演练】1.页是（ ）单位，由（ ）划分，它的长度（ ）。A.逻辑，系统，定长B.逻辑，用户，不定长C.物理，用户，不定长D.物理，系统，定长1.【答案】D。解析：页是物理单位，由系统划分，它的长度固定。2.下列方法中，解决碎片问题最好的存储管理方法是（ ）。A.基本页式存储管理B.基本分段存储管理C.固定大小分区管理D.不同大小分区管理792.【答案】A。解析：离散分配方式将一个作业离散地存放到内存中，从而使系统无须紧凑便能很好地解决碎片问题，而离散分配方式中，分页是为解决碎片问题，提高内存的利用率，分段的目的则是为了
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 能更好地满足用户的需要，故选A。3.分段管理提供（ ）维的地址结构。A.1B.2C.3D.43.【答案】B。解析：分段存储管理的地址空间是二维的，标识一个地址时，既需给出段名，又需给出段内地址。80知识点 15、虚拟存储器（一）局部性原理程序局部性原理是指程序在执行时将呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。局限性还表现在下述两方面：1.时间局限性如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。2.空间局限性一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。81基于局部性原理产生了虚拟存储器。（ 二）虚拟存储器的实现虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。虚拟存储器的实现，建
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 立在离散分配的存储管理方式的基础上。目前，所有的虚拟存储器都是采用下述方式之一实现的：1.请求分页系统在分页系统的基础上，增加了请求调页功能和页面置换功能，便形成页式虚拟存储系统。它允许只装入少数页面的程序及数据，便启动运行。之后再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。822.请求分段系统在分段系统的基础上，增加了请求调段及分段置换功能后，便形成段式虚拟存储系统。它允许只装入少数而非所有段的用户程序和数据，即可启动运行。之后再通过调段功能和段的置换功能将暂不运行的段调出，同时调入即将运行的段。（ 三）虚拟存储器的特征虚拟存储器具有多次性、对换性和虚拟性三大主要特征。1.多次性多次性是指虚拟存储器将一个作业分成多次调入内存。多次性是虚拟存储器最重要的特征，任何其它的存储管理方式都不具有这一特征。2.对换性在作业运行期间，虚拟存储器允许将内存中暂时不能运行的进程或暂时不用的程序或数据，调出到外存上，以便腾出足够的内存空间，再把具备运83行条件的进程或进程所需要的程序和数据调入内存。如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。这种对换被
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。而相应的，如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。它们是实现虚拟存储器的基础。3.虚拟性虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。虚拟性是实现虚拟存储器的最重要的目标。虚拟性是以多次性和对换性为基础的，仅当系统允许将作业分多次调入内存，并能将内存中暂时不运行的程序和数据换至盘上时，才有可能实现虚拟存储器；而多次性和对换性又必须建立在离散分配的基础上。84（ 四 ）请求分页存储管理方式请求分页系统是建立在基本分页存储管理基础上的，增加了请求调页功能和页面置换功能。请求分页便成为目前最常用的一种实现虚拟存储器的方式。为了确定所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：1.预调页策略如果进程的许多页是存放在外存的一个连续区域中，则一次调入若干个相邻的页，会比一次调入一页更高效些。但如果调入的一批页面中的大多数都未被访问，则又是低效的。可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。这种策
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。2.请求调页策略85当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由OS 将其所需页面调入内存。由请求调页策略所确定调入的页，是一定会被访问的，再加之请求调页策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。【习题演练】1.实现虚拟存储器的目的是（ ）。A.实现存储保护B.实现程序浮动C.扩充辅存容量D.扩充主存容量1.【答案】D。解析：实现虚拟存储器的目的是为了扩充主存容量。2.虚拟存储器的最大容量是由（ ）决定的。A.计算机系统的地址结构和外存空间B.页表长度86C.内存空间D.逻辑空间2.【答案】A。解析：虚存容量不是无限的，最大容量受外存可利用的总容量和计算机总线地址结构的限制。3.具有虚拟存储功能的管理方法包括（ ）。A.可变分区存储管理B.分页式存储管理C.请求分段存储管理D.段页式存储管理3.【答案】C。解析：虚拟存储功能涉及内存的存储空间扩充问题。请求分段存储管理：作业可以装入不连续的存储空间中，且作业不要求全部装入内存就可以运行，因此具有空间扩充功能；段页式存储管理：作业虽然可以装入不连续
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的存储空间中，但是作业仍要求全部装入才可运行，因此不具备空间扩充功能。87知识点 16、页面置换算法置换算法的好坏直接影响系统的性能。若采用的置换算法不合适，可能出现这样的现象：刚被换出的页，很快又被访问，为把它调入而换出另一页，之后又访问刚被换出的页……如此频繁地更换页面，以致系统的大部分时间花费在页面的调度和传输上。此时，系统看起来很忙，但实际效率却很低。这种现象称为“抖动”。好的页面置换算法能够适当降低页面更换频率（减少缺页率），尽量避免系统“抖动”。为评价一个算法的优劣，可将该算法应用于一个特定的存储访问序列上，并且计算缺页数量，存储访问序列也叫页面走向。（一）最佳（OPT）置换算法最佳置换算法（Optimal，OPT）是选择不再访问的页面或者是在未来最长时间内不再被访问的页88面予以淘汰。最佳页面置换算法是在理论上提出的一种算法，具有最好的性能，但实现是困难的，因为它需要人们预先知道一个进程在整个运行过程中页面走向的全部情况。不过，这个算法可用来衡量其他算法的优劣。（ 二 ）先进先出（FIFO） 页面置换算法FIFO 算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰，该算法的
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 出发点是最早调入内存中的页面，其不再被使用的可能性会比较高。其实现简单、直观，对按线性顺序访问的程序比较合适，面对其他情况则效率不高，因为经常被访问的页面，往往在内存中因停留得最久而被淘汰。一般而言，对于任一作业或进程，如果给它分配的内存页面数越接近于它所要求的页面数，则发生缺页的次数会越少。在极限情况下，这个推论是成立的，如果给一个进程分配了它所要求的全部页89面，则不会发生缺页现象。但是，使用 FIFO 算法时，在给进程或作业分配满足它所要求的页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为Belady 现象。（ 三）最近最久未使用（LRU） 置换算法LRU 算法是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能以“最近的过去”作为“最近的将来”的近似，选择在最近一段时间里最久没有使用过的页面予以置换。因此，LRU 算法是与每个页面最后使用的时间有关的，当必须置换一个页面时，LRU 算法选择过去一段时间内最久未使用的页面。LRU 置换算法是一种比较好的算法，但需要硬件的支持：移位寄存器或栈。关于确定最后使用时间的问题，对于移位寄存器而言，当进程访
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 问某物理块时，要将相应寄存器的位置成“1”。此时，定时信号将每隔一定时间将90寄存器右移一位。如果把 n 位寄存器的数看做是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。对于栈而言，每当访问一个页面时，便将它的页面号从栈中移出，压入栈顶。因此栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。（ 四）Clock 置换算法LRU 算法是较好的一种算法，但它要求有较多的硬件支持，故在实际应用中大多采用LRU 的近似算法。Clock 算法就是用得较多的一种LRU 近似算法。Clock 置换算法采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的表针，指向可能要淘汰的页面。它在存储分块表的每一表项中增加一个访问位，操作系统定期地将它们置为 0。当某一页被访问时，由硬件91将该位置为 1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0 后还未使用过，可把该位是0 的页淘汰出去，因为在最近一段时间里它未被访问过。由于该算法是循环地检查各页面的使用情况，故称为Clock 算法。但因该算法只有一位访问位，只能用它表示该页是否已经使
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用过，而置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法（Not Recently Used，NRU）。【习题演练】1.在请求调页中可采用多种置换算法，其中LRU 是（ ）置换算法。A.最佳B.最近最久未用C.最近未用D.最少使用921.【答案】B 。解析：LRU 是最近最久未用置换算法。2.Clock 置换算法又称为（ ）。A.最久驻留置换算法B.最近最久未使用置换算法C.最近未使用置换算法D.最少使用置换算法2.【答案】C。解析：最近未使用算法是Clock置换算法。知识点 17、线性表（ 一）概念线性表是最基本、最简单、也是最常用的一种数据结构。线性表是具有n （n≥0）个类型相同的数据元素组成的有限序列。93线性表的长度：线性表中元素的个数。空表：长度为0 的线性表。（ 二）特点线性表中一定存在唯一的“第一元素”。线性表中一定存在唯一的“最后元素”。除最后一个元素之外，均有唯一的后继（后件）。除第一个元素之外，均有唯一的前驱（前件）。（ 三）表示方式1.线性表的顺序表示线性表中的数据元素是用一组地址连续的存储单元依次存储的。顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。942.线性表的链式表示（1）线性链表用一组任意的存储单元存储线性表的数据元素，存储单元不一定是连续的，可以连续，也可以不连续。（2）循环链表循环链表中最后一个结点的后继指针指向头结点，使整个链表形成一个环形。（3）双向链表在双向链表中，每个结点有两个指针域，一个指向它的直接后继，另一个指向它的直接前驱。【习题演练】1.下列有关线性表的叙述中，正确的是（ ）。A.线性表中的元素之间是线性关系B.线性表中至少有一个元素C.线性表中任何一个元素有且仅有一个直接前驱95D.线性表中任何一个元素有且仅有一个直接后继1.【答案】A。解析：线性表可以为空，并且线性表中的第一个结点是没有前驱结点的，最后一个结点没有后继结点。知识点 18、栈和队列（ 一）栈的定义1.栈的定义栈是一种只能在一端进行插入或删除操作的线性表。栈中的数据元素是线性关系。栈顶：允许进行插入或删除操作的一端。栈底：不允许进行插入和删除操作，固定不变的一端。入栈：栈的插入操作。出栈：栈的删除操作。962.栈的
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 特点先进后出（First In Last Out，简称FILO）、后进先出（Last In First Out，简称LIFO）。3.栈的存储结构（1）顺序栈使用顺序存储结构存储栈。（2）链式栈使用链式存储结构存储栈。（ 二）队列的定义1.队列的定义97队列是一种运算受限制的线性表，元素的添加在表的一端进行，而元素的删除在表的另一端进行。队头：允许删除元素的一端。队尾：允许添加元素的一端。入队：向队列添加元素。出队：从队列中删除元素。2.队列的特点先进先出（FIFO）（先入队的元素先出队，后入队的元素后出队）。3.存储结构顺序队：使用顺序存储结构的队列。链队：使用链式存储结构的队列。98【习题演练】1. 下述有关栈和队列的区别，说法错误的是( )。A.栈是限定只能在表的一端进行插入和删除操作B.队列是限定只能在表的一端进行插入和在另一端进行删除操作C.栈和队列都属于线性表D.栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（n）1.【答案】D。解析：栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（1）。因为都是在端点处进行的操作。2.为解决计算机主机与打印机之间速度不匹配问题，
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是( )。99A.栈B.队列C.树D.图2.【答案】B。解析：主机将数据依次写入，打印机依次取出，应该属于先进先出的特点，既使用的逻辑结构是队列。知识点 19、树（ 一）定义树形结构是一种重要的非线性结构，树是n 个结点的有限集合，在任一棵非空树中：（1）有且仅有一个称为根的结点。（2）其余结点可分为m 个互不相交的集合，而且这些集合中的每一集合都本身又是一棵树，称为根的子树，因此树是递归结构。100（ 二）基本术语结点：包含一个数据元素及若干指向其子树的分支。结点的度数：结点的非空子树个数。树的度：树中各节点中度的最大值。分支结点：度不为0 的结点。叶子结点：度为0 的结点。孩子：结点的子树的根。双亲：结点的直接前驱。兄弟：同一个双亲的孩子之间互为兄弟。堂兄弟：双亲在同一层的结点互为堂兄弟。祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。子孙：以某结点为根的子树中的所有结点，都是该结点的子孙。层次：从根开始，根为第一层，根的孩子为第二层，以此类推。101树的深度（或者高度）：树
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 中结点的最大层数。结点的深度和高度：结点的深度是从根结点算起的，根结点的深度为 1；结点高度是从最底层的叶子结点算起的，最底层叶子结点的高度为 1。有序树：子树按照一定的次序从左向右排列，相对次序不能随意变换。无序树：子树无一定的次序排列，相对次序可以随意变换。丰满树：即理想平衡树，要求除最底层外，其他层都是满的。森林：是由零个或多个不相交的树所组成的集合。【习题演练】1.如果在数据结构中每个数据元素只可能有一个直接前驱，但可有多个直接后继，则该结构是( )。A.栈102B.队列C.树D.图1.【答案】C。解析：树结构的每个结点都有一个前驱，但可以有多个后继。知识点 20、二叉树（ 一）定义二叉树是一个连通的无环图，并且每一个顶点的度不大于 2。有根二叉树还要满足根结点的度不大于 2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2 个子结点。（ 二）主要性质①二叉树的第 i 层上至多有2i- 1 个结点。②深度为k 的二叉树至多有2k- 1 个结点。103（补充概念：a.满二叉树：深度为k，有2k- 1 个结点。b.完全二叉树：给满二叉树的结点编号，从上至下，从左至右，n 个结点的完全二叉树中结点在对应
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 满二叉树中的编号正好是从 1 到n。③叶子结点 n0，度为2 的结点为n2，则n0 =n2+1。④n个结点的完全二叉树深度为 l㎀ g2n」+1。⑤n 个结点的完全二叉树，结点按层次编号。a.i 的双亲是1 n/2，如果i =1时为根（无双亲）。b.i 的左孩子是2i，如果2i>n，则无左孩子。c.i 的右孩子是2i + 1，如果2i + 1>n 则无右孩子。（ 三）存储结构1.顺序存储结构顺序存储结构即用一个数组来存储一棵二叉树，这种存储方式最适合于完全二叉树，用于存储104一般二叉树则会浪费大量的存储空间。将完全二叉树中的结点值按编号依次存入一个一维数组中，即完成了一棵二叉树的顺序存储。例：结点 A B C D E数组下标 0 1 2 3 4 52.链式存储结构二叉树中的每个结点用一个链结点来存放，结点结构如下：lchild data rchild其中，data 表示结点数据域，用于存储对应的数据元素；lchild 和 rchild 分别表示左指针域和右指针域，分别用于存储左孩子结点和右孩子结点的位置。（ 四）遍历算法若以L、D、R 分别表示遍历左子树、遍历根结点和遍历右子树，则有六种遍历方案：DLR、L
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: DR、LRD.DRL、RDL、RLD。若规定先左后右，则只有105前三种情况，分别是：DLR--先（根）序遍历；LDR--中（根）序遍历；LRD--后（根）序遍历。【习题演练】1.设非空二叉树中度数为0 的结点数为n0，度数为 1 的结点数为n1，度数为2 的结点数为n2，则下列等式成立的是（ ）。A.n0=n1+n2B.n0=2n1+1C.n0=n2+1D.n0=n1+11.【答案】C。解析：二叉树中度为0 的结点个数等于度为2 的结点个数加一。2.一棵树高为k 的完全二叉树至少有（ ）个结点。A.2k- 1B.2k- 1- 1C.2k- 1106D.2k2.【答案】C。解析：完全二叉树层次最小为k时，前k- 1 层都是满的，第k 层有一个结点。3.深度为 5 的完全二叉树的结点数不可能是( )。A.15B.16C.17D.183.【答案】A。解析：深度为5 的完全二叉树结点最多为二的 5 次方减一个，即31 个，最少为 16个。4.二叉树的先序遍历和中序遍历如下：先序遍历：EFHIGJK，中序遍历：HFIEJKG，则二叉树根结点为（ ）。A.EB.FC.G107D.H4.【答案】A。解析：先序遍历顺序为根
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 左右，所以树根为E。知识点 21、图（ 一）图的定义图是由顶点集V 和集合E（边的集合）组成的，可以定义为G=（V，E）。V 是顶点的非空有穷集合，E 是可空的边的有穷集合。（ 二）图的术语1.无向图对于一个图，若每条边都是没有方向的，则称该图为无向图。如下图：108对于此无向图，(Vi，Vj)和(Vj，Vi)表示的是同一条边。无向图的顶点集和边集分别表示为：V(G)={V1，V2，V3，V4，V5}E(G)={(V1，V2)，(V1，V4)，(V2，V3)，(V2，V5)，(V3，V4)，(V3，V5)，(V4，V5)}2.有向图对于一个图，若每条边都是有方向的，则称该图为有向图。如下图：109在此有向图中，<Vi，Vj>和<Vj，Vi>是两条不同的有向边。有向边又称为弧。终端点也称为弧头，初始点也称为弧尾。有向图的顶点集和边集分别表示为：V(G)={V1，V2，V3}E(G)={<V1，V2>，<V2，V3>，<V3，V1>，<V1，V3>}3.无向完全图和有向完全图具有n(n- 1)/2 条边的无向图为无向完全图。具有n(n- 1)条边的有向图称为有向完全图。4.稀疏图有很少条边或弧的图。5.稠密图有很
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 多条边或弧的图1106.顶点图中的数据元素通常称为顶点。7.顶点的度无向图中，顶点的度表示以该顶点作为端点的边的数目。有向图中，顶点的度分为入度和出度。入度表示以该顶点为终点的边的数目，出度是以该顶点为起点的边的数目，该顶点的度等于其入度、出度之和。8.回路、环指一条路径的起点和终点为一个顶点。9.连通图在无向图中，如果从顶点v1 到顶点v2 有路径，则称v1 和v2 是连通的。如果图中任意两个顶点都是连通的，则称图是连通图。10.连通分量指的是无向图中的极大连通子图。11.强连通图111在有向图G 中，对任意一对顶点vi 和vj（vi≠vj），若从vi 到vj 和从vj 到vi 都存在路径，则称G 是强连通图。12.强连通分量有向图中的极大强连通子图称为有向图的强连通分量。（ 三）遍历算法从图的某一顶点出发，访问图中其余顶点，且使每个顶点仅被访问一次，这一过程称为图的遍历。图的遍历分为深度优先搜索遍历和广度优先搜索遍历。1.广度优先广度优先搜索类似于树的按层次遍历。选取图中任意一个顶点Vi作为出发点，按照下列步骤遍历图。（1）首先访问出发点Vi。112（2）接着依次访问Vi的所有未被访问过的邻接点Vi1，V
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: i2，Vi3，ⅆ , Vit并均标记为已访问过。（3）然后再按照Vi1，Vi2，ⅆ , Vit的次序，访问每一个顶点的所有未被访问过的顶点，并均标记为已访问过。（4）依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。2.深度优先深度优先搜索（DFS）类似于树的先序遍历。【习题演练】1.具有n 个结点的连通图至少有（ ）条边。A.n-1B.nC.n（n- 1）/2D.2n1.【答案】A。解析：具有n 个结点的连通图至少有n-1 条边。1132.在有向图中每个顶点的度等于该顶点的( ) 。A.入度B.出度C.入度与出度之和D.入度与出度之差2.【答案】C。解析：有向图的某个顶点v，把以 v 为终点的边的数目称为v 的入度；以v 为始点的边的数目称为v 的出度；v 的度则定义为该顶点的入度和出度之和。3.设连通图G 中的边集E={（a，b），（a，e），（a，c），（b，e），（e，d），（d，f），（f，c）}，则从顶点a 出发可以得到一种深度优先遍历的顶点序列为（ ）。A.abedfcB.acfebdC.aebdfcD.aedfcb1143.【答案】A。图的深度优先遍历类似于树的前序遍历。采
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用的搜索方法的特点是尽可能先对纵深方向进行搜索。知识点 22、数据模型（ 一）数据模型的概念数据模型是对现实世界数据特征的抽象。也就是说，数据模型是用来描述数据、组织数据和对数据进行操作的。（ 二）两类数据模型在数据库中模型主要分为两大类：一类为概念模型；另一类为逻辑模型和物理模型。概念模型也称为信息模型，在数据库设计阶段，由设计员按照用户观点建模实现对现实世界的概念抽象。115http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8656077逻辑模型包括网状、层次、关系和对象模型等，由设计人员按照计算机观点建模实现概念模型到适应某DBMS 的逻辑模型的转变。再由DBMS 完成逻辑到物理模型的转变。物理模型是数据最底层的抽象，描述数据的存储方式和方法。（ 三 ）现实世界的数据化过程现实世界 信息世界 数据世界概念模型现实世界的数据化过程【习题演练】1.常见的逻辑模型有3 种，它们是（ ）。A.字段名、字段类型和记录116DBMS支持下的数据模型事物本身B.层次、关系和网状C.环状、层次和关系D.网状、关系和语义1.【答案】B。解析：常见的数据模型有3 
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 种，即按图论理论建立的层次结构模型和网状结构模型以及按关系理论建立的关系结构模型。知识点 23、概念模型概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有利工具，也是数据库设计人员和用户之间进行交流的语言。（ 一）常用术语1.实体117客观存在并且可以区分的具体事物或者抽象概念。例如，一个学生、一个宿舍、一个操作流程等等。2.属性属性是对客观事物特征的一种反映，是实体具有的某个特征。例如，学生实体中有学号属性、姓名属性、性别属性，年龄属性、所在系属性等。属性有属性名称和属性值之分，例如，姓名为属性名，则“李白”就是这个属性的值。3.码在现实生活中，实体是可以互相区分的，所以没有两个完全相同的实体，即不能够有两个实体在各自对应属性上的属性值都是相同的。4.域一个属性的取值范围被称为域。例如，性别属性的属性值只能为“男”或者只能为“女”。5.实体型118实体集的名称及其所有属性名的集合称为实体型。例如，学生（学号，姓名，性别，年龄，所在系）就是学生实体集的实体型。6.实体集所有属性名完全相同的实体集合在一起，称为实体集。比如说学生实体集，教师实体集等。（ 二）概念模型
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的表示方法：实体-联系图E-R 图中文称为实体-联系图，它是概念模型中的一种表示形式。E-R 图主要包含三个概念，分别是：实体集、联系集和属性。1.实体-联系图的表示方法实体型：用矩形表示，矩形框内写明实体名。属性：用椭圆表示，并用无向边将其对应的实体型连接起来。联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或者M：N）。1192.联系两个实体集之间的联系可归纳为以下三类：（1）一对一联系（1:1）如果对于实体集A 中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A 与实体集B 具有一对一关系，记为 1：1。例如，一个学校只能有一个校长；一个账号只能提供给一个人使用等。（2）一对多联系（1：N）和多对一联系（N：1）如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集B 中的每一个实体，实体集A 中至多只有一个实体与之联系，则称实体集A 与实体集B 有一对多的联系，记为 1：n。例如，一个工厂可以有若干个员工，而一个员工只能属于一个工厂；一个导师可以有若干个学
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 员，而一个学员只能属于一个导师等。（3）多对多联系（M：N）120如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集 B 中的每一个实体，实体集A 中也有M 个实体（M>=0）与之联系，则称实体集A 与实体集B具有多对多的联系，记为M：N。例如，一门课程可以被多个学生选择，一个学生可以选择多门课程等。【习题演练】1.下列实体类型的联系中，属于一对一联系的是（ ）。A.教研室对教师的所属联系B.父亲对孩子的联系C.省对省会的所属联系D.供应商与工程项目的供货联系1.【答案】C。解析：实体之间的联系分为：一对一、一对多和多对多。因为每一个省都只有一个省会，而一个省会只属于一个省，所以省和省会之121间是一对一的联系。而A 选项属于一对多的关系；B 选项属于一对多的关系；D 选项属于多对多的关系。2.在E-R 图中，用长方形表示（ ），用椭圆表示（ ）。A.联系、属性B.属性、实体C.实体、属性D.什么也不代表、实体2.【答案】C。解析：矩形表示实体，椭圆表示属性。3.关系模型中，候选码（ ）。A.可由多个任意属性组成B.至多由一个属性组成C.可由一个或多个其值能惟一标识
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 该关系模式中任何元组的属性组成D.以上都不是1223.【答案】C。解析：候选码可以是一个也可以是多个，但是必须能唯一标识元组。知识点 24、关系模型（ 一）简介关系数据模型是目前最重要的一种数据模型。关系数据库系统采用关系数据模型作为数据的组织方式。有层次数据模型和网状模型相比，关系模型概念简单、清晰，并且具有严格的数据基础，形成了关系数据理论，操作也直观、容易，因此易学易用。支持关系数据模型的DBMS 称为关系型数据库管理系统RDBMS。与其他数据模型相同，关系数据模型也是由数据结构、数据操作和完整性约束三个部分组成。123（ 二）关系模型的性质列是同质的，即同一列的分量值应该出自相同的域。列名是唯一的，即在同一个关系中不能出现完全相同的两个属性名称。行的顺序无关，即元组与元组之间互换位置，不相互影响。列的顺序无关，即列于列之间互换位置，不相互影响。任何两行不能完全相同，即不能出现两个完全相同的元组。分量必须是原子量，即是不可分的基本数据项。【习题演练】1.下列叙述正确的为（ ）。A.关系中元组没有先后顺序，属性有先后顺序B.关系中元组有先后顺序，属性没有先后顺序124C.关系中元组没有先后顺序，属性也没有
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 先后顺序D.关系中元组有先后顺序，属性也有先后顺序1.【答案】C。解析：关系中元组的顺序无关，属性的顺序也无关。知识点 25、关系操作和完整性约束（一 ）基本的关系操作1.查询操作关系的查询表达能力很强，是关系操作最主要的部分。查询操作又可以分为：选择、投影、连接、除、并、差、交、笛卡尔积等。2.更新操作更新操作又可以分为：插入、删除、修改。3.基本操作125关系的基本操作有五种，分别是：选择、投影、并、差、笛卡尔积。其他操作是可以用基本操作来定义和导出的。就像乘法可以用加法定义和导出一样。4.关系操作的特点关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应地，非关系数据模型的数据操作方式则为一次一记录的方式。（ 二）关系的三类完整性关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。1.实体完整性126（1）规则若属性（指一个或者一组属性）A 是基本关系R 的
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 主属性，则A 不能取空值。按照实体完整性规则的规定基本关系的主码都不能取空值。如果主码由若干属性组成，则所有这些主属性都不能取空值。（2）具体说明①实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。②现实世界中的实体是可以区分的，即它们具有某种唯一性标识。③相应地，关系模型中以主码作为唯一标识。④主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与②点相矛盾，因此这个规则称为实体完整性。2.参照完整性127若属性（或属性组）F 是基本关系R 的外码，它与基本关系S 的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R 中每个元组在F上的值必须为：①或者取空值（F 的每个属性值均为空值）；②或者等于 S 中某个元组的主码值。3.用户自定义完整性任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件。它反映某一具体应用所涉及的数据必须满足的语义要求。例如某个属性必须取值唯一
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、某个非主属性也不能取空值等。【习题演练】1281.若属性A是关系R 的主属性，则A不能为空，该规则称为（ ）。A.实体完整性规则B.属性完整性规则C.参照完整性规则D.用户定义完整性规则1.【答案】A。解析：数据完整性包括：实体完整性、参照完整型和用户定义完整性。实体完整性即规定主键不能为空。2.关系模型有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。定义外键实现的是（ ）完整性。A.实体完整性B.参照完整性C.用户定义的完整性D.实体完整性、参照完整性和用户定义的完整性1292.【答案】B。解析：定义外键实现的是参照完整性。知识点 26、SQL 常用语句SQL（Structured Query Language），即结构化查询语言，是关系数据库的标准语言。当前，几乎所有的关系数据库管理系统软件都支持 SQL，许多软件厂商对 SQL 的基本命令集还进行了不同程度的扩充和修改。SQL 集数据查询、数据操纵、数据定义和数据控制功能于一体，是一个综合的、通用的、功能极强、简洁易学的语言。（ 一）数据查询1.语句格式SELECT [ALL|DISTINCT] column_listFROM table_
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: list130[WHERE search_condition][GROUP BY group_by_list][HAVING search_condition][ORDER BY order_list[ASC|DESC]]2.运算符算术比较运算符：=，<，<=，>，>=，<>，!>，!<逻辑运算符：AND、OR、NOT所属集合运算符：IN、NOT IN谓词：EXISTS（存在)、BETWEEN…AND（范围）、LIKE（匹配）、IS NULL（空值）3.统计函数常见的统计函数统计函数 描述COUNT（*） 计算记录的个数COUNT（[DISTINCT]列名） 对一列中的值计算个数SUM（[DISTINCT]列名） 求某一数值型列的总和AVG（[DISTINCT]列名） 求某一数值型列的平均值131统计函数 描述MAX（[DISTINCT]列名） 求某一列的最大值MIN（[DISTINCT]列名） 求某一列的最小值4.连接查询在查询的数据涉及到多个表时，必须用连接条件将这些表连接起来。5.嵌套查询在 SQL 语句中，可以将一个查询嵌入在另一个查询的WHERE 子句中，这类查询称为嵌套查询。一般内层的查询称为子查
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 询，将外层的查询称为父查询。嵌套的 SELECT 查询使得 SQL 可以实现各种复杂的查询，子查询必须用括号括起来。6.示例a.查询计算机系年龄在20 岁以下的学生姓名：SELECT SnameFROM StudentWHERE Sdept=’CS’ AND Sage<20；b.查询选修了3 门以上课程的学生学号：132SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*)>3;（ 二）数据更新1.INSERT 语句（1）语句格式INSERT INTO<表名>[（<属性名清单>）]VALUES（<常量清单>）;（2）实例：在Employee表中插入一职工记录。INSERT INTO EmployeeVALUES（’2032’，’张杉’，’男’，28，’工程师’，’01 ’）;2.UPDATE 语句（1）语句格式UPDATE<表名>133SET <列名>=<表达式>[,<列名>=<表达式>][WHERE<条件>];（2）实例：在工资表中，将所有职工的基本工资都增加500。UPDATE SalarySET Basepay=Basepay+500;3.DELETE 语句（1）语句格
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 式DELETE FROM <表名>[WHERE<条件>]（2）实例：从职工表中删除Eno（职工号）为1003 的记录。DELETE FROM EmployeeWHERE Eno=’1003’;【习题演练】1341.SQL 语言的标准库函数 COUNT 、SUM 、AVG、MAX 和MIN 等，不允许出现在下列哪个子句中（ ）。A.SELECTB.HAVINGC.WHERED.GROUP，HAVING1.【答案】C。解析：SQL 语言的标准库函数COUNT、SUM、AVG、MAX 和MIN 等，不允许出现在WHERE 子句中。2.在SQL 语句中，与X BETWEEN 20 AND 30等价的表达式是（ ）。A.X>=20 AND X<30B.X>=20 AND X<=30C.X>20 AND X<=30D.X>20 AND X<302.【答案】B。解析：BETWEEN A AND B 是指在 A-B 之间的范围，且包括A 和B 。故与X135BETWEEN 20 AND 30 等价的表达式是 X>=20AND X<=30。3.一个查询的结果成为另一个查询的条件，这种查询被称为（ ）。A.内查询B.连接查询C.
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 自查询D.子查询3.【答案】D。解析：一个查询的结果成为另一个查询的条件，这种查询被称为子查询，也叫嵌套查询。4.在考试表中，要将58 分、59 分的分数调整到60 分，下列SQL 语句中能实现的是（ ）。A.UPDATE 考试表 SET 分数 = 60 HAVING分数>=58 AND 分数<60B.UPDATE 考试表 SET 分数 = 60 WHERE分数>=58 AND 分数<60136C.UPDATE 考试表 SET 分数 = 60 WHERE分数 IN(58,59)D.UPDATE 考试表 SET 分数 = 60 WHERE分数 BETWEEN 58 AND 594.【答案】C。解析：由题知至包含58 分和59分，符合题意的只有C 选项。知识点 27、计算机网络分类（一）按作用范围1.局域网（LAN）局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，137http://baike.baidu.com/view/
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 7886.htmhttp://baike.baidu.com/view/4321959.htmhttp://baike.baidu.com/view/281640.htm可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。2.城域网（MAN）城域网（Metropolitan Area Network）是在一个城市范围内所建立的计算机通信网，简称MAN。属于宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在 100 兆比特/秒以上。3.广域网（WAN）广域网（WAN，Wide Area Network）也称远程网（Long Haul Network）。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。（ 二）按拓扑结构1.星型拓扑结构138星型拓扑结构是一种以中央结点为中心，把若干外围结点连接起来的辐射式互联结构，各结点与中央结点通过点与点方式连接，中央结点执行集中式通信控制策略，因此中央结点相当复杂，负担也重。2.树型拓扑结构树型拓扑结构是一种层次结构，
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结点按层次连接，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。3.总线型拓扑结构总线型拓扑结构是采用单根传输作为共用的传输介质，将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上。使用总线型拓扑结构需解决的是确保用户使用媒体发送数据时不能冲突。在点到点的链路配置时，如果链路是半双工操作，只需使用简单的机制便可保证两个用户轮流工作。在一点到多点方式中，对线路的访问依靠控制139http://baike.baidu.com/view/47398.htmhttp://baike.baidu.com/view/420833.htm端的探询来确定。采取分布式访问控制策略来协调网络上计算机数据的发送。4.环型拓扑结构环型拓扑结构是使用公共电缆组成一个封闭的环，各结点直接连到环上，信息沿着环按一定方向从一个结点传送到另一个结点。环接口一般由发送器、接收器、控制器、线控制器和线接收器组成。5.网状拓扑结构网状拓扑结构，这种拓扑结构主要指各结点通过传输线相互连接起来，并且每一个结点至少与其他两个结点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护
2025-08-10 14:53:29.202 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，不常用于局域网。（ 三）按使用范围1.公用网一般是国家的邮电部门建造的网络。“公用”的意思就是从所有愿意按邮电部门规定交纳费用的140人都可以使用。因此，公用网也可以称为公众网，例如CHINANET、CERNET 等。2.专用网“专用网”是某个部门为本单位的特殊工作的需要而建立的网络。专用网指专用于一些保密性要求较高的部门的网络，比如企业内部专用网、军队专用网，尤其是涉及国家机密的部门。这种网络不向本单位以外的人提供服务。例如，军队、铁路、电力等系统均有本系统的专用网。【习题演练】1.局域网常用的基本拓扑结构有（ ）、环型和星型。A.层次型B.总线型C.交换型D.分组型1411.【答案】B。解析：局域网常用的拓扑结构有星型、环型、树型、总线型。网状型通常应用于广域网。知识点 28、网络地址（ 一）物理地址网卡物理地址存储器中存储单元对应实际地址称物理地址。MAC（介质访问控制）地址是识别LAN（局域网）结点的标识。网卡的物理地址通常是由网卡生产厂家烧入网卡的EPROM（一种闪存芯片，通常可以通过程序擦写），它存储的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址。物理地址一般记作 06-2E-1
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4-F9-5A-23，48 比特的不同组合。142（ 二）IP 地址是为网络每台计算机分配的唯一标识，为了使连入网络的众多计算机主机在通信时能够互相识别，网络中的每一台主机都有唯一的32 位地址。IP 地址一般用小数点隔开的十进制数，即点分十进制表示，如202.120.70.23。以点分十进制的形式表示IP 地址时，用小数点将 IP 地址分为四部分，每个部分的范围为0～255。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志该主机（或路由器）。两级的IP 地址可以记为：IP 地址：：= { <网络号>，<主机号>}（ 三）IP 地址分类汇总143IP 地址分类类型 IP 范围 私有IPA 1-126 10.0.0.1-10.255.255.255B 128-191 172.16.0.1- 172.31.255.255C 192-223 192.168.0.1- 192.168.255.255D 224-239E 240-254（ 四）特殊的 IP 地址主机号全为 1 表示本网段的内部广播地址，不能分给计
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 算机使用。主机号全为0 表示本网络的网段，计算机所在网络。127 开头的本地回环地址，主要测试TCP/IP 协议正确性。D 类地址为组播地址。主要是路由协议OSPF等使用。14410.0.0.110.255.255.255172.16.0.1172.31.255.255192.168.0.1192.168.255.255E 类地址用于研究使用。169.254.*.*的地址是当计算机自动获取IP 地址失败后的标识，但不能用于计算机之间的通信。（五）IPv6 地址IPv6 是InternetProtocoLVersion 6 的缩写，是下一代 IP 地址，用于替代现行版本 IP 协议（IPv4）的下一代 IP 协议，目的是为解决 IP 地址紧缺的问题。扩大地址的可用空间，满足计算机网路增长的需求。IPv6 将地址32 位（IPv4）增大到了 128 位二进制，使得地址数量变为原来的2 的96 次方倍，地址数量更多，适应未来网络扩展的需求。【习题演练】1.以下IP地址中，属于A 类地址的是（ ）。A.52.213. 12.23B.210.123.23. 12145C.223.123.213.23D.156.123.
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 32. 121.【答案】A。解析：A 类地址的第一个部分范围是 1～126，符合的只有A 选项。2.IPv4 地址和IPv6 地址的位数分别为（ ）。A.4，6B.8，16C.16，24D.32，1282.【答案】D。解析：IPv4 地址和Ipv6 地址的位数分别为32，128。知识点 29、子网掩码（ 一）概念子网掩码是一种用来指明一个 IP 地址的网络位和主机位，知道了 IP 地址的网络位，就可以确定146计算机 IP 地址所在的网络，知道了主机位就可以确定该 IP 地址所在网络的位置。（ 二）功能子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码是一个32 位地址，一般在书写的时候也是点分十进制表示。在子网掩码中，1 表示网络位，0 表示主机位。（ 三）默认子网掩码A 类网络的子网掩码为255.0.0.0，B 类网络的子网掩码为 255.255.0.0，C 类网络的子网掩码为255.255.255.0。（ 四）求网络号主机号全为0 的地址表示网络号。第一步把IP 地址转化为二进制。147255.0.0.0255.255.0.0255.255.255.0第二步把子网掩码转化为二进制。第三步保留
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 子网掩码中 1 所对应的部分，主机位用0 填充。第四步转为点分十进制。（五） 求主机号第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 0 所对应的部分。（六） 求广播号主机号全为 1 的地址表示广播号。第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 1 所对应的部分，主机位用 1 填充。第四步转为点分十进制。148（七） 子网划分计算形成子网的数量计算：从主机位借位当网络位来使用。借位数 子网个数 借位数 子网个数1 21 = 2 4 24 =162 22 = 4 5 25 =323 23 =8 6 26 = 64【习题演练】1.以下关于子网掩码的作用，错误的是（ ）。A.标识 IP 地址的网络部分和主机部分B.主机部分对应的子网掩码部分全为“0”C.网络部分对应的子网掩码部分全为“1”D.通过子网掩码标识网络的类型1491.【答案】D。解析：子网掩码是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位。其中主机部分对应的子网掩码部分全为0，网络部分全为 1。2.一个子网掩码是 255.255.240.0
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，这个子网能拥有的最大主机数是（ ）。A.240B.255C.4094D.655342.【答案】C。解析：255.255.240.0，将子网掩码中的240 转换为二进制，240=11110000，所以进行子网划分的时候借走了4 位主机位充当网络位，能够形成 2^4= 16 个子网，每个子网中的 IP 数量2^ 12=4096 ，但是能够分配给计算机使用的只有4096-2=4094。150255.255.240.0知识点 30、网络设备（一）局域网设备1.中继器中继器（Repeater）是局域网互连的最简单设备，工作在OSI 体系结构的物理层，它接收并识别网络信号，然后再生信号并将其发送到网络的其他分支上。信号在传输线路上传输的时候，受到距离、噪音、电阻等影响，使得信号传输的距离不能是长到无限远，在传输一定距离后，信号需要加强。如果在线路中间插入放大器，则伴随信号的放大，噪音也被放大了。中继器的功能是对接收信号进行再生和发送。2.集线器集线器属于物理层设备。集线器是有多个端口的中继器，简称HUB。151集线器在创建网络时，一般是以星型或树型拓扑结构为主。集线器没有MAC地址表，采用广播方式发送，当网络中的主机数
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 量过多的时候，就会在网络生成广播风暴。以集线器为主要网络设备的网络被称为共享式以太网。3.网卡网络接口卡NIC（Network Interface Card）又称网卡或网络适配器。网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。4.网桥在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据MAC 帧的目的地址对收到的帧进行转发。152网桥不隔绝广播风暴。5.交换机以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。（ 二）广域网设备1.网关网关（Gateway）又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。2.路由器153路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，以最佳路径，按前后顺序发送信号。3.调制解调器调制解调器（modem）是一种计算机硬件，它能把计算机的数字信号翻译成可沿普通电话线传送的模拟信号，是家用电话拨号上网的必不可上少的设备。调制：将数字信号转化为模拟信号。解调：将模拟信号转化为数字信号。【习题演练】1.集线器是工作在（ ）的设备。A.物理层B.链路层C.网络层D.运输层1541.【答案】A。解析：中继器和集线器就是物理层的设备。2.在下列网间连接器中，（ ）在数据链路层实现网络互连。A.中继器B.网桥C.路由器D.网关2.【答案】B。解析：网桥是数据链路层的设备，中继器是物理层设备，路由器是网络层设备，网关在传输层及其以上实现网络互联。155知识点 31、信息加密技术（ 一）信息加密信息加密是指使有用的信息变为看上去似为无用的乱码，使攻击者无法读懂信息的内容从而保护信息。任何一个加密系统至少由下面四个部分组成：1.未加密的信息，也称明文。2.加密后的信息，也称密文。3.加密解密设备或算法。4.加密解密的密钥。发送方用加密密钥，通过加密设备或算法，将信息加密后发送出去。接收方在收到密文后，用解密密钥将密文解密，恢复为明文。如果传输中有人窃取，他只能
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 得到无法理解的密文，从而对信息起到保密作用。156其中，密钥是唯一能够控制明文与密文之间变换的关键，通常是一随机字符串，在计算机上实现的数据加密算法，其加密或解密变换是由一个密钥来控制的。（ 二）对称加密1.概念对称密码体制是指如果一个加密系统的加密密钥和解密密钥相同，或者虽然不相同，但是由其中的任意一个可以很容易地推导出另一个，即密钥是双方共享的，则该系统所采用的就是对称密码体制。2.加密过程3.对称加密算法特点157对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。常见的对称加密算法：DES 算法，3DES 算法，TDEA 算法，Blowfish 算法，RC5 算法， IDEA 算法。（ 三）非对称密钥加密1.概念公钥密码体制指一个加密系统的加密密钥和解密密钥是不一样的，或者说不能由一个推导出另一158个。其中一个称为公
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 钥用于加密，是公开的，另一个称为私钥用于解密，是保密的。公钥密码体制解决了密钥的管理和发布问题，每个用户都可以把自己的公开密钥进行公开，如发布到一个公钥数据库中。2.工作原理A要给B发送信息时，A用B 的公钥加密信息，因为A 知道B 的公钥。A 将这个消息发给B。B 收到这个消息后，B 用自己的私钥解密A 的消息。其他所有收到这个报文的人都无法解密，因为只有B 才有B 的私钥。3.RSA 算法159RSA 是Rivest、Shamire 和Adleman 于 1978 年在美国麻省理工学院研制出来的，它是一种比较典型的公开密钥加密算法。【习题演练】1.在数据加密技术中，将待加密的报文称为( )。A.密文B.正文C.短文D.明文1.【答案】D。解析：待加密的报文称为明文。2.在公钥密码体制中，公开的是（ ）。A.公钥和私钥B.公钥和算法C.明文和密文D.加密密钥和解密密钥1602.【答案】B。解析：公钥加密算法是计算机网络中经常使用的算法，能跟好的保证网络安全。其中有两个秘钥，公钥和算法是公开的，可以在服务器上查找到，这样方便用于加密。私钥是用户自己保存的一种密钥。3. 以下关于对称与非对称加密算法叙述中正确的
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 是（ ）。A.对称加密比非对称加密的安全性好B.对称加密比非对称加密的解密速度慢C.非对称加密算法中公钥是公开的，算法是保密的D.非对称加密与对称加密相比，用户需要保管的密钥数量少3.【答案】D。解析：非对称加密使用了一对密钥，即公钥与私钥，公钥是公开的，私钥个人持有，不公开，故D 选择正确。161知识点 32、计算机病毒（ 一）计算机病毒的概念广义上，能够引起计算机故障、破坏计算机数据的程序都可称为计算机病毒；狭义上，计算机病毒是指编制者在计算机程序中插入的破坏计算机或者毁坏数据，影响计算机的使用，并能自我复制的一组计算机指令或者程序代码。（ 二）计算机病毒的特性目前，计算机病毒有数十万种，各有其不同的特征，但总的说来，计算机病毒又有明显的共性。计算机病毒主要有以下几种特征：1.传染性传染性是计算机病毒的基本特征。计算机病毒能通过自我复制来感染正常的文件，达到破坏计算162机系统正常运行的目的。但传染性是有条件的，只有病毒程序被执行之后才具有传染性，才能感染其他文件。2.破坏性任何计算机病毒只要侵入计算机系统，都会对系统及应用程序产生不同程度的影响和破坏，轻则降低计算机的工作效率，占用系统资源，重则破坏数据
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，删除文件，甚至导致系统崩溃，给用户造成不可挽回的损失。3.寄生性虽然计算机病毒是一种程序，但这种程序通常不是以独立文件的形式存在的，它寄生在合法的程序之中。这些合法的程序可以是系统引导程序、可执行程序、一般应用程序等。现在的某些病毒本身就是一个完整的程序，如广义病毒中的网络蠕虫。4.欺骗性黑客常常会把带有病毒程序的名字起成一些用户比较关心的程序名字。1635.隐蔽性和潜伏性计算机病毒要有效的传染和传播，就应该尽量在用户能够觉察的范围之外进行。6.衍生性既然计算机病毒是一段特殊的程序，了解病毒程序的人就可以根据其个人意图随意改动，从而衍生出另一种不同于原版病毒的新病毒。7.可触发性编制计算机病毒的人，一般都为病毒程序设定了一些触发条件，例如系统时钟的某个时间或日期、系统运行了某些程序等。一旦条件满足，计算机病毒就会“发作”，使系统遭到破坏。（ 三）计算机病毒的传播方式计算机病毒的传播方式主要有：（1）移动存储设备传播；（2）计算机网络传播；（3）电子邮件传播。164【习题演练】1.计算机病毒是可以造成计算机故障的（ ）。A.一种微生物B.一种特殊的程序C.一块特殊芯片D.一个程序逻辑错误1.【答案】B。解析：
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 计算机病毒指人为编制的一段具有破坏性的，能够自我复制的程序或者代码。2.计算机病毒具有破坏性、（ ）、潜伏性和传染性等特点。A.必然性B.再生性C.隐蔽性D.易读性2.【答案】C。解析：计算机病毒具有寄生性、传染性、潜伏性、隐蔽性。1653.根据统计，当前计算机病毒扩散最快的途径是（ ）。A.软件复制B.网络传播C.磁盘拷贝D.运行游戏软件3.【答案】B。解析：计算机病毒扩散最快的是网络传播，需要提前安装使用杀毒软件来做好防范。166目录知识点 1 、进制转换知识点 2 、常见数据编码知识点 3 、机器数知识点 4 、补码溢出知识点 5 、寻址方式知识点 6 、存储芯片容量的计算知识点 7 、DRAM 的刷新知识点 8、存储器与 CPU 的扩展连接知识点 9 、死锁知识点 10 、处理机调度的层次知识点 11 、调度算法知识点 12 、内存的连续分配知识点 13 、基本的分页存储管理知识点 14 、基本的分段存储管理知识点 15 、虚拟存储器知识点 16 、页面置换算法知识点 17 、线性表知识点 18 、栈和队列知识点 19 、树知识点 20 、二叉树知识点 21 、图知识点 22 、数据模型知识点 23 
2025-08-10 14:53:29.203 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、概念模型知识点 24 、关系模型知识点 25 、关系操作和完整性约束知识点 26 、SQL 常用语句知识点 27 、计算机网络分类知识点 28 、网络地址知识点 29 、子网掩码知识点 30 、网络设备知识点 31 、信息加密技术知识点 32 、计算机病毒
2025-08-10 14:53:29.401 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:29.401 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:29.401 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.yizhaoqi.smartpai.service.VectorizationService - 开始向量化文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:29.407 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 87
2025-08-10 14:53:29.408 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:29.474 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:29.710 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] [2f214867-1] Response 400 BAD_REQUEST
2025-08-10 14:53:29.712 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] [2f214867-1] Read 312 bytes
2025-08-10 14:53:30.722 [parallel-1] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:30.722 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:30.863 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] [2f214867-2] Response 400 BAD_REQUEST
2025-08-10 14:53:30.864 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] [2f214867-2] Read 312 bytes
2025-08-10 14:53:31.871 [parallel-2] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:31.871 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:32.180 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] [2f214867-3] Response 400 BAD_REQUEST
2025-08-10 14:53:32.180 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] [2f214867-3] Read 312 bytes
2025-08-10 14:53:33.191 [parallel-3] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:33.191 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:33.485 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] [2f214867-4] Response 400 BAD_REQUEST
2025-08-10 14:53:33.485 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [80d6a0d] [2f214867-4] Read 312 bytes
2025-08-10 14:53:33.486 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [80d6a0d] Cancel signal (to close connection)
2025-08-10 14:53:33.486 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR com.yizhaoqi.smartpai.client.EmbeddingClient - 调用向量化 API 失败: Retries exhausted: 3/3
reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:840)
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:33.488 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.yizhaoqi.smartpai.service.VectorizationService - 向量化失败，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:33.489 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.y.smartpai.consumer.FileProcessingConsumer - Error processing task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:36.526 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR o.s.kafka.listener.KafkaMessageListenerContainer - Error handler threw an exception
org.springframework.kafka.KafkaException: Seek to current after exception
	at org.springframework.kafka.listener.SeekUtils.seekOrRecover(SeekUtils.java:227)
	at org.springframework.kafka.listener.DefaultErrorHandler.handleRemaining(DefaultErrorHandler.java:168)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeErrorHandler(KafkaMessageListenerContainer.java:2836)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2713)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: org.springframework.kafka.listener.ListenerExecutionFailedException: Listener method 'public void com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(com.yizhaoqi.smartpai.model.FileProcessingTask)' threw exception
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.decorateException(KafkaMessageListenerContainer.java:2869)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2814)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	... 10 common frames omitted
	Suppressed: org.springframework.kafka.listener.ListenerExecutionFailedException: Restored Stack Trace
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:435)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
Caused by: java.lang.RuntimeException: Error processing task
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:67)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	... 12 common frames omitted
Caused by: java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	... 25 common frames omitted
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:36.530 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Received task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
2025-08-10 14:53:36.530 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件权限信息: userId=1, orgTag=PRIVATE_sy, isPublic=false
2025-08-10 14:53:36.530 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Downloading file from storage: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:36.530 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Detected remote URL: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:36.536 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Successfully connected to URL, starting download...
2025-08-10 14:53:36.536 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 开始解析文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:36.669 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] WARN  org.apache.pdfbox.pdmodel.font.PDCIDFontType2 - Found CFF/OTF but expected embedded TTF font THDZFH+AppleSDGothicNeo-Regular
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文件元数据:
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:unmappedUnicodeCharsPerPage: 0
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:PDFVersion: 1.7
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmp:CreatorTool: WPS 文字
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXFA: false
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:modify_annotations: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print_degraded: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By-Full-Set: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:creator: Sky123.Org
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:num3DAnnotations: 0
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:format: application/pdf; version=1.7
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator_tool: WPS 文字
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:overallPercentageUnmappedUnicodeChars: 0.0
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:fill_in_form: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasCollection: false
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:encrypted: false
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsNonEmbeddedFont: false
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:custom:SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasMarkedContent: false
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - Content-Type: application/pdf
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator: Sky123.Org
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:totalUnmappedUnicodeChars: 0
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_for_accessibility: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:assemble_document: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmpTPg:NPages: 166
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXMP: false
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:charsPerPage: 15
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_content: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:trapped: False
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationTypes: null
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_modify: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationSubtypes: Link
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsDamagedFont: true
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 提取的文本内容长度: 44161
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换............................................................ 6知识点 2、常见数据编码....................................................8知识点 3、机器数.............................................................. 14知识点 4、补码溢出..........................................................19知识点 5、寻址方式..........................................................22知识点 6、存储芯片容量的计算..................................... 39知识点 7、DRAM 的刷新................................................ 40知识点 8、存储
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与 CPU 的扩展连接...........................43知识点 9、死锁.................................................................. 48知识点 10、处理机调度的层次....................................... 553知识点 11、调度算法........................................................57知识点 12、内存的连续分配........................................... 63知识点 13、基本的分页存储管理................................... 70知识点 14、基本的分段存储管理................................... 76知识点 15、虚拟存储器....................................................83知识点 16、页面置换算法....................
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ........................... 90知识点 17、线性表............................................................ 95知识点 18、栈和队列........................................................98知识点 19、树.................................................................. 102知识点 20、二叉树.......................................................... 105知识点 21、图.................................................................. 1104知识点 22、数据模型......................................................117知识点 23、概念模型................................
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ......................119知识点 24、关系模型......................................................125知识点 25、关系操作和完整性约束.............................127知识点 26、SQL 常用语句............................................ 132知识点 27、计算机网络分类......................................... 139知识点 28、网络地址......................................................144知识点 29、子网掩码......................................................148知识点 30、网络设备......................................................153知识点 31、信息加密技术...............................
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: .............. 158知识点 32、计算机病毒..................................................1645知识点 1、进制转换常用数制数制 数码 运算规则 尾符十进制 0—9 逢十进一 D或10二进制 0—1 逢二进一 B或2八进制 0—7 逢八进一 O或8十六进制 0—9，A—F 逢十六进一 H或16（ 一 ）非十进制数转换成十进制数方法每位上的数码×基的位次方，然后求和。（ 二 ）十进制数转换成非十进制数方法整数部分：除N 取余数，直至商为0，余数倒输出。小数部分：乘N 取整数，直至积为0（或满足精度），整数正输出。6（N 为进制数，N 可取2、8、16。）（ 三 ）二/八/十六进制数的互相转换方法由于一位八/十六进制数相当于三/四位二进制数，因此，要将八/十六进制数转换成二进制数时，只需以小数点为界，向左或向右每一位八/十六进制数用相应的三/四位二进制数取代即可。如果不足三/四位，可用零补足。反之，二进制数转换成相应的八/十六进制数，只是上述方法的逆过程，即以小数点为界，向左或向右，每三/四位二进制数用相应的一位八/十六进制数取代即可。【习题
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 演练】1.二进制数 1101.01 转换成十进制数是（ ）。A.17.256B.13.5C.13.25D.17.571.【答案】C。解析：（1101.01）2= 1 x23+1 x22+1+1 x 2—2 = 13.25。2.下列数中最大的数是（ ）。A.227OB.1FFHC. 10100001BD.1789D2.【答案】D。解析：将所有数都统一转换为十进制进行比较，227O=151D ， 1FFH=511D ，10100001B= 161D，对比可知应选D 选项。知识点 2、常见数据编码（ 一）ASCII码美国信息交换标准代码（American StrandardCode for Information Interchage，ASCII）是一种西8文机内码，是计算机中使用最广泛的字符编码，已经作为国际通用的信息交换标准代码。ASCII 码包括 0～9 十个数字，大小写英文字母和专用符号等95 种可打印字符，以及33 种控制字符（如回车、换行等），通常采用一个字节编码，由7 位二进制编码组成，字节的最高位一般规定为0，或用作校验码，可表示 128 个不同的字符。（ 二）汉字的编码1.国标码《信息交换用汉字编
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 码字符集·基本集》是我国于 1980 年制定的国家标准GB2312—80，简称国标码，是国家规定的用于汉字信息交换使用的代码的依据。GB2312—80 中规定了信息交换用的6763个汉字和682 个非汉字图形符号（包括外文字母、数字和符号）的代码。国标码用两个字节表示一个汉字，每个字节只使用低7 位，最高位为0。2.汉字机内码9汉字的机内码是供计算机系统内部进行存储、加工处理、传输统一使用的代码，又称为汉字内部码或汉字内码。汉字机内码是将国标码的两个字节的最高位分别置为 1 而得到的。其最大优点是机内码表示简单，同时也解决了中西文机内码存在的二义性的问题。3.汉字输入码汉字输入码是为了将汉字通过键盘输入计算机而设计的代码。汉字输入编码方案很多，其表示形式大多用字母、数字或符号。输入码的长度也不同，多数为四个字节。综合起来可分为流水码、音码、形码和音形码几大类。4.汉字字形码汉字字形码是汉字字库中存储的汉字字形的数字化信息，用于汉字的显示和打印。目前汉字字形的产生方式大多是数字式，即以点阵方式形成汉字。因此，汉字字形码主要是指汉字字形点阵的代码，10主要有 16×16 点阵、32×32 点阵、256×256 点
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 阵等。如 24×24 的点阵，每字需要72 字节；32×32的点阵，每字需要 128 字节。与每个汉字对应的这一串字节就是汉字的字形码。（ 三）二-十进制编码人们习惯于使用十进制数，而计算机内部多采用二进制数表示和处理数值数据，因此在计算机输入和输出数据时，就要进行由十进制到二进制和从二进制到十进制的转换处理，显然，这项事务性工作如果由人工来完成，势必造成大量时间浪费。因此，必须采用一种编码的方法，由计算机自己来完成这种识别和转换工作。人们通常采用把十进制数的每一位分别写成二进制数形式的编码，称为二-十进制编码或BCD 编码。BCD 编码方法很多，通常采用的是8421 编码。其方法是用四位二进制数表示一位十进制数，自左11至右每一位对应的位权分别是8，4，2，1。值得注意的是，四位二进制数有 0000～1111 十六种状态，这里只取了0000～1001 十种状态，而 1010～1111六种状态在这种编码中没有意义。如十进制数864，其BCD进制编码为 100001100100。8 6 4↓ ↓ ↓1000 0110 0100BCD 码有压缩和非压缩两种。上述的编码方法属于压缩BCD 码，特点是用 1 个字节表
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 示2 位BCD码；非压缩 BCD 码用 1 个字节的低 4 位表示 1 位BCD 码，高4 位为0（无意义）。如 13 的压缩BCD码为 0001 0011 ，非压缩 BCD 码为 0000000100000011。【习题演练】1.已知字符0 的ASCII码为48D，用ASCII 码（7 位）表示字符5 和7 是（ ）。12A.0110010 和0110111B.0100011 和0111011C. 1000101和1100011D.0110101 和01101111.【答案】D。解析：ASCII 码表中字符5 和7的码值分别为 53 和 55 ，转换为二进制表示为0110101 和 0110111。2.某数用压缩BCD 码表示为 10010101，其真值为（ ）。A.135B.95C.95HD. 10010101B2.【答案】B。解析：BCD码是二-十进制编码，1001 和0101 分别对应十进制的9 和5，故选择B选项。3.一个 16×16 点阵的汉字要占用（ ）。A.24 个字节13B.32 个字节C.48 个字节D.256 个字节3.【答案】B。解析：16×16 点阵的汉字要用16×16/8=32 个
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 字节。知识点 3、机器数对于数的符号“＋”和“－”，计算机是无法识别的，需要把符号数码化。通常，约定二进制数的最高位为符号位，“0”表示正号，“1”表示负号。这种在计算机中使用的表示数的形式称为机器数，常见的机器数有原码、反码、补码等。（ 一）原码原码表示法是机器数的一种简单的表示法。其符号位用0 表示正号，用 1 表示负号，数值一般用14二进制形式表示。设有一数用X 表示真值，则原码表示可记作[X]原，例如：X1=＋1010110X2=－1001010其原码记作：[X1]原=[＋1010110]原=01010110[X2]原=[－1001010]原= 11001010在原码表示法中，对 0 有两种表示形式：[＋0]原=00000000[－0]原=10000000（ 二）反码机器数的反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。假设有一数用X表示真值，那么X 的反码表示记作[X]反，例如：X1=＋101011015X2=－1001010那么[X1]原=01010110[X1]反=[X1]原=01010110[X2]
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 原=11001010[X2]反=10110101在反码表示法中，对 0 也有两种表示形式：[＋0]反=00000000[－0]反=11111111反码通常作为求补过程的中间形式，即在一个负数的反码的末位上加 1，就得到该负数的补码。（ 三）补码机器数的补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在末位加 1 而得到的。设有一数用X 表示真值，则X 的补码表示记作[X]补，例如：16X1=＋1010110X2= – 1001010那么[X1]原=01010110[X1]补= [X1]原=01010110[X2]原=11001010[X2]补= 10110101+1=10110110在补码表示法中，0 只有一种表示形式：[＋0]补=00000000[－0]补= 11111111＋1=00000000所以有[＋0]补=[－0]补=00000000。【习题演练】1.采用补码表示的 8 位二进制数真值范围是( )。A.- 127～+127B.- 127～+128C.- 128～+12717D.- 128～+1281.【答案】C。
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 解析：补码表示的8 位二进制数真值范围是- 128～+127 ，原码和反码的范围是- 127～+127。2.补码25H 的真值是（ ）。A.25B.-25C.-37D.372.【答案】D。解析：正数的原码、反码与补码都相同。3.在机器中，（ ）的零的表示形式是唯一的。A.原码B.补码C.反码D.原码和反码3.【答案】B。解析：补码零的表示形式唯一，而原码和反码不唯一。18知识点 4、补码溢出（一 ）补码溢出的产生在补码加减运算中，有时会遇到这样的情况：两个正数相加，而结果的符号位却为 1（结果为负）；两个负数相加，而结果的符号位却为0（结果为正）。发生这种错误的原因在于两数相加之和的数值已超过了机器允许的表示范围。字长为n+1 位的定点整数（其中一位为符号位），采用补码表示，当运算结果大于2n- 1 或小于-2n 时，就产生溢出。设参加运算的两数为X、Y，做加法运算：①若X、Y 异号，不会溢出；②若X、Y 同号，运算结果为正且大于所能表示的最大正数或运算结果为负且小于所能表示的最小负数时，产生溢出。将两正数相加产生的溢出称为正溢；反之，两负数相加产生的溢出称为负溢。19（ 二）补码溢出的检测设被操作数为[X]
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 补=XsX1X2…Xn，操作数为[Y]补=YsY1Y2…Yn，其和（差）为[S]补=SsS1S2…Sn，则判断溢出的方法有以下三种：1.采用一个符号位两正数相加，结果为负表明产生正溢；两负数相加，结果为正表明产生负溢。因此可得出采用一个符号位检测溢出的方法：当Xs=Ys=0，Ss=1 时，产生正溢；当Xs=Ys=1，Ss=0 时，产生负溢。2.采用进位位两数运算时，产生的进位为：CsC1C2…Cn，其中：Cs 为符号位产生的进位，C1 为最高数值位产生的进位。两正数相加，当最高有效位产生进位（C1= 1）而符号位不产生进位（Cs=0）时，发生正溢。20两负数相加，当最高有效位没有进位（C1=0）而符号位产生进位（Cs= 1）时，发生负溢。3.采用变形补码（双符号位补码）在双符号位的情况下，把左边的符号位 Ss1 叫做真符，因为它代表了该数真正的符号，两个符号位都作为数的一部分参加运算。这种编码又称为变形补码。双符号位的含义如下：Ss1Ss2=00，结果为正数，无溢出；Ss1Ss2=01，结果正溢；Ss1Ss2=10，结果负溢；Ss1Ss2= 11，结果为负数，无溢出。【习题演练】1.算式65H-3EH 的运算
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结果是否有溢出，结果的真值为（ ）。A.有、39B.有、27C.无、39D.无、27211.【答案】C。解析：65H-3EH=101D-62D=39D，无溢出。知识点 5、寻址方式存储器既可用来存放操作数，又可用来存放指令。当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。因此，寻址方式可以分为数据寻址和指令寻址。寻找操作数的地址称为数据寻址，数据寻址方式较多，其最终目的都是寻找所需要的操作数。寻找下一条将要执行的指令地址称为指令寻址。（ 一）指令寻址指令寻址比较简单，它又可以细分为顺序寻址和跳跃寻址。顺序寻址可通过程序计数器PC 加 1，22自动形成下一条指令的地址；跳跃寻址是程序转移执行时的指令寻址方式，它通过转移类指令实现。跳跃寻址的转移地址形成方式有三种：直接（绝对）、相对和间接寻址，它与数据寻址方式中的直接、相对和间接寻址是相同的，只不过寻找到的不是操作数的有效地址而是转移的有效地址而已。（ 二）数据寻址数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 真实地址称为有效地址，记作 EA，它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如下所示。操作码OP 寻址特征# 形式地址A寻址方式是根据指令中给出的地址码字段寻找真实操作数地址的方式。23指令中的形式地址A—（寻址方式）→有效地址EA1.立即寻址在取指令时，操作码和操作数被同时取出，不必再次访问存储器，从而提高了指令的执行速度，如下图所示。立即寻址的特点是操作数本身设在指令字内，即形式地址A 不是操作数的地址，而是操作数本身，也称立即数。由于操作数是指令的一部分，故立即数的大小将受到指令长度的限制。立即寻址示意图2.直接寻址指令中地址码字段给出的地址A 就是操作数的有效地址：EA=A，如下图所示。直接寻址的缺点在于A 的位数限制了操作数的寻址范围，且必须修改A 的值，才能修改操作数的地址。24直接寻址示意图3.间接寻址指令中给出的地址A 不是操作数的地址，而是存放操作数地址的地址：EA=（A），如下图所示。间接寻址要比直接寻址灵活得多，它的主要优点为：一是扩大了寻址范围，可用指令的短地址访问大的主存空间，二是可将主存单元作为程序的地址指针，用以指示操作数在主存中的位置。当操作数的地址需要改变时，
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 不必修改指令，只需修改存放有效地址的那个主存单元（间接地址单元）的内容就可以了。25一级间接寻址二级间接寻址26除去一级间接寻址外，还有多级间接寻址。多级间接寻址为取得操作数需要多次访问主存，即使在找到操作数有效地址后，还需再访问一次主存才可得到真正的操作数。4.寄存器寻址指令中地址码部分给出某一通用寄存器的编号，所指定的寄存器中存放着操作数，如下图所示。它有两个明显的优点：一是从寄存器存取数据比主存快得多；二是由于寄存器的数量较少，其地址码字段比主存单元地址字段短得多。寄存器寻址示意图5.寄存器间接寻址27寄存器间接寻址示意图指令中的地址码给出某一通用寄存器的编号，被指定的寄存器中存放操作数的有效地址，而操作数则存放在主存单元中，如上图所示。这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数。6.变址寻址把指令给出的形式地址A 与变址寄存器Rx 的内容相加，形成操作数有效地址：EA ＝ A +（Rx），Rx 的内容为变址值，如下图所示。28变址寻址是一种广泛采用的寻址方式，通常指令中的形式地址作为基准地址，而 Rx 的内容作为修改量。在遇到需要频繁修改地址时，无须修改指令，只要修改变址值就可以了
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。变址寻址示意图如要把一组连续存放在主存单元中的数据（首地址是A）依次传送到另一存储区（首地址为B）中去，则只需在指令中指明两个存储区的首地址A和B（形式地址），用同一变址寄存器提供修改量29K，即可实现（A＋K）→B＋K。变址寄存器的内容在每次传送之后自动地修改。7.基址寻址将基址寄存器Rb 的内容与形式地址A 相加，形成操作数有效地址：EA＝（Rb）＋ A，基址寄存器的内容称为基址值，如下图所示。基址寻址示意图工30基址寻址和变址寻址在形成有效地址时所用的算法是相同的，而且在一些计算机中，这两种寻址方式都是由同样的硬件来实现的。但这两种寻址方式应用的场合不同，变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改。8.相对寻址相对寻址是基址寻址的一种变通，由程序计数器PC 提供基准地址，即：EA＝（PC）＋ A，A 是操作数和现行指令之间的相对位置，如下图所示。3132相对寻址示意图相对寻址方式的特点是：操作数的地址不是固定的，
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 它随着PC 值的变化而变化，并且与指令地址之间总是相差一个固定值A。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC 相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。指令中给出的位移量A 可正、可负，通常用补码表示，故对于指令地址而言，操作数地址可能在指令地址之前或之后。9.隐含寻址隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。如一地址指令格式，只给出一个操作数的地址，另一个操作数隐含在累加器ACC 中，故累加器ACC对一地址指令格式来说是隐含地址，如下图所示。33隐含寻址示意图10.堆栈寻址在堆栈寻址的指令字中没有形式地址码字段，它是一种零地址指令。堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组来实现，也可利用主存的一部分空间作堆栈，前者称为硬堆栈，后者称为软堆栈。【习题演练】1. 对某个寄存器中操作数的寻址方式称为( ) 寻址。A.直接B.间接C.寄存器34D.寄存器间接1.【答案】C。解析：操作数在寄存器中的寻址方式为：“寄存器直接寻址”，也叫“寄存器寻址
2025-08-10 14:53:36.762 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ”。当操作数的有效地址在寄存器中时叫“寄存器间接寻址”。2.操作数所处的位置，可以决定指令的寻址方式。操作数的地址在寄存器中，寻址方式为（ ）。A.相对寻址B.直接寻址C.寄存器寻址D.寄存器间接寻址2.【答案】D。解析：操作数包含在指令中的寻址方式为立即寻址；操作数在寄存器中的寻址方式为寄存器寻址；操作数的地址在寄存器中的寻址方式为寄存器间接寻址。3.变址寻址和基址寻址的有效地址形成方式类似，但（ ）。35A.变址寄存器的内容在程序执行过程巾是不能改变的B.基址寄存器的内容在程序执行过程中是可以改变的C.在程序执行过程中，变址寄存器的内容不能改变而基址寄存器的内容可变D.在程序执行过程中，基址寄存器的内容不能改变而变址寄存器的内容可变3.【答案】D。解析：基址寄存器的内容由操作系统确定，而变址寄存器的内容由用户确定，因此基址寄存器的内容不能改变而变址寄存器的内容可变。知识点 6、存储芯片容量的计算存储芯片的容量与地址线的位数、数据线的位数均有关。地址线和数据线的位数共同反映存储芯片的容量。其公式可写为：36存储芯片容量=2A×D位，其中，A 为地址线根数，D 为数据线根数。如地址线为 10 根，数据线为4根
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，则存储芯片容量为 210×4＝4K 位；又如地址线为 14 根，数据线为 1根，则其容量为214×1＝16K 位。【习题演练】1.某DRAM 芯片，其存储容量为512K×8 位，该芯片的地址线和数据线数目为（ ）。A.8，512B.512，8C.18，8D.19，81.【答案】D。解析：512K X8 = 219 X 8，所以地址线和数据线分别为 19 和8。37知识点 7、DRAM 的刷新动态随机存储器刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。DRAM 是靠电容来存储信息的，由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对DRAM 的全部基本单元电路必作一次刷新，一般取2ms（2000μs），这个时间称为刷新周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本电路的逐行刷新，才能保证DRAM 内的信息不会丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。38（ 一）集中刷新集中刷新是在规定的一个刷新周期内，对全部存
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。如对 128×128 矩阵的存储芯片进行刷新，刷新的时间相当于 128 个读周期。若读/写周期为 0.5μs，则对 128 行集中刷新共需 128×0.5 =64μs，其余的 1936μs（=2000－64）用来读/写或维持信息。由于在这 64μs 时间内不能进行读写操作，故称为“死时间”。（ 二）分散刷新分散刷新把对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期分成两段，前半段用来读/写或维持信息，后半段用来刷新。若读/写周期为 0.5μs，则存取周期为 1μs，那么每隔128μs 就可将 128 行的存储芯片全部刷新一遍，但39这比允许的 2ms 间隔要短得多，且存取周期长了，整个系统的速度降低。（ 三）异步刷新前两种方式的集合，既可缩短“死时间”，又充分利用最大刷新间隔为 2ms 的特点。如可在 2ms内对 128 行各刷新一遍，即每隔 15.6μs（2000/ 128）刷新一行，每行的刷新时间仍为 0.5μs，但对每行来说，刷新间隔仍为2ms，“死时间”缩短为0.5μs。【习题演练】1.动态RAM 的刷新是以（ ）为单位进行的
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。A.存储矩阵B.行C.列D.存储单元1.【答案】B。解析：动态RAM 的刷新以行为单位进行。40知识点 8、存储器与 CPU 的扩展连接（一 ）存储容量的扩展由于单片存储芯片的容量总是有限的，很难满足实际的需要，因此，必须将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有位扩展和字扩展。1.位扩展位扩展是指增加存储字长，只在位数方向扩展（加大字长）。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。位扩展组成容量 地址 数据41存储器 64K×8 16 位 8 位存储芯片 64K×1 16 位 1 位如用 64K×1 的SRAM 芯片组成64K×8 的存储器，需要8 个芯片，如上表所示。当CPU 访问该存储器时，其发出的地址和控制信号同时传给8个芯片，选中每个芯片的同一单元，其单元的内容被同时读至数据总线的相应位，或将数据总线上的内容分别同时写入相应单元。2.字扩展字扩展是指增加存储器字的数量，它仅在字数方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。如用 16K×8 的SRAM 组成64K
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ×8 的存储器，需要4 个芯片，如下表所示。字扩展组成容量 地址 数据42存储器 64K×8 16 位 8 位存储芯片 16K×8 14 位 8 位在同一时间内四个芯片中只能有一个芯片被选中。3.字和位同时扩展字和位同时扩展组成容量 地址 数据存储器 64K×8 16 位 8 位存储芯片 16K×4 14 位 4 位字和位同时扩展是指既增加存储字的数量，又增加存储字长。当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展，这将是前两种扩展的组合，实现起来也较为容易。如用16K×4 的SRAM 组成64K×8 的存储器，需要8 个芯片，如上表所示。43（ 二）存储器与 CPU 的连接存储芯片与CPU 芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。1.地址线的连接存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU 地址线的低位与存储芯片的地址线相连。CPU 地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。2.数据线的连接CPU 的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU 
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的数据线数相等。3.读/写命令线的连接CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。4.片选线的连接44片选线的连接是CPU 与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端---cs是否能接收到来自CPU 的片选有效信号。5.合理选择存储芯片合理选择存储芯片主要是指存储芯片类型（RAM 或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM 则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单方便。【习题演练】1.用存储容量为16K×1 位的存储器芯片来组成一个 64K×8 位的存储器，则在字方向和位方向上分别扩展了（ ）倍。A.4 和2B.8 和4C.2 和445D.4 和81.【答案】D。解析：用64K 除以16K等于4，用8 除以1 等于8。2.RAM 芯片并联时可以使（ ）。A.存储器存储字长增加B.存储器地址范围增加C.存储器速度增加D.降低存储器的平均价格2.【答案】A。解析：并联时可以增加存储器的存储字长。知识点 9、死锁死锁是指多个进程在运行过程中因争夺资源而造成
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。如下图所示，有两个资源R1 和R2 供进程P1和P2 共享，P1 已占用资源R1，P2 已占用资源R2，46此时若 P2 继续要求R1,P1 要求R2，则 P1 和 P2 之间便会形成僵局，它们都在等待对方释放自己所需的资源，但同时又不释放自己已占用的资源，从而进入死锁状态。P1R2P2死锁示例（一 ）死锁产生的原因产生死锁的原因可归结为如下两点：1.竞争资源47R1当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。2.进程间推进顺序非法进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。（ 二）死锁产生的必要条件死锁的发生必须具备下列四个必要条件：1.互斥条件指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。2.请求和保持条件指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此48时请求进程阻塞，但又对自己已获得
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的其它资源保持不放。3.不剥夺条件指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。4.环路等待条件指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的P0 正在等待一个P1 占用的资源；P1 正在等待P2 占用的资源，……，Pn正在等待已被P0 占用的资源。（ 三）死锁的处理为保证系统中各进程的正常运行，应事先采取必要的措施，来预防发生死锁。系统已经出现死锁后，则应及时检测到死锁的发生，并采取适当措施来解除死锁。目前，处理死锁的方法可归结为以下四种：1.预防死锁49这是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。2.避免死锁该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。3.检测死锁这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机制，及时地检测出死锁的发
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 生，并精确地确定与死锁有关的进程和资源；然后，采取适当措施，从系统中将已发生的死锁清除掉。4.解除死锁这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱50出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。【习题演练】1.以下各种情况中，属于死锁现象的是（ ）。A.某进程执行了死循环B.某进程为了得到某资源，等待了很长的时间C.某进程为了得到某资源，等待了无限的时间D.操作系统故障1.【答案】C。解析：死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，它们都将无法再向前推进。由死锁概念可知，只有C 选项符合。2.死锁预防是保证系统不进入死锁状态的静态策略，其解决方法是破坏产生死锁的四个必要条件之一。下列方法中破坏了“循环等待”条件的是( )。51A.银行家算法B.一次性分配策略C.剥夺资源法D.资源有序分配法2.【答案】D。解析：资源有序分配法可以破坏“循环等待”条件。3.产生系统死锁的原因可能是由于（ ）。A.进程释放资源B.一个进程进入死循环C.多个进程竞争资源，出现了循环
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 等待D.多个进程竞争共享型设备3.【答案】C。解析：产生系统死锁的原因可能是多个进程竞争资源，从而出现了循环等待。52知识点 10、处理机调度的层次（ 一）作业调度作业调度又称高级调度，或宏观调度，根据某种算法，把外存上处于后备队列中的作业调入内存。（ 二）中级调度中级调度又称中程调度，将那些暂时不能运行的进程调至外存上去等待，此时的进程状态称为挂起状态。中级调度实际上就是存储器管理中的对换功能。（ 三）进程调度进程调度又称低级调度，或微观调度，它决定就绪队列中的哪个进程应获得处理机。53进程调度的方式有两种：非抢占方式和抢占方式。抢占方式基于的原则有三个：优先权原则、短作业/进程优先原则、时间片原则。【习题演练】1.操作系统中的高级调度是指（ ）。A.线程调度B.作业调度C.进程内、外存交换调D.进程调度1.【答案】B。解析：高级调度又称为作业调度、宏观调度或者长程调度，其主要任务是按照一定的原则从外存上处于后备状态的作业中选择一个或者多个，给它们分配内存、输入输出设备等必要的资源，并建立相应的进程，以使作业具有获得竞争处理器的权利。2.CPU 的调度分为高级、中级和低级三种，其中低级调度是指（ ）调度。5
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4A.作业B.交换C.进程D.线程2.【答案】C。解析：进程调度又称低级调度。知识点 11、调度算法（ 一 ）先来先服务调度算法先来先服务（First Come First Served，FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS 算法比较有利于长作业（进程），而不利于短作业（进程）。（ 二）短作业/进程优先调度算法短作业 / 进程优 先调度算法（ShortestJob/Process First，SJ/PF），是指对短作业或短进程55优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。需要注意的是短进程优先调度算法中，每次选择的是已进入系统的、要求服务时间最短的进程。SJ/PF 调度算法的缺点在于：该算法对长作业不利；完全未考虑作业的紧迫程度，因而不能保证紧迫性作业/进程会被及时处理；由于
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 作业/进程的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。56（ 三 ）高优先权优先调度算法作为作业调度算法，此算法常被用于批处理系统中，作为进程调度算法，还可用于实时系统中。对于最高优先权优先调度算法，其关键在于：它是使用静态优先权，还是用动态优先权，以及如何确定进程的优先权。1.静态优先权静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。确定进程优先权的依据：进程类型、进程对资源的需求和用户需求。2.动态优先权动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。动态优先权的变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间57= 响应时间/要求服务时间= 响应比这种算法即为高响应比优先调度算法（HighestResponse-ratio Next，HRN），它既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折中。但每次要进行调度之前，都须先做响应比的计算，这会增加系统开销。
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: （ 四 ）基于时间片的轮转调度算法1.时间片轮转法其基本思想是为每一个进程分配一个时间段，该时间段被称为时间片，即允许该进程运行的时间。每个进程只能依次循环轮流运行，如果时间片结束时进程还在运行，CPU 将剥夺该进程的使用权转而将CPU 分配给另一个进程。如果进程在时间片结束之前阻塞或结束，CPU 当即进行切换。为了实现进程的循环执行，将每次被中止运行的进程存入就绪58队列的末尾，同时将CPU 分配给就绪队列中的队首进程。该算法是一种简单而又公平的算法，使用非常广泛。2.多级反馈队列调度算法前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。【习题演练】1.为了对紧急进程或重要进程进行调度，调度算法应采用（ ）。A.先进先出调度算法B.优先数法59C.最短作业优先调度D.定时轮转法1.【答案】B。解析：为了对紧急进程或重要进程进行调度，可遵
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 循优先权准则，采用优先数法。2.按照作业到达的先后次序调度作业，排队等待时间最长的作业被优先调度，这是指（ ）调度算法。A.先来先服务B.最短作业优先C.定时轮转法D.优先数法2.【答案】A。解析：先来先服务按作业进入的先后次序安排。优点是实现简单，缺点是不利于运行时间短的作业。3.以下（ ）调度算法对CPU 繁忙型进程有利。A.FCFSB.时间片轮转60C.多级反馈队列D.短进程优先3.【答案】A。解析：CPU 繁忙型进程占用CPU时间比较多，更接近于长进程，故选A，FCFS 算法有利于长进程。知识点 12、内存的连续分配连续分配方式，是指为一个用户程序分配一个连续的内存空间。它又可进一步分为：单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配四种。（ 一）单一连续分配单一连续分配是最简单的一种存储管理方式，只能用于单用户、单任务的操作系统中。它将内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除61系统区以外的全部内存空间，提供给用户使用，其中仅能存放一道作业。（ 二）固定分区分配固定分区分配是最早的多道程序的存储管理方式，是指系统先把内存划分成若干个
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 大小固定的分区，一旦划分好，在系统运行期间便不再重新划分。为了满足不同程序的存储需求，各分区的大小可以不等，也可以相等，但在每个分区中只装入一道作业。采用固定分区分配方法存在以下缺点：（1）由于预先规定了分区的大小，使得大作业无法装入，用户不得不采取其他技术加以补救，增加了用户的负担；（2）内存利用率不高，作业很少能恰好填满分区；（3）固定分区无法实现动态扩充内存空间的要求；62（4）由于分区个数在系统初启时确定，因此会限制多道运行的程序个数，特别不适于分时系统交互型用户及内存变化很大的情形。（ 三）动态分区分配动态分区分配算法根据进程的实际需要，动态地分配内存空间。在实现可变分区分配时，涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作三个问题。常用的分配算法主要有以下几种：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。1.首次适应算法该算法将空闲分区按起始地址递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，直至找到第一个能满足要求的空闲分区为止，并按作业的大小从该分区中分割出一块内存空间分配给请求者，剩余的部分仍留在空闲分区表63或链中。该算法优先使用内存低
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 址部分的空闲分区，从而能在高址部分保留较大的空闲分区，但它会在内存的低端留下很多难以利用的小空闲分区，而每次分配时，对空闲分区的查找都必须经过这些分区，从而会增加查找的开销。2.循环首次适应算法该算法由首次适应算法演变而成，每次分配均从上次分配的位置之后开始查找，并将第一个能满足要求的空闲分区分割并分配出去。其特点是内存中的空闲分区分布得更均匀，从而减少查找空闲分区的开销，但它会使存储器中缺乏大的空闲分区。3.最佳适应算法该算法将空闲分区按大小递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，并将第一个能满足要求的空闲分区分割并分配出去。该算法尽管被称为“最佳”，但情况并非总是如此，因为每次分配后所切割下来的剩余部分总64是最小的，它会在内存中留下大量难以利用的小空闲分区。4.最坏适应算法该算法将空闲分区按大小递减的次序排列。当作业申请一个空闲区时，先检查空闲分区链（表）的第一个空闲区是否大于或等于所要求的内存长度，若该空闲区长度小于要求，则分配失败，否则分配相应的存储空间给用户，然后修改和调整空闲分区链（表）。该算法的优点是产生碎片的几率最小，缺点主要是使内存中缺乏大的空闲区。（四 ）可重定
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 位分区分配在动态分区分配方式中，经过一段时间的分配和回收后，内存中会产生很多小的空闲分区。此时，可能有用户程序因找不到足够大的空闲分区而难以装入，但所有空闲分区容量的总和却足以满足该程序的要求。65上述这些不能被利用的空闲分区可采用以下办法加以解决：将内存中的所有作业进行移动，从而将原来分散的多个空闲分区移到同一处拼接成一个大的空闲分区，以装入用户的作业。这种技术被称为“拼接”或“紧凑”。可重定位分区分配方式就是在动态分区分配方式的基础上增加紧凑功能，即在找不到足够大的空闲分区、而空闲分区总和却能满足用户的要求时，对内存空间进行紧凑。由于紧凑时，作业要在内存中移动位置，因此，它需要得到动态重定位技术的支持，这也是它被称为动态重定位分区分配的原因。【习题演练】1.分区存储管理中的首次适应算法，要求把空闲区按照（ ）的次序登记在空闲区表中。A.大小递减B.大小递增C.地址递减66D.地址递增1.【答案】D。解析：首次适应算法要求对空闲分区按地址从小到大的顺序排列。2.可重定位内存的分区分配目的为（ ）。A.解决碎片问题B.便于多作业共享内存C.回收空白区方便D.便于用户干预2.【答案】A。解析：可重定位内存的分区
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 增加了紧凑的功能，通常在找不到足够大的空闲分区来满足用户需求时使用，解决了碎片问题。3.在以下存储管理方案中，不适用于多道程序设计系统的是（ ）。A.单一连续分配B.固定式分区分配C.可变式分区分配D.页式存储管理673.【答案】A。解析：单一连续分配只能用于单用户、单任务的操作系统。知识点 13、基本的分页存储管理在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。（ 一）页面与页表基本的分页存储管理方式中，系统将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。相应地，将内存空间分成若干个与页面同样大小的块，称为物理块或页框。内存的分配以块为单位，并允许将一个进程的若干页分别装入到多个不相邻的物理块中。68为了地址映射的方便，页面的大小通常设置成2 的幂。如果页面的大小为2k 字节，逻辑地址的长度为 n 位，则分页系统的地址结构如下图所示，可将线性的逻辑地址分成两部分：右边的 k 位为页内位移量（即页内地址）W，左边的n-k 位为页号P。n-1 k k-1 0页号P 位移量W分页地址中的地址结构在进
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 程运行时，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页面映射表，简称页表，进程的每个页占页表的一个表项，其中记录了相应页对应的内存块的块号，以及用于分页保护的存取控制信息。下图给出了分页系统的一个内存分配实例，其中页面大小为4K，用户作业的大小为11K。由于进程的最后一页不足一块，因此造成了存放该页的物69理块中部分空间的浪费，这部分被浪费的空间被称为“页内碎片”。分页系统中的内存分配（ 二）地址变换机构页式存储管理系统中，逻辑地址到物理地址的转换是在进程执行的过程中，由硬件地址变换机构借助于页表自动进行的。1.基本的地址变换机构通常将作业的页表存放在内存中，而在系统中只设置一个页表寄存器PTR（Page-Table Register），当一进程因CPU 调度而转入执行状态时，其页表的70内存始址和长度将从该进程的 PCB 中装入页表寄存器。当进程要访问某个逻辑地址中的指令或数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号大于或等于页表长度，便产生越界中断，否则便以页号为索引去检索页表，从中得到该页的物理块号，送入物理地址寄存
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与页内地址拼接，形成对应的物理地址。2.具有快表的地址变换机构由于页表存放在内存中，故CPU 每存取一个指令或数据时都要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次才根据物理地址存取指令或数据，这使得计算机的处理速度降低近1/2。为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”或“快表”，用以存放当前访问的那些页表项。71在进行地址转换时，地址变换机构自动将逻辑地址中的页号并行地与快表中的所有页号进行比较，若其中有与此相匹配的页号，便可直接从快表中读出该页对应的物理块号，并送到物理地址寄存器中。如果在快表中未找到对应的页号，则仍需访问内存中的页表来进行地址转换，同时还必须将得到的页表项与页号—起装入到快表中，若快表已满，则还需根据置换算法淘汰某个快表项，以装入新的内容。（ 三）多级页表现代的大多数计算机系统都支持非常大的逻辑地址空间，此时，页表就变得非常大，要为它分配一大段连续的内存空间将变得十分困难。对于该问题，可利用将页表进行分页，并离散地将各个页表存放到内存块中的办法加以解决，此时，必须为离散分配的页表再建立一张页表，称为外层
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 页表，用来记录存放各页表页的内存块号，从72而形成了两级页表。在使用两级页表的分页系统中，每次访问一个数据需访问三次内存，故同样需增设快表来有效地提高访问速度。如果外层页表仍十分大，则可以将它再进行分页，并离散地存放到内存中，然后再通过一张第二级的外层页表来记录存放各外层页表页的内存块号，这样，便形成了三级页表，并可进一步形成更多级的页表。【习题演练】1.碎片现象的存在使得（ ）。A.内存空间利用率降低B.内存空间利用率提高C.内存空间利用率得以改善D.内存空间利用率不影响1.【答案】A。解析：碎片会占用计算机的内存，使部分内存空间不能满足程序运行的最低标准，从而不能被使用，降低内存的使用效率。732.基本分页存储管理中，若没有引入快表，则每次从主存取指令或取操作数，要（ ）访问主存。A.1 次B.2 次C.3 次D.4 次2.【答案】B。解析：要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次根据物理地址存取指令或操作数。知识点 14、基本的分段存储管理用户通常喜欢将自己的作业按逻辑关系划分成若干段，然后通过段名和段内地址来访问相应的程序或数据，还希望能以段为单位对程序和数据进行共享和保护，并
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 要求分段能动态增长。分页系统虽然能较好地解决动态分区的碎片问题，却难以满足74用户的上述要求，因此又引入了分段式存储管理方式。在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如主程序段、子程序段、数据段等。每个段都有自己的名字，都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，故各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，即其逻辑地址由段号和段内地址所组成。分段地址中的地址具有如下图的结构：段号 段内地址31 16 15 0分段地址中的地址结构在该地址结构中，允许一个作业最长有64K个段，每个段的最大长度为64KB。75（ 一）段表在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地放入内存不同的分区。系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，但更常多的是放在内存中。在配置了段表后，执行中的进程可通过查找段表找到每个段所对应的内存区。故段表是用于实现从逻辑段到物理内存区的映射。（ 二）地址变换机
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 构为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放正在执行进程的段表始址和长度。在进行地址转换时，地址变换机构将逻辑地址中的段号与段表寄存76器中的段表长度进行比较，若段号不小于段表长度，便产生越界中断；否则便以段号为索引去检索段表，从中得到该段的基址和长度；接着检查段内地址是否超过段长，若超过，则发出越界中断信号；若未超过，则将该段的基址与段内地址相加，从而得到对应的物理地址。（ 三 ）分页和分段的主要区别分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换，这是它们的相同之处，其不同主要表现在以下三个方面：①页是信息的物理单位，分页是为提高内存的利用率；段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。②页的大小固定且由系统决定，在系统中只能有一种大小的页面；而段的长度却不固定，取决于用户所编写的程序，通常由编译程序在编译时，根据信息的性质来划分。77③分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。（ 四）
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 段页式存储管理方式为了既能像分页系统那样有效地利用内存，又能像分段系统那样满足用户多方面的需要，操作系统中又引入了段页式存储管理方式。段页式系统的基本原理，是先将用户程序分成若干个段，再把每个段分成若干个页。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成。在段页式系统中，为获得一条指令或数据须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中78取出该页所在的物理块号，并将该块号与页内地址一起形成物理地址；第三次访问是取指令或数据。【习题演练】1.页是（ ）单位，由（ ）划分，它的长度（ ）。A.逻辑，系统，定长B.逻辑，用户，不定长C.物理，用户，不定长D.物理，系统，定长1.【答案】D。解析：页是物理单位，由系统划分，它的长度固定。2.下列方法中，解决碎片问题最好的存储管理方法是（ ）。A.基本页式存储管理B.基本分段存储管理C.固定大小分区管理D.不同大小分区管理792.【答案】A。解析：离散分配方式将一个作业离散地存放到内存中，从而使系统无须紧凑便能很好地解决碎片问题，而离散分配方式中，分页是为解决碎片问题，提高内存的利用率，分段的目的则是为了
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 能更好地满足用户的需要，故选A。3.分段管理提供（ ）维的地址结构。A.1B.2C.3D.43.【答案】B。解析：分段存储管理的地址空间是二维的，标识一个地址时，既需给出段名，又需给出段内地址。80知识点 15、虚拟存储器（一）局部性原理程序局部性原理是指程序在执行时将呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。局限性还表现在下述两方面：1.时间局限性如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。2.空间局限性一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。81基于局部性原理产生了虚拟存储器。（ 二）虚拟存储器的实现虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。虚拟存储器的实现，建
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 立在离散分配的存储管理方式的基础上。目前，所有的虚拟存储器都是采用下述方式之一实现的：1.请求分页系统在分页系统的基础上，增加了请求调页功能和页面置换功能，便形成页式虚拟存储系统。它允许只装入少数页面的程序及数据，便启动运行。之后再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。822.请求分段系统在分段系统的基础上，增加了请求调段及分段置换功能后，便形成段式虚拟存储系统。它允许只装入少数而非所有段的用户程序和数据，即可启动运行。之后再通过调段功能和段的置换功能将暂不运行的段调出，同时调入即将运行的段。（ 三）虚拟存储器的特征虚拟存储器具有多次性、对换性和虚拟性三大主要特征。1.多次性多次性是指虚拟存储器将一个作业分成多次调入内存。多次性是虚拟存储器最重要的特征，任何其它的存储管理方式都不具有这一特征。2.对换性在作业运行期间，虚拟存储器允许将内存中暂时不能运行的进程或暂时不用的程序或数据，调出到外存上，以便腾出足够的内存空间，再把具备运83行条件的进程或进程所需要的程序和数据调入内存。如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。这种对换被
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。而相应的，如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。它们是实现虚拟存储器的基础。3.虚拟性虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。虚拟性是实现虚拟存储器的最重要的目标。虚拟性是以多次性和对换性为基础的，仅当系统允许将作业分多次调入内存，并能将内存中暂时不运行的程序和数据换至盘上时，才有可能实现虚拟存储器；而多次性和对换性又必须建立在离散分配的基础上。84（ 四 ）请求分页存储管理方式请求分页系统是建立在基本分页存储管理基础上的，增加了请求调页功能和页面置换功能。请求分页便成为目前最常用的一种实现虚拟存储器的方式。为了确定所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：1.预调页策略如果进程的许多页是存放在外存的一个连续区域中，则一次调入若干个相邻的页，会比一次调入一页更高效些。但如果调入的一批页面中的大多数都未被访问，则又是低效的。可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。这种策
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。2.请求调页策略85当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由OS 将其所需页面调入内存。由请求调页策略所确定调入的页，是一定会被访问的，再加之请求调页策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。【习题演练】1.实现虚拟存储器的目的是（ ）。A.实现存储保护B.实现程序浮动C.扩充辅存容量D.扩充主存容量1.【答案】D。解析：实现虚拟存储器的目的是为了扩充主存容量。2.虚拟存储器的最大容量是由（ ）决定的。A.计算机系统的地址结构和外存空间B.页表长度86C.内存空间D.逻辑空间2.【答案】A。解析：虚存容量不是无限的，最大容量受外存可利用的总容量和计算机总线地址结构的限制。3.具有虚拟存储功能的管理方法包括（ ）。A.可变分区存储管理B.分页式存储管理C.请求分段存储管理D.段页式存储管理3.【答案】C。解析：虚拟存储功能涉及内存的存储空间扩充问题。请求分段存储管理：作业可以装入不连续的存储空间中，且作业不要求全部装入内存就可以运行，因此具有空间扩充功能；段页式存储管理：作业虽然可以装入不连续
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的存储空间中，但是作业仍要求全部装入才可运行，因此不具备空间扩充功能。87知识点 16、页面置换算法置换算法的好坏直接影响系统的性能。若采用的置换算法不合适，可能出现这样的现象：刚被换出的页，很快又被访问，为把它调入而换出另一页，之后又访问刚被换出的页……如此频繁地更换页面，以致系统的大部分时间花费在页面的调度和传输上。此时，系统看起来很忙，但实际效率却很低。这种现象称为“抖动”。好的页面置换算法能够适当降低页面更换频率（减少缺页率），尽量避免系统“抖动”。为评价一个算法的优劣，可将该算法应用于一个特定的存储访问序列上，并且计算缺页数量，存储访问序列也叫页面走向。（一）最佳（OPT）置换算法最佳置换算法（Optimal，OPT）是选择不再访问的页面或者是在未来最长时间内不再被访问的页88面予以淘汰。最佳页面置换算法是在理论上提出的一种算法，具有最好的性能，但实现是困难的，因为它需要人们预先知道一个进程在整个运行过程中页面走向的全部情况。不过，这个算法可用来衡量其他算法的优劣。（ 二 ）先进先出（FIFO） 页面置换算法FIFO 算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰，该算法的
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 出发点是最早调入内存中的页面，其不再被使用的可能性会比较高。其实现简单、直观，对按线性顺序访问的程序比较合适，面对其他情况则效率不高，因为经常被访问的页面，往往在内存中因停留得最久而被淘汰。一般而言，对于任一作业或进程，如果给它分配的内存页面数越接近于它所要求的页面数，则发生缺页的次数会越少。在极限情况下，这个推论是成立的，如果给一个进程分配了它所要求的全部页89面，则不会发生缺页现象。但是，使用 FIFO 算法时，在给进程或作业分配满足它所要求的页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为Belady 现象。（ 三）最近最久未使用（LRU） 置换算法LRU 算法是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能以“最近的过去”作为“最近的将来”的近似，选择在最近一段时间里最久没有使用过的页面予以置换。因此，LRU 算法是与每个页面最后使用的时间有关的，当必须置换一个页面时，LRU 算法选择过去一段时间内最久未使用的页面。LRU 置换算法是一种比较好的算法，但需要硬件的支持：移位寄存器或栈。关于确定最后使用时间的问题，对于移位寄存器而言，当进程访
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 问某物理块时，要将相应寄存器的位置成“1”。此时，定时信号将每隔一定时间将90寄存器右移一位。如果把 n 位寄存器的数看做是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。对于栈而言，每当访问一个页面时，便将它的页面号从栈中移出，压入栈顶。因此栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。（ 四）Clock 置换算法LRU 算法是较好的一种算法，但它要求有较多的硬件支持，故在实际应用中大多采用LRU 的近似算法。Clock 算法就是用得较多的一种LRU 近似算法。Clock 置换算法采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的表针，指向可能要淘汰的页面。它在存储分块表的每一表项中增加一个访问位，操作系统定期地将它们置为 0。当某一页被访问时，由硬件91将该位置为 1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0 后还未使用过，可把该位是0 的页淘汰出去，因为在最近一段时间里它未被访问过。由于该算法是循环地检查各页面的使用情况，故称为Clock 算法。但因该算法只有一位访问位，只能用它表示该页是否已经使
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用过，而置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法（Not Recently Used，NRU）。【习题演练】1.在请求调页中可采用多种置换算法，其中LRU 是（ ）置换算法。A.最佳B.最近最久未用C.最近未用D.最少使用921.【答案】B 。解析：LRU 是最近最久未用置换算法。2.Clock 置换算法又称为（ ）。A.最久驻留置换算法B.最近最久未使用置换算法C.最近未使用置换算法D.最少使用置换算法2.【答案】C。解析：最近未使用算法是Clock置换算法。知识点 17、线性表（ 一）概念线性表是最基本、最简单、也是最常用的一种数据结构。线性表是具有n （n≥0）个类型相同的数据元素组成的有限序列。93线性表的长度：线性表中元素的个数。空表：长度为0 的线性表。（ 二）特点线性表中一定存在唯一的“第一元素”。线性表中一定存在唯一的“最后元素”。除最后一个元素之外，均有唯一的后继（后件）。除第一个元素之外，均有唯一的前驱（前件）。（ 三）表示方式1.线性表的顺序表示线性表中的数据元素是用一组地址连续的存储单元依次存储的。顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。942.线性表的链式表示（1）线性链表用一组任意的存储单元存储线性表的数据元素，存储单元不一定是连续的，可以连续，也可以不连续。（2）循环链表循环链表中最后一个结点的后继指针指向头结点，使整个链表形成一个环形。（3）双向链表在双向链表中，每个结点有两个指针域，一个指向它的直接后继，另一个指向它的直接前驱。【习题演练】1.下列有关线性表的叙述中，正确的是（ ）。A.线性表中的元素之间是线性关系B.线性表中至少有一个元素C.线性表中任何一个元素有且仅有一个直接前驱95D.线性表中任何一个元素有且仅有一个直接后继1.【答案】A。解析：线性表可以为空，并且线性表中的第一个结点是没有前驱结点的，最后一个结点没有后继结点。知识点 18、栈和队列（ 一）栈的定义1.栈的定义栈是一种只能在一端进行插入或删除操作的线性表。栈中的数据元素是线性关系。栈顶：允许进行插入或删除操作的一端。栈底：不允许进行插入和删除操作，固定不变的一端。入栈：栈的插入操作。出栈：栈的删除操作。962.栈的
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 特点先进后出（First In Last Out，简称FILO）、后进先出（Last In First Out，简称LIFO）。3.栈的存储结构（1）顺序栈使用顺序存储结构存储栈。（2）链式栈使用链式存储结构存储栈。（ 二）队列的定义1.队列的定义97队列是一种运算受限制的线性表，元素的添加在表的一端进行，而元素的删除在表的另一端进行。队头：允许删除元素的一端。队尾：允许添加元素的一端。入队：向队列添加元素。出队：从队列中删除元素。2.队列的特点先进先出（FIFO）（先入队的元素先出队，后入队的元素后出队）。3.存储结构顺序队：使用顺序存储结构的队列。链队：使用链式存储结构的队列。98【习题演练】1. 下述有关栈和队列的区别，说法错误的是( )。A.栈是限定只能在表的一端进行插入和删除操作B.队列是限定只能在表的一端进行插入和在另一端进行删除操作C.栈和队列都属于线性表D.栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（n）1.【答案】D。解析：栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（1）。因为都是在端点处进行的操作。2.为解决计算机主机与打印机之间速度不匹配问题，
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是( )。99A.栈B.队列C.树D.图2.【答案】B。解析：主机将数据依次写入，打印机依次取出，应该属于先进先出的特点，既使用的逻辑结构是队列。知识点 19、树（ 一）定义树形结构是一种重要的非线性结构，树是n 个结点的有限集合，在任一棵非空树中：（1）有且仅有一个称为根的结点。（2）其余结点可分为m 个互不相交的集合，而且这些集合中的每一集合都本身又是一棵树，称为根的子树，因此树是递归结构。100（ 二）基本术语结点：包含一个数据元素及若干指向其子树的分支。结点的度数：结点的非空子树个数。树的度：树中各节点中度的最大值。分支结点：度不为0 的结点。叶子结点：度为0 的结点。孩子：结点的子树的根。双亲：结点的直接前驱。兄弟：同一个双亲的孩子之间互为兄弟。堂兄弟：双亲在同一层的结点互为堂兄弟。祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。子孙：以某结点为根的子树中的所有结点，都是该结点的子孙。层次：从根开始，根为第一层，根的孩子为第二层，以此类推。101树的深度（或者高度）：树
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 中结点的最大层数。结点的深度和高度：结点的深度是从根结点算起的，根结点的深度为 1；结点高度是从最底层的叶子结点算起的，最底层叶子结点的高度为 1。有序树：子树按照一定的次序从左向右排列，相对次序不能随意变换。无序树：子树无一定的次序排列，相对次序可以随意变换。丰满树：即理想平衡树，要求除最底层外，其他层都是满的。森林：是由零个或多个不相交的树所组成的集合。【习题演练】1.如果在数据结构中每个数据元素只可能有一个直接前驱，但可有多个直接后继，则该结构是( )。A.栈102B.队列C.树D.图1.【答案】C。解析：树结构的每个结点都有一个前驱，但可以有多个后继。知识点 20、二叉树（ 一）定义二叉树是一个连通的无环图，并且每一个顶点的度不大于 2。有根二叉树还要满足根结点的度不大于 2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2 个子结点。（ 二）主要性质①二叉树的第 i 层上至多有2i- 1 个结点。②深度为k 的二叉树至多有2k- 1 个结点。103（补充概念：a.满二叉树：深度为k，有2k- 1 个结点。b.完全二叉树：给满二叉树的结点编号，从上至下，从左至右，n 个结点的完全二叉树中结点在对应
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 满二叉树中的编号正好是从 1 到n。③叶子结点 n0，度为2 的结点为n2，则n0 =n2+1。④n个结点的完全二叉树深度为 l㎀ g2n」+1。⑤n 个结点的完全二叉树，结点按层次编号。a.i 的双亲是1 n/2，如果i =1时为根（无双亲）。b.i 的左孩子是2i，如果2i>n，则无左孩子。c.i 的右孩子是2i + 1，如果2i + 1>n 则无右孩子。（ 三）存储结构1.顺序存储结构顺序存储结构即用一个数组来存储一棵二叉树，这种存储方式最适合于完全二叉树，用于存储104一般二叉树则会浪费大量的存储空间。将完全二叉树中的结点值按编号依次存入一个一维数组中，即完成了一棵二叉树的顺序存储。例：结点 A B C D E数组下标 0 1 2 3 4 52.链式存储结构二叉树中的每个结点用一个链结点来存放，结点结构如下：lchild data rchild其中，data 表示结点数据域，用于存储对应的数据元素；lchild 和 rchild 分别表示左指针域和右指针域，分别用于存储左孩子结点和右孩子结点的位置。（ 四）遍历算法若以L、D、R 分别表示遍历左子树、遍历根结点和遍历右子树，则有六种遍历方案：DLR、L
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: DR、LRD.DRL、RDL、RLD。若规定先左后右，则只有105前三种情况，分别是：DLR--先（根）序遍历；LDR--中（根）序遍历；LRD--后（根）序遍历。【习题演练】1.设非空二叉树中度数为0 的结点数为n0，度数为 1 的结点数为n1，度数为2 的结点数为n2，则下列等式成立的是（ ）。A.n0=n1+n2B.n0=2n1+1C.n0=n2+1D.n0=n1+11.【答案】C。解析：二叉树中度为0 的结点个数等于度为2 的结点个数加一。2.一棵树高为k 的完全二叉树至少有（ ）个结点。A.2k- 1B.2k- 1- 1C.2k- 1106D.2k2.【答案】C。解析：完全二叉树层次最小为k时，前k- 1 层都是满的，第k 层有一个结点。3.深度为 5 的完全二叉树的结点数不可能是( )。A.15B.16C.17D.183.【答案】A。解析：深度为5 的完全二叉树结点最多为二的 5 次方减一个，即31 个，最少为 16个。4.二叉树的先序遍历和中序遍历如下：先序遍历：EFHIGJK，中序遍历：HFIEJKG，则二叉树根结点为（ ）。A.EB.FC.G107D.H4.【答案】A。解析：先序遍历顺序为根
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 左右，所以树根为E。知识点 21、图（ 一）图的定义图是由顶点集V 和集合E（边的集合）组成的，可以定义为G=（V，E）。V 是顶点的非空有穷集合，E 是可空的边的有穷集合。（ 二）图的术语1.无向图对于一个图，若每条边都是没有方向的，则称该图为无向图。如下图：108对于此无向图，(Vi，Vj)和(Vj，Vi)表示的是同一条边。无向图的顶点集和边集分别表示为：V(G)={V1，V2，V3，V4，V5}E(G)={(V1，V2)，(V1，V4)，(V2，V3)，(V2，V5)，(V3，V4)，(V3，V5)，(V4，V5)}2.有向图对于一个图，若每条边都是有方向的，则称该图为有向图。如下图：109在此有向图中，<Vi，Vj>和<Vj，Vi>是两条不同的有向边。有向边又称为弧。终端点也称为弧头，初始点也称为弧尾。有向图的顶点集和边集分别表示为：V(G)={V1，V2，V3}E(G)={<V1，V2>，<V2，V3>，<V3，V1>，<V1，V3>}3.无向完全图和有向完全图具有n(n- 1)/2 条边的无向图为无向完全图。具有n(n- 1)条边的有向图称为有向完全图。4.稀疏图有很少条边或弧的图。5.稠密图有很
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 多条边或弧的图1106.顶点图中的数据元素通常称为顶点。7.顶点的度无向图中，顶点的度表示以该顶点作为端点的边的数目。有向图中，顶点的度分为入度和出度。入度表示以该顶点为终点的边的数目，出度是以该顶点为起点的边的数目，该顶点的度等于其入度、出度之和。8.回路、环指一条路径的起点和终点为一个顶点。9.连通图在无向图中，如果从顶点v1 到顶点v2 有路径，则称v1 和v2 是连通的。如果图中任意两个顶点都是连通的，则称图是连通图。10.连通分量指的是无向图中的极大连通子图。11.强连通图111在有向图G 中，对任意一对顶点vi 和vj（vi≠vj），若从vi 到vj 和从vj 到vi 都存在路径，则称G 是强连通图。12.强连通分量有向图中的极大强连通子图称为有向图的强连通分量。（ 三）遍历算法从图的某一顶点出发，访问图中其余顶点，且使每个顶点仅被访问一次，这一过程称为图的遍历。图的遍历分为深度优先搜索遍历和广度优先搜索遍历。1.广度优先广度优先搜索类似于树的按层次遍历。选取图中任意一个顶点Vi作为出发点，按照下列步骤遍历图。（1）首先访问出发点Vi。112（2）接着依次访问Vi的所有未被访问过的邻接点Vi1，V
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: i2，Vi3，ⅆ , Vit并均标记为已访问过。（3）然后再按照Vi1，Vi2，ⅆ , Vit的次序，访问每一个顶点的所有未被访问过的顶点，并均标记为已访问过。（4）依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。2.深度优先深度优先搜索（DFS）类似于树的先序遍历。【习题演练】1.具有n 个结点的连通图至少有（ ）条边。A.n-1B.nC.n（n- 1）/2D.2n1.【答案】A。解析：具有n 个结点的连通图至少有n-1 条边。1132.在有向图中每个顶点的度等于该顶点的( ) 。A.入度B.出度C.入度与出度之和D.入度与出度之差2.【答案】C。解析：有向图的某个顶点v，把以 v 为终点的边的数目称为v 的入度；以v 为始点的边的数目称为v 的出度；v 的度则定义为该顶点的入度和出度之和。3.设连通图G 中的边集E={（a，b），（a，e），（a，c），（b，e），（e，d），（d，f），（f，c）}，则从顶点a 出发可以得到一种深度优先遍历的顶点序列为（ ）。A.abedfcB.acfebdC.aebdfcD.aedfcb1143.【答案】A。图的深度优先遍历类似于树的前序遍历。采
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用的搜索方法的特点是尽可能先对纵深方向进行搜索。知识点 22、数据模型（ 一）数据模型的概念数据模型是对现实世界数据特征的抽象。也就是说，数据模型是用来描述数据、组织数据和对数据进行操作的。（ 二）两类数据模型在数据库中模型主要分为两大类：一类为概念模型；另一类为逻辑模型和物理模型。概念模型也称为信息模型，在数据库设计阶段，由设计员按照用户观点建模实现对现实世界的概念抽象。115http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8656077逻辑模型包括网状、层次、关系和对象模型等，由设计人员按照计算机观点建模实现概念模型到适应某DBMS 的逻辑模型的转变。再由DBMS 完成逻辑到物理模型的转变。物理模型是数据最底层的抽象，描述数据的存储方式和方法。（ 三 ）现实世界的数据化过程现实世界 信息世界 数据世界概念模型现实世界的数据化过程【习题演练】1.常见的逻辑模型有3 种，它们是（ ）。A.字段名、字段类型和记录116DBMS支持下的数据模型事物本身B.层次、关系和网状C.环状、层次和关系D.网状、关系和语义1.【答案】B。解析：常见的数据模型有3 
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 种，即按图论理论建立的层次结构模型和网状结构模型以及按关系理论建立的关系结构模型。知识点 23、概念模型概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有利工具，也是数据库设计人员和用户之间进行交流的语言。（ 一）常用术语1.实体117客观存在并且可以区分的具体事物或者抽象概念。例如，一个学生、一个宿舍、一个操作流程等等。2.属性属性是对客观事物特征的一种反映，是实体具有的某个特征。例如，学生实体中有学号属性、姓名属性、性别属性，年龄属性、所在系属性等。属性有属性名称和属性值之分，例如，姓名为属性名，则“李白”就是这个属性的值。3.码在现实生活中，实体是可以互相区分的，所以没有两个完全相同的实体，即不能够有两个实体在各自对应属性上的属性值都是相同的。4.域一个属性的取值范围被称为域。例如，性别属性的属性值只能为“男”或者只能为“女”。5.实体型118实体集的名称及其所有属性名的集合称为实体型。例如，学生（学号，姓名，性别，年龄，所在系）就是学生实体集的实体型。6.实体集所有属性名完全相同的实体集合在一起，称为实体集。比如说学生实体集，教师实体集等。（ 二）概念模型
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的表示方法：实体-联系图E-R 图中文称为实体-联系图，它是概念模型中的一种表示形式。E-R 图主要包含三个概念，分别是：实体集、联系集和属性。1.实体-联系图的表示方法实体型：用矩形表示，矩形框内写明实体名。属性：用椭圆表示，并用无向边将其对应的实体型连接起来。联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或者M：N）。1192.联系两个实体集之间的联系可归纳为以下三类：（1）一对一联系（1:1）如果对于实体集A 中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A 与实体集B 具有一对一关系，记为 1：1。例如，一个学校只能有一个校长；一个账号只能提供给一个人使用等。（2）一对多联系（1：N）和多对一联系（N：1）如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集B 中的每一个实体，实体集A 中至多只有一个实体与之联系，则称实体集A 与实体集B 有一对多的联系，记为 1：n。例如，一个工厂可以有若干个员工，而一个员工只能属于一个工厂；一个导师可以有若干个学
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 员，而一个学员只能属于一个导师等。（3）多对多联系（M：N）120如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集 B 中的每一个实体，实体集A 中也有M 个实体（M>=0）与之联系，则称实体集A 与实体集B具有多对多的联系，记为M：N。例如，一门课程可以被多个学生选择，一个学生可以选择多门课程等。【习题演练】1.下列实体类型的联系中，属于一对一联系的是（ ）。A.教研室对教师的所属联系B.父亲对孩子的联系C.省对省会的所属联系D.供应商与工程项目的供货联系1.【答案】C。解析：实体之间的联系分为：一对一、一对多和多对多。因为每一个省都只有一个省会，而一个省会只属于一个省，所以省和省会之121间是一对一的联系。而A 选项属于一对多的关系；B 选项属于一对多的关系；D 选项属于多对多的关系。2.在E-R 图中，用长方形表示（ ），用椭圆表示（ ）。A.联系、属性B.属性、实体C.实体、属性D.什么也不代表、实体2.【答案】C。解析：矩形表示实体，椭圆表示属性。3.关系模型中，候选码（ ）。A.可由多个任意属性组成B.至多由一个属性组成C.可由一个或多个其值能惟一标识
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 该关系模式中任何元组的属性组成D.以上都不是1223.【答案】C。解析：候选码可以是一个也可以是多个，但是必须能唯一标识元组。知识点 24、关系模型（ 一）简介关系数据模型是目前最重要的一种数据模型。关系数据库系统采用关系数据模型作为数据的组织方式。有层次数据模型和网状模型相比，关系模型概念简单、清晰，并且具有严格的数据基础，形成了关系数据理论，操作也直观、容易，因此易学易用。支持关系数据模型的DBMS 称为关系型数据库管理系统RDBMS。与其他数据模型相同，关系数据模型也是由数据结构、数据操作和完整性约束三个部分组成。123（ 二）关系模型的性质列是同质的，即同一列的分量值应该出自相同的域。列名是唯一的，即在同一个关系中不能出现完全相同的两个属性名称。行的顺序无关，即元组与元组之间互换位置，不相互影响。列的顺序无关，即列于列之间互换位置，不相互影响。任何两行不能完全相同，即不能出现两个完全相同的元组。分量必须是原子量，即是不可分的基本数据项。【习题演练】1.下列叙述正确的为（ ）。A.关系中元组没有先后顺序，属性有先后顺序B.关系中元组有先后顺序，属性没有先后顺序124C.关系中元组没有先后顺序，属性也没有
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 先后顺序D.关系中元组有先后顺序，属性也有先后顺序1.【答案】C。解析：关系中元组的顺序无关，属性的顺序也无关。知识点 25、关系操作和完整性约束（一 ）基本的关系操作1.查询操作关系的查询表达能力很强，是关系操作最主要的部分。查询操作又可以分为：选择、投影、连接、除、并、差、交、笛卡尔积等。2.更新操作更新操作又可以分为：插入、删除、修改。3.基本操作125关系的基本操作有五种，分别是：选择、投影、并、差、笛卡尔积。其他操作是可以用基本操作来定义和导出的。就像乘法可以用加法定义和导出一样。4.关系操作的特点关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应地，非关系数据模型的数据操作方式则为一次一记录的方式。（ 二）关系的三类完整性关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。1.实体完整性126（1）规则若属性（指一个或者一组属性）A 是基本关系R 的
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 主属性，则A 不能取空值。按照实体完整性规则的规定基本关系的主码都不能取空值。如果主码由若干属性组成，则所有这些主属性都不能取空值。（2）具体说明①实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。②现实世界中的实体是可以区分的，即它们具有某种唯一性标识。③相应地，关系模型中以主码作为唯一标识。④主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与②点相矛盾，因此这个规则称为实体完整性。2.参照完整性127若属性（或属性组）F 是基本关系R 的外码，它与基本关系S 的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R 中每个元组在F上的值必须为：①或者取空值（F 的每个属性值均为空值）；②或者等于 S 中某个元组的主码值。3.用户自定义完整性任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件。它反映某一具体应用所涉及的数据必须满足的语义要求。例如某个属性必须取值唯一
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、某个非主属性也不能取空值等。【习题演练】1281.若属性A是关系R 的主属性，则A不能为空，该规则称为（ ）。A.实体完整性规则B.属性完整性规则C.参照完整性规则D.用户定义完整性规则1.【答案】A。解析：数据完整性包括：实体完整性、参照完整型和用户定义完整性。实体完整性即规定主键不能为空。2.关系模型有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。定义外键实现的是（ ）完整性。A.实体完整性B.参照完整性C.用户定义的完整性D.实体完整性、参照完整性和用户定义的完整性1292.【答案】B。解析：定义外键实现的是参照完整性。知识点 26、SQL 常用语句SQL（Structured Query Language），即结构化查询语言，是关系数据库的标准语言。当前，几乎所有的关系数据库管理系统软件都支持 SQL，许多软件厂商对 SQL 的基本命令集还进行了不同程度的扩充和修改。SQL 集数据查询、数据操纵、数据定义和数据控制功能于一体，是一个综合的、通用的、功能极强、简洁易学的语言。（ 一）数据查询1.语句格式SELECT [ALL|DISTINCT] column_listFROM table_
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: list130[WHERE search_condition][GROUP BY group_by_list][HAVING search_condition][ORDER BY order_list[ASC|DESC]]2.运算符算术比较运算符：=，<，<=，>，>=，<>，!>，!<逻辑运算符：AND、OR、NOT所属集合运算符：IN、NOT IN谓词：EXISTS（存在)、BETWEEN…AND（范围）、LIKE（匹配）、IS NULL（空值）3.统计函数常见的统计函数统计函数 描述COUNT（*） 计算记录的个数COUNT（[DISTINCT]列名） 对一列中的值计算个数SUM（[DISTINCT]列名） 求某一数值型列的总和AVG（[DISTINCT]列名） 求某一数值型列的平均值131统计函数 描述MAX（[DISTINCT]列名） 求某一列的最大值MIN（[DISTINCT]列名） 求某一列的最小值4.连接查询在查询的数据涉及到多个表时，必须用连接条件将这些表连接起来。5.嵌套查询在 SQL 语句中，可以将一个查询嵌入在另一个查询的WHERE 子句中，这类查询称为嵌套查询。一般内层的查询称为子查
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 询，将外层的查询称为父查询。嵌套的 SELECT 查询使得 SQL 可以实现各种复杂的查询，子查询必须用括号括起来。6.示例a.查询计算机系年龄在20 岁以下的学生姓名：SELECT SnameFROM StudentWHERE Sdept=’CS’ AND Sage<20；b.查询选修了3 门以上课程的学生学号：132SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*)>3;（ 二）数据更新1.INSERT 语句（1）语句格式INSERT INTO<表名>[（<属性名清单>）]VALUES（<常量清单>）;（2）实例：在Employee表中插入一职工记录。INSERT INTO EmployeeVALUES（’2032’，’张杉’，’男’，28，’工程师’，’01 ’）;2.UPDATE 语句（1）语句格式UPDATE<表名>133SET <列名>=<表达式>[,<列名>=<表达式>][WHERE<条件>];（2）实例：在工资表中，将所有职工的基本工资都增加500。UPDATE SalarySET Basepay=Basepay+500;3.DELETE 语句（1）语句格
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 式DELETE FROM <表名>[WHERE<条件>]（2）实例：从职工表中删除Eno（职工号）为1003 的记录。DELETE FROM EmployeeWHERE Eno=’1003’;【习题演练】1341.SQL 语言的标准库函数 COUNT 、SUM 、AVG、MAX 和MIN 等，不允许出现在下列哪个子句中（ ）。A.SELECTB.HAVINGC.WHERED.GROUP，HAVING1.【答案】C。解析：SQL 语言的标准库函数COUNT、SUM、AVG、MAX 和MIN 等，不允许出现在WHERE 子句中。2.在SQL 语句中，与X BETWEEN 20 AND 30等价的表达式是（ ）。A.X>=20 AND X<30B.X>=20 AND X<=30C.X>20 AND X<=30D.X>20 AND X<302.【答案】B。解析：BETWEEN A AND B 是指在 A-B 之间的范围，且包括A 和B 。故与X135BETWEEN 20 AND 30 等价的表达式是 X>=20AND X<=30。3.一个查询的结果成为另一个查询的条件，这种查询被称为（ ）。A.内查询B.连接查询C.
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 自查询D.子查询3.【答案】D。解析：一个查询的结果成为另一个查询的条件，这种查询被称为子查询，也叫嵌套查询。4.在考试表中，要将58 分、59 分的分数调整到60 分，下列SQL 语句中能实现的是（ ）。A.UPDATE 考试表 SET 分数 = 60 HAVING分数>=58 AND 分数<60B.UPDATE 考试表 SET 分数 = 60 WHERE分数>=58 AND 分数<60136C.UPDATE 考试表 SET 分数 = 60 WHERE分数 IN(58,59)D.UPDATE 考试表 SET 分数 = 60 WHERE分数 BETWEEN 58 AND 594.【答案】C。解析：由题知至包含58 分和59分，符合题意的只有C 选项。知识点 27、计算机网络分类（一）按作用范围1.局域网（LAN）局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，137http://baike.baidu.com/view/
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 7886.htmhttp://baike.baidu.com/view/4321959.htmhttp://baike.baidu.com/view/281640.htm可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。2.城域网（MAN）城域网（Metropolitan Area Network）是在一个城市范围内所建立的计算机通信网，简称MAN。属于宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在 100 兆比特/秒以上。3.广域网（WAN）广域网（WAN，Wide Area Network）也称远程网（Long Haul Network）。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。（ 二）按拓扑结构1.星型拓扑结构138星型拓扑结构是一种以中央结点为中心，把若干外围结点连接起来的辐射式互联结构，各结点与中央结点通过点与点方式连接，中央结点执行集中式通信控制策略，因此中央结点相当复杂，负担也重。2.树型拓扑结构树型拓扑结构是一种层次结构，
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结点按层次连接，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。3.总线型拓扑结构总线型拓扑结构是采用单根传输作为共用的传输介质，将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上。使用总线型拓扑结构需解决的是确保用户使用媒体发送数据时不能冲突。在点到点的链路配置时，如果链路是半双工操作，只需使用简单的机制便可保证两个用户轮流工作。在一点到多点方式中，对线路的访问依靠控制139http://baike.baidu.com/view/47398.htmhttp://baike.baidu.com/view/420833.htm端的探询来确定。采取分布式访问控制策略来协调网络上计算机数据的发送。4.环型拓扑结构环型拓扑结构是使用公共电缆组成一个封闭的环，各结点直接连到环上，信息沿着环按一定方向从一个结点传送到另一个结点。环接口一般由发送器、接收器、控制器、线控制器和线接收器组成。5.网状拓扑结构网状拓扑结构，这种拓扑结构主要指各结点通过传输线相互连接起来，并且每一个结点至少与其他两个结点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，不常用于局域网。（ 三）按使用范围1.公用网一般是国家的邮电部门建造的网络。“公用”的意思就是从所有愿意按邮电部门规定交纳费用的140人都可以使用。因此，公用网也可以称为公众网，例如CHINANET、CERNET 等。2.专用网“专用网”是某个部门为本单位的特殊工作的需要而建立的网络。专用网指专用于一些保密性要求较高的部门的网络，比如企业内部专用网、军队专用网，尤其是涉及国家机密的部门。这种网络不向本单位以外的人提供服务。例如，军队、铁路、电力等系统均有本系统的专用网。【习题演练】1.局域网常用的基本拓扑结构有（ ）、环型和星型。A.层次型B.总线型C.交换型D.分组型1411.【答案】B。解析：局域网常用的拓扑结构有星型、环型、树型、总线型。网状型通常应用于广域网。知识点 28、网络地址（ 一）物理地址网卡物理地址存储器中存储单元对应实际地址称物理地址。MAC（介质访问控制）地址是识别LAN（局域网）结点的标识。网卡的物理地址通常是由网卡生产厂家烧入网卡的EPROM（一种闪存芯片，通常可以通过程序擦写），它存储的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址。物理地址一般记作 06-2E-1
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4-F9-5A-23，48 比特的不同组合。142（ 二）IP 地址是为网络每台计算机分配的唯一标识，为了使连入网络的众多计算机主机在通信时能够互相识别，网络中的每一台主机都有唯一的32 位地址。IP 地址一般用小数点隔开的十进制数，即点分十进制表示，如202.120.70.23。以点分十进制的形式表示IP 地址时，用小数点将 IP 地址分为四部分，每个部分的范围为0～255。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志该主机（或路由器）。两级的IP 地址可以记为：IP 地址：：= { <网络号>，<主机号>}（ 三）IP 地址分类汇总143IP 地址分类类型 IP 范围 私有IPA 1-126 10.0.0.1-10.255.255.255B 128-191 172.16.0.1- 172.31.255.255C 192-223 192.168.0.1- 192.168.255.255D 224-239E 240-254（ 四）特殊的 IP 地址主机号全为 1 表示本网段的内部广播地址，不能分给计
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 算机使用。主机号全为0 表示本网络的网段，计算机所在网络。127 开头的本地回环地址，主要测试TCP/IP 协议正确性。D 类地址为组播地址。主要是路由协议OSPF等使用。14410.0.0.110.255.255.255172.16.0.1172.31.255.255192.168.0.1192.168.255.255E 类地址用于研究使用。169.254.*.*的地址是当计算机自动获取IP 地址失败后的标识，但不能用于计算机之间的通信。（五）IPv6 地址IPv6 是InternetProtocoLVersion 6 的缩写，是下一代 IP 地址，用于替代现行版本 IP 协议（IPv4）的下一代 IP 协议，目的是为解决 IP 地址紧缺的问题。扩大地址的可用空间，满足计算机网路增长的需求。IPv6 将地址32 位（IPv4）增大到了 128 位二进制，使得地址数量变为原来的2 的96 次方倍，地址数量更多，适应未来网络扩展的需求。【习题演练】1.以下IP地址中，属于A 类地址的是（ ）。A.52.213. 12.23B.210.123.23. 12145C.223.123.213.23D.156.123.
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 32. 121.【答案】A。解析：A 类地址的第一个部分范围是 1～126，符合的只有A 选项。2.IPv4 地址和IPv6 地址的位数分别为（ ）。A.4，6B.8，16C.16，24D.32，1282.【答案】D。解析：IPv4 地址和Ipv6 地址的位数分别为32，128。知识点 29、子网掩码（ 一）概念子网掩码是一种用来指明一个 IP 地址的网络位和主机位，知道了 IP 地址的网络位，就可以确定146计算机 IP 地址所在的网络，知道了主机位就可以确定该 IP 地址所在网络的位置。（ 二）功能子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码是一个32 位地址，一般在书写的时候也是点分十进制表示。在子网掩码中，1 表示网络位，0 表示主机位。（ 三）默认子网掩码A 类网络的子网掩码为255.0.0.0，B 类网络的子网掩码为 255.255.0.0，C 类网络的子网掩码为255.255.255.0。（ 四）求网络号主机号全为0 的地址表示网络号。第一步把IP 地址转化为二进制。147255.0.0.0255.255.0.0255.255.255.0第二步把子网掩码转化为二进制。第三步保留
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 子网掩码中 1 所对应的部分，主机位用0 填充。第四步转为点分十进制。（五） 求主机号第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 0 所对应的部分。（六） 求广播号主机号全为 1 的地址表示广播号。第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 1 所对应的部分，主机位用 1 填充。第四步转为点分十进制。148（七） 子网划分计算形成子网的数量计算：从主机位借位当网络位来使用。借位数 子网个数 借位数 子网个数1 21 = 2 4 24 =162 22 = 4 5 25 =323 23 =8 6 26 = 64【习题演练】1.以下关于子网掩码的作用，错误的是（ ）。A.标识 IP 地址的网络部分和主机部分B.主机部分对应的子网掩码部分全为“0”C.网络部分对应的子网掩码部分全为“1”D.通过子网掩码标识网络的类型1491.【答案】D。解析：子网掩码是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位。其中主机部分对应的子网掩码部分全为0，网络部分全为 1。2.一个子网掩码是 255.255.240.0
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，这个子网能拥有的最大主机数是（ ）。A.240B.255C.4094D.655342.【答案】C。解析：255.255.240.0，将子网掩码中的240 转换为二进制，240=11110000，所以进行子网划分的时候借走了4 位主机位充当网络位，能够形成 2^4= 16 个子网，每个子网中的 IP 数量2^ 12=4096 ，但是能够分配给计算机使用的只有4096-2=4094。150255.255.240.0知识点 30、网络设备（一）局域网设备1.中继器中继器（Repeater）是局域网互连的最简单设备，工作在OSI 体系结构的物理层，它接收并识别网络信号，然后再生信号并将其发送到网络的其他分支上。信号在传输线路上传输的时候，受到距离、噪音、电阻等影响，使得信号传输的距离不能是长到无限远，在传输一定距离后，信号需要加强。如果在线路中间插入放大器，则伴随信号的放大，噪音也被放大了。中继器的功能是对接收信号进行再生和发送。2.集线器集线器属于物理层设备。集线器是有多个端口的中继器，简称HUB。151集线器在创建网络时，一般是以星型或树型拓扑结构为主。集线器没有MAC地址表，采用广播方式发送，当网络中的主机数
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 量过多的时候，就会在网络生成广播风暴。以集线器为主要网络设备的网络被称为共享式以太网。3.网卡网络接口卡NIC（Network Interface Card）又称网卡或网络适配器。网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。4.网桥在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据MAC 帧的目的地址对收到的帧进行转发。152网桥不隔绝广播风暴。5.交换机以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。（ 二）广域网设备1.网关网关（Gateway）又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。2.路由器153路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，以最佳路径，按前后顺序发送信号。3.调制解调器调制解调器（modem）是一种计算机硬件，它能把计算机的数字信号翻译成可沿普通电话线传送的模拟信号，是家用电话拨号上网的必不可上少的设备。调制：将数字信号转化为模拟信号。解调：将模拟信号转化为数字信号。【习题演练】1.集线器是工作在（ ）的设备。A.物理层B.链路层C.网络层D.运输层1541.【答案】A。解析：中继器和集线器就是物理层的设备。2.在下列网间连接器中，（ ）在数据链路层实现网络互连。A.中继器B.网桥C.路由器D.网关2.【答案】B。解析：网桥是数据链路层的设备，中继器是物理层设备，路由器是网络层设备，网关在传输层及其以上实现网络互联。155知识点 31、信息加密技术（ 一）信息加密信息加密是指使有用的信息变为看上去似为无用的乱码，使攻击者无法读懂信息的内容从而保护信息。任何一个加密系统至少由下面四个部分组成：1.未加密的信息，也称明文。2.加密后的信息，也称密文。3.加密解密设备或算法。4.加密解密的密钥。发送方用加密密钥，通过加密设备或算法，将信息加密后发送出去。接收方在收到密文后，用解密密钥将密文解密，恢复为明文。如果传输中有人窃取，他只能
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 得到无法理解的密文，从而对信息起到保密作用。156其中，密钥是唯一能够控制明文与密文之间变换的关键，通常是一随机字符串，在计算机上实现的数据加密算法，其加密或解密变换是由一个密钥来控制的。（ 二）对称加密1.概念对称密码体制是指如果一个加密系统的加密密钥和解密密钥相同，或者虽然不相同，但是由其中的任意一个可以很容易地推导出另一个，即密钥是双方共享的，则该系统所采用的就是对称密码体制。2.加密过程3.对称加密算法特点157对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。常见的对称加密算法：DES 算法，3DES 算法，TDEA 算法，Blowfish 算法，RC5 算法， IDEA 算法。（ 三）非对称密钥加密1.概念公钥密码体制指一个加密系统的加密密钥和解密密钥是不一样的，或者说不能由一个推导出另一158个。其中一个称为公
2025-08-10 14:53:36.763 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 钥用于加密，是公开的，另一个称为私钥用于解密，是保密的。公钥密码体制解决了密钥的管理和发布问题，每个用户都可以把自己的公开密钥进行公开，如发布到一个公钥数据库中。2.工作原理A要给B发送信息时，A用B 的公钥加密信息，因为A 知道B 的公钥。A 将这个消息发给B。B 收到这个消息后，B 用自己的私钥解密A 的消息。其他所有收到这个报文的人都无法解密，因为只有B 才有B 的私钥。3.RSA 算法159RSA 是Rivest、Shamire 和Adleman 于 1978 年在美国麻省理工学院研制出来的，它是一种比较典型的公开密钥加密算法。【习题演练】1.在数据加密技术中，将待加密的报文称为( )。A.密文B.正文C.短文D.明文1.【答案】D。解析：待加密的报文称为明文。2.在公钥密码体制中，公开的是（ ）。A.公钥和私钥B.公钥和算法C.明文和密文D.加密密钥和解密密钥1602.【答案】B。解析：公钥加密算法是计算机网络中经常使用的算法，能跟好的保证网络安全。其中有两个秘钥，公钥和算法是公开的，可以在服务器上查找到，这样方便用于加密。私钥是用户自己保存的一种密钥。3. 以下关于对称与非对称加密算法叙述中正确的
2025-08-10 14:53:36.765 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 是（ ）。A.对称加密比非对称加密的安全性好B.对称加密比非对称加密的解密速度慢C.非对称加密算法中公钥是公开的，算法是保密的D.非对称加密与对称加密相比，用户需要保管的密钥数量少3.【答案】D。解析：非对称加密使用了一对密钥，即公钥与私钥，公钥是公开的，私钥个人持有，不公开，故D 选择正确。161知识点 32、计算机病毒（ 一）计算机病毒的概念广义上，能够引起计算机故障、破坏计算机数据的程序都可称为计算机病毒；狭义上，计算机病毒是指编制者在计算机程序中插入的破坏计算机或者毁坏数据，影响计算机的使用，并能自我复制的一组计算机指令或者程序代码。（ 二）计算机病毒的特性目前，计算机病毒有数十万种，各有其不同的特征，但总的说来，计算机病毒又有明显的共性。计算机病毒主要有以下几种特征：1.传染性传染性是计算机病毒的基本特征。计算机病毒能通过自我复制来感染正常的文件，达到破坏计算162机系统正常运行的目的。但传染性是有条件的，只有病毒程序被执行之后才具有传染性，才能感染其他文件。2.破坏性任何计算机病毒只要侵入计算机系统，都会对系统及应用程序产生不同程度的影响和破坏，轻则降低计算机的工作效率，占用系统资源，重则破坏数据
2025-08-10 14:53:36.765 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，删除文件，甚至导致系统崩溃，给用户造成不可挽回的损失。3.寄生性虽然计算机病毒是一种程序，但这种程序通常不是以独立文件的形式存在的，它寄生在合法的程序之中。这些合法的程序可以是系统引导程序、可执行程序、一般应用程序等。现在的某些病毒本身就是一个完整的程序，如广义病毒中的网络蠕虫。4.欺骗性黑客常常会把带有病毒程序的名字起成一些用户比较关心的程序名字。1635.隐蔽性和潜伏性计算机病毒要有效的传染和传播，就应该尽量在用户能够觉察的范围之外进行。6.衍生性既然计算机病毒是一段特殊的程序，了解病毒程序的人就可以根据其个人意图随意改动，从而衍生出另一种不同于原版病毒的新病毒。7.可触发性编制计算机病毒的人，一般都为病毒程序设定了一些触发条件，例如系统时钟的某个时间或日期、系统运行了某些程序等。一旦条件满足，计算机病毒就会“发作”，使系统遭到破坏。（ 三）计算机病毒的传播方式计算机病毒的传播方式主要有：（1）移动存储设备传播；（2）计算机网络传播；（3）电子邮件传播。164【习题演练】1.计算机病毒是可以造成计算机故障的（ ）。A.一种微生物B.一种特殊的程序C.一块特殊芯片D.一个程序逻辑错误1.【答案】B。解析：
2025-08-10 14:53:36.765 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 计算机病毒指人为编制的一段具有破坏性的，能够自我复制的程序或者代码。2.计算机病毒具有破坏性、（ ）、潜伏性和传染性等特点。A.必然性B.再生性C.隐蔽性D.易读性2.【答案】C。解析：计算机病毒具有寄生性、传染性、潜伏性、隐蔽性。1653.根据统计，当前计算机病毒扩散最快的途径是（ ）。A.软件复制B.网络传播C.磁盘拷贝D.运行游戏软件3.【答案】B。解析：计算机病毒扩散最快的是网络传播，需要提前安装使用杀毒软件来做好防范。166目录知识点 1 、进制转换知识点 2 、常见数据编码知识点 3 、机器数知识点 4 、补码溢出知识点 5 、寻址方式知识点 6 、存储芯片容量的计算知识点 7 、DRAM 的刷新知识点 8、存储器与 CPU 的扩展连接知识点 9 、死锁知识点 10 、处理机调度的层次知识点 11 、调度算法知识点 12 、内存的连续分配知识点 13 、基本的分页存储管理知识点 14 、基本的分段存储管理知识点 15 、虚拟存储器知识点 16 、页面置换算法知识点 17 、线性表知识点 18 、栈和队列知识点 19 、树知识点 20 、二叉树知识点 21 、图知识点 22 、数据模型知识点 23 
2025-08-10 14:53:36.765 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、概念模型知识点 24 、关系模型知识点 25 、关系操作和完整性约束知识点 26 、SQL 常用语句知识点 27 、计算机网络分类知识点 28 、网络地址知识点 29 、子网掩码知识点 30 、网络设备知识点 31 、信息加密技术知识点 32 、计算机病毒
2025-08-10 14:53:36.941 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:36.941 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:36.941 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.yizhaoqi.smartpai.service.VectorizationService - 开始向量化文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:36.950 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 174
2025-08-10 14:53:36.950 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:36.951 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:37.154 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] [2f214867-5] Response 400 BAD_REQUEST
2025-08-10 14:53:37.155 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] [2f214867-5] Read 312 bytes
2025-08-10 14:53:38.160 [parallel-4] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:38.160 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:38.366 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] [2f214867-6] Response 400 BAD_REQUEST
2025-08-10 14:53:38.367 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] [2f214867-6] Read 312 bytes
2025-08-10 14:53:39.380 [parallel-5] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:39.381 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:39.609 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] [2f214867-7] Response 400 BAD_REQUEST
2025-08-10 14:53:39.618 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] [2f214867-7] Read 312 bytes
2025-08-10 14:53:40.620 [parallel-6] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:40.620 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:40.802 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] [2f214867-8] Response 400 BAD_REQUEST
2025-08-10 14:53:40.802 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [5db61c27] [2f214867-8] Read 312 bytes
2025-08-10 14:53:40.804 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [5db61c27] Cancel signal (to close connection)
2025-08-10 14:53:40.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR com.yizhaoqi.smartpai.client.EmbeddingClient - 调用向量化 API 失败: Retries exhausted: 3/3
reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:840)
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:40.806 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.yizhaoqi.smartpai.service.VectorizationService - 向量化失败，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:40.807 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.y.smartpai.consumer.FileProcessingConsumer - Error processing task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:43.826 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR o.s.kafka.listener.KafkaMessageListenerContainer - Error handler threw an exception
org.springframework.kafka.KafkaException: Seek to current after exception
	at org.springframework.kafka.listener.SeekUtils.seekOrRecover(SeekUtils.java:227)
	at org.springframework.kafka.listener.DefaultErrorHandler.handleRemaining(DefaultErrorHandler.java:168)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeErrorHandler(KafkaMessageListenerContainer.java:2836)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2713)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: org.springframework.kafka.listener.ListenerExecutionFailedException: Listener method 'public void com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(com.yizhaoqi.smartpai.model.FileProcessingTask)' threw exception
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.decorateException(KafkaMessageListenerContainer.java:2869)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2814)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	... 10 common frames omitted
	Suppressed: org.springframework.kafka.listener.ListenerExecutionFailedException: Restored Stack Trace
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:435)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
Caused by: java.lang.RuntimeException: Error processing task
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:67)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	... 12 common frames omitted
Caused by: java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	... 25 common frames omitted
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:43.829 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Received task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
2025-08-10 14:53:43.829 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件权限信息: userId=1, orgTag=PRIVATE_sy, isPublic=false
2025-08-10 14:53:43.829 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Downloading file from storage: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:43.829 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Detected remote URL: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:43.834 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Successfully connected to URL, starting download...
2025-08-10 14:53:43.834 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 开始解析文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:43.963 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] WARN  org.apache.pdfbox.pdmodel.font.PDCIDFontType2 - Found CFF/OTF but expected embedded TTF font THDZFH+AppleSDGothicNeo-Regular
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文件元数据:
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:unmappedUnicodeCharsPerPage: 0
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:PDFVersion: 1.7
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmp:CreatorTool: WPS 文字
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXFA: false
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:modify_annotations: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print_degraded: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By-Full-Set: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:creator: Sky123.Org
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:num3DAnnotations: 0
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:format: application/pdf; version=1.7
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator_tool: WPS 文字
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:overallPercentageUnmappedUnicodeChars: 0.0
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:fill_in_form: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasCollection: false
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:encrypted: false
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsNonEmbeddedFont: false
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:custom:SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasMarkedContent: false
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - Content-Type: application/pdf
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator: Sky123.Org
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:totalUnmappedUnicodeChars: 0
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_for_accessibility: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:assemble_document: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmpTPg:NPages: 166
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXMP: false
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:charsPerPage: 15
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_content: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:trapped: False
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationTypes: null
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_modify: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationSubtypes: Link
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsDamagedFont: true
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 提取的文本内容长度: 44161
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换............................................................ 6知识点 2、常见数据编码....................................................8知识点 3、机器数.............................................................. 14知识点 4、补码溢出..........................................................19知识点 5、寻址方式..........................................................22知识点 6、存储芯片容量的计算..................................... 39知识点 7、DRAM 的刷新................................................ 40知识点 8、存储
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与 CPU 的扩展连接...........................43知识点 9、死锁.................................................................. 48知识点 10、处理机调度的层次....................................... 553知识点 11、调度算法........................................................57知识点 12、内存的连续分配........................................... 63知识点 13、基本的分页存储管理................................... 70知识点 14、基本的分段存储管理................................... 76知识点 15、虚拟存储器....................................................83知识点 16、页面置换算法....................
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ........................... 90知识点 17、线性表............................................................ 95知识点 18、栈和队列........................................................98知识点 19、树.................................................................. 102知识点 20、二叉树.......................................................... 105知识点 21、图.................................................................. 1104知识点 22、数据模型......................................................117知识点 23、概念模型................................
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ......................119知识点 24、关系模型......................................................125知识点 25、关系操作和完整性约束.............................127知识点 26、SQL 常用语句............................................ 132知识点 27、计算机网络分类......................................... 139知识点 28、网络地址......................................................144知识点 29、子网掩码......................................................148知识点 30、网络设备......................................................153知识点 31、信息加密技术...............................
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: .............. 158知识点 32、计算机病毒..................................................1645知识点 1、进制转换常用数制数制 数码 运算规则 尾符十进制 0—9 逢十进一 D或10二进制 0—1 逢二进一 B或2八进制 0—7 逢八进一 O或8十六进制 0—9，A—F 逢十六进一 H或16（ 一 ）非十进制数转换成十进制数方法每位上的数码×基的位次方，然后求和。（ 二 ）十进制数转换成非十进制数方法整数部分：除N 取余数，直至商为0，余数倒输出。小数部分：乘N 取整数，直至积为0（或满足精度），整数正输出。6（N 为进制数，N 可取2、8、16。）（ 三 ）二/八/十六进制数的互相转换方法由于一位八/十六进制数相当于三/四位二进制数，因此，要将八/十六进制数转换成二进制数时，只需以小数点为界，向左或向右每一位八/十六进制数用相应的三/四位二进制数取代即可。如果不足三/四位，可用零补足。反之，二进制数转换成相应的八/十六进制数，只是上述方法的逆过程，即以小数点为界，向左或向右，每三/四位二进制数用相应的一位八/十六进制数取代即可。【习题
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 演练】1.二进制数 1101.01 转换成十进制数是（ ）。A.17.256B.13.5C.13.25D.17.571.【答案】C。解析：（1101.01）2= 1 x23+1 x22+1+1 x 2—2 = 13.25。2.下列数中最大的数是（ ）。A.227OB.1FFHC. 10100001BD.1789D2.【答案】D。解析：将所有数都统一转换为十进制进行比较，227O=151D ， 1FFH=511D ，10100001B= 161D，对比可知应选D 选项。知识点 2、常见数据编码（ 一）ASCII码美国信息交换标准代码（American StrandardCode for Information Interchage，ASCII）是一种西8文机内码，是计算机中使用最广泛的字符编码，已经作为国际通用的信息交换标准代码。ASCII 码包括 0～9 十个数字，大小写英文字母和专用符号等95 种可打印字符，以及33 种控制字符（如回车、换行等），通常采用一个字节编码，由7 位二进制编码组成，字节的最高位一般规定为0，或用作校验码，可表示 128 个不同的字符。（ 二）汉字的编码1.国标码《信息交换用汉字编
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 码字符集·基本集》是我国于 1980 年制定的国家标准GB2312—80，简称国标码，是国家规定的用于汉字信息交换使用的代码的依据。GB2312—80 中规定了信息交换用的6763个汉字和682 个非汉字图形符号（包括外文字母、数字和符号）的代码。国标码用两个字节表示一个汉字，每个字节只使用低7 位，最高位为0。2.汉字机内码9汉字的机内码是供计算机系统内部进行存储、加工处理、传输统一使用的代码，又称为汉字内部码或汉字内码。汉字机内码是将国标码的两个字节的最高位分别置为 1 而得到的。其最大优点是机内码表示简单，同时也解决了中西文机内码存在的二义性的问题。3.汉字输入码汉字输入码是为了将汉字通过键盘输入计算机而设计的代码。汉字输入编码方案很多，其表示形式大多用字母、数字或符号。输入码的长度也不同，多数为四个字节。综合起来可分为流水码、音码、形码和音形码几大类。4.汉字字形码汉字字形码是汉字字库中存储的汉字字形的数字化信息，用于汉字的显示和打印。目前汉字字形的产生方式大多是数字式，即以点阵方式形成汉字。因此，汉字字形码主要是指汉字字形点阵的代码，10主要有 16×16 点阵、32×32 点阵、256×256 点
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 阵等。如 24×24 的点阵，每字需要72 字节；32×32的点阵，每字需要 128 字节。与每个汉字对应的这一串字节就是汉字的字形码。（ 三）二-十进制编码人们习惯于使用十进制数，而计算机内部多采用二进制数表示和处理数值数据，因此在计算机输入和输出数据时，就要进行由十进制到二进制和从二进制到十进制的转换处理，显然，这项事务性工作如果由人工来完成，势必造成大量时间浪费。因此，必须采用一种编码的方法，由计算机自己来完成这种识别和转换工作。人们通常采用把十进制数的每一位分别写成二进制数形式的编码，称为二-十进制编码或BCD 编码。BCD 编码方法很多，通常采用的是8421 编码。其方法是用四位二进制数表示一位十进制数，自左11至右每一位对应的位权分别是8，4，2，1。值得注意的是，四位二进制数有 0000～1111 十六种状态，这里只取了0000～1001 十种状态，而 1010～1111六种状态在这种编码中没有意义。如十进制数864，其BCD进制编码为 100001100100。8 6 4↓ ↓ ↓1000 0110 0100BCD 码有压缩和非压缩两种。上述的编码方法属于压缩BCD 码，特点是用 1 个字节表
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 示2 位BCD码；非压缩 BCD 码用 1 个字节的低 4 位表示 1 位BCD 码，高4 位为0（无意义）。如 13 的压缩BCD码为 0001 0011 ，非压缩 BCD 码为 0000000100000011。【习题演练】1.已知字符0 的ASCII码为48D，用ASCII 码（7 位）表示字符5 和7 是（ ）。12A.0110010 和0110111B.0100011 和0111011C. 1000101和1100011D.0110101 和01101111.【答案】D。解析：ASCII 码表中字符5 和7的码值分别为 53 和 55 ，转换为二进制表示为0110101 和 0110111。2.某数用压缩BCD 码表示为 10010101，其真值为（ ）。A.135B.95C.95HD. 10010101B2.【答案】B。解析：BCD码是二-十进制编码，1001 和0101 分别对应十进制的9 和5，故选择B选项。3.一个 16×16 点阵的汉字要占用（ ）。A.24 个字节13B.32 个字节C.48 个字节D.256 个字节3.【答案】B。解析：16×16 点阵的汉字要用16×16/8=32 个
2025-08-10 14:53:44.015 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 字节。知识点 3、机器数对于数的符号“＋”和“－”，计算机是无法识别的，需要把符号数码化。通常，约定二进制数的最高位为符号位，“0”表示正号，“1”表示负号。这种在计算机中使用的表示数的形式称为机器数，常见的机器数有原码、反码、补码等。（ 一）原码原码表示法是机器数的一种简单的表示法。其符号位用0 表示正号，用 1 表示负号，数值一般用14二进制形式表示。设有一数用X 表示真值，则原码表示可记作[X]原，例如：X1=＋1010110X2=－1001010其原码记作：[X1]原=[＋1010110]原=01010110[X2]原=[－1001010]原= 11001010在原码表示法中，对 0 有两种表示形式：[＋0]原=00000000[－0]原=10000000（ 二）反码机器数的反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。假设有一数用X表示真值，那么X 的反码表示记作[X]反，例如：X1=＋101011015X2=－1001010那么[X1]原=01010110[X1]反=[X1]原=01010110[X2]
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 原=11001010[X2]反=10110101在反码表示法中，对 0 也有两种表示形式：[＋0]反=00000000[－0]反=11111111反码通常作为求补过程的中间形式，即在一个负数的反码的末位上加 1，就得到该负数的补码。（ 三）补码机器数的补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在末位加 1 而得到的。设有一数用X 表示真值，则X 的补码表示记作[X]补，例如：16X1=＋1010110X2= – 1001010那么[X1]原=01010110[X1]补= [X1]原=01010110[X2]原=11001010[X2]补= 10110101+1=10110110在补码表示法中，0 只有一种表示形式：[＋0]补=00000000[－0]补= 11111111＋1=00000000所以有[＋0]补=[－0]补=00000000。【习题演练】1.采用补码表示的 8 位二进制数真值范围是( )。A.- 127～+127B.- 127～+128C.- 128～+12717D.- 128～+1281.【答案】C。
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 解析：补码表示的8 位二进制数真值范围是- 128～+127 ，原码和反码的范围是- 127～+127。2.补码25H 的真值是（ ）。A.25B.-25C.-37D.372.【答案】D。解析：正数的原码、反码与补码都相同。3.在机器中，（ ）的零的表示形式是唯一的。A.原码B.补码C.反码D.原码和反码3.【答案】B。解析：补码零的表示形式唯一，而原码和反码不唯一。18知识点 4、补码溢出（一 ）补码溢出的产生在补码加减运算中，有时会遇到这样的情况：两个正数相加，而结果的符号位却为 1（结果为负）；两个负数相加，而结果的符号位却为0（结果为正）。发生这种错误的原因在于两数相加之和的数值已超过了机器允许的表示范围。字长为n+1 位的定点整数（其中一位为符号位），采用补码表示，当运算结果大于2n- 1 或小于-2n 时，就产生溢出。设参加运算的两数为X、Y，做加法运算：①若X、Y 异号，不会溢出；②若X、Y 同号，运算结果为正且大于所能表示的最大正数或运算结果为负且小于所能表示的最小负数时，产生溢出。将两正数相加产生的溢出称为正溢；反之，两负数相加产生的溢出称为负溢。19（ 二）补码溢出的检测设被操作数为[X]
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 补=XsX1X2…Xn，操作数为[Y]补=YsY1Y2…Yn，其和（差）为[S]补=SsS1S2…Sn，则判断溢出的方法有以下三种：1.采用一个符号位两正数相加，结果为负表明产生正溢；两负数相加，结果为正表明产生负溢。因此可得出采用一个符号位检测溢出的方法：当Xs=Ys=0，Ss=1 时，产生正溢；当Xs=Ys=1，Ss=0 时，产生负溢。2.采用进位位两数运算时，产生的进位为：CsC1C2…Cn，其中：Cs 为符号位产生的进位，C1 为最高数值位产生的进位。两正数相加，当最高有效位产生进位（C1= 1）而符号位不产生进位（Cs=0）时，发生正溢。20两负数相加，当最高有效位没有进位（C1=0）而符号位产生进位（Cs= 1）时，发生负溢。3.采用变形补码（双符号位补码）在双符号位的情况下，把左边的符号位 Ss1 叫做真符，因为它代表了该数真正的符号，两个符号位都作为数的一部分参加运算。这种编码又称为变形补码。双符号位的含义如下：Ss1Ss2=00，结果为正数，无溢出；Ss1Ss2=01，结果正溢；Ss1Ss2=10，结果负溢；Ss1Ss2= 11，结果为负数，无溢出。【习题演练】1.算式65H-3EH 的运算
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结果是否有溢出，结果的真值为（ ）。A.有、39B.有、27C.无、39D.无、27211.【答案】C。解析：65H-3EH=101D-62D=39D，无溢出。知识点 5、寻址方式存储器既可用来存放操作数，又可用来存放指令。当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。因此，寻址方式可以分为数据寻址和指令寻址。寻找操作数的地址称为数据寻址，数据寻址方式较多，其最终目的都是寻找所需要的操作数。寻找下一条将要执行的指令地址称为指令寻址。（ 一）指令寻址指令寻址比较简单，它又可以细分为顺序寻址和跳跃寻址。顺序寻址可通过程序计数器PC 加 1，22自动形成下一条指令的地址；跳跃寻址是程序转移执行时的指令寻址方式，它通过转移类指令实现。跳跃寻址的转移地址形成方式有三种：直接（绝对）、相对和间接寻址，它与数据寻址方式中的直接、相对和间接寻址是相同的，只不过寻找到的不是操作数的有效地址而是转移的有效地址而已。（ 二）数据寻址数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 真实地址称为有效地址，记作 EA，它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如下所示。操作码OP 寻址特征# 形式地址A寻址方式是根据指令中给出的地址码字段寻找真实操作数地址的方式。23指令中的形式地址A—（寻址方式）→有效地址EA1.立即寻址在取指令时，操作码和操作数被同时取出，不必再次访问存储器，从而提高了指令的执行速度，如下图所示。立即寻址的特点是操作数本身设在指令字内，即形式地址A 不是操作数的地址，而是操作数本身，也称立即数。由于操作数是指令的一部分，故立即数的大小将受到指令长度的限制。立即寻址示意图2.直接寻址指令中地址码字段给出的地址A 就是操作数的有效地址：EA=A，如下图所示。直接寻址的缺点在于A 的位数限制了操作数的寻址范围，且必须修改A 的值，才能修改操作数的地址。24直接寻址示意图3.间接寻址指令中给出的地址A 不是操作数的地址，而是存放操作数地址的地址：EA=（A），如下图所示。间接寻址要比直接寻址灵活得多，它的主要优点为：一是扩大了寻址范围，可用指令的短地址访问大的主存空间，二是可将主存单元作为程序的地址指针，用以指示操作数在主存中的位置。当操作数的地址需要改变时，
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 不必修改指令，只需修改存放有效地址的那个主存单元（间接地址单元）的内容就可以了。25一级间接寻址二级间接寻址26除去一级间接寻址外，还有多级间接寻址。多级间接寻址为取得操作数需要多次访问主存，即使在找到操作数有效地址后，还需再访问一次主存才可得到真正的操作数。4.寄存器寻址指令中地址码部分给出某一通用寄存器的编号，所指定的寄存器中存放着操作数，如下图所示。它有两个明显的优点：一是从寄存器存取数据比主存快得多；二是由于寄存器的数量较少，其地址码字段比主存单元地址字段短得多。寄存器寻址示意图5.寄存器间接寻址27寄存器间接寻址示意图指令中的地址码给出某一通用寄存器的编号，被指定的寄存器中存放操作数的有效地址，而操作数则存放在主存单元中，如上图所示。这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数。6.变址寻址把指令给出的形式地址A 与变址寄存器Rx 的内容相加，形成操作数有效地址：EA ＝ A +（Rx），Rx 的内容为变址值，如下图所示。28变址寻址是一种广泛采用的寻址方式，通常指令中的形式地址作为基准地址，而 Rx 的内容作为修改量。在遇到需要频繁修改地址时，无须修改指令，只要修改变址值就可以了
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。变址寻址示意图如要把一组连续存放在主存单元中的数据（首地址是A）依次传送到另一存储区（首地址为B）中去，则只需在指令中指明两个存储区的首地址A和B（形式地址），用同一变址寄存器提供修改量29K，即可实现（A＋K）→B＋K。变址寄存器的内容在每次传送之后自动地修改。7.基址寻址将基址寄存器Rb 的内容与形式地址A 相加，形成操作数有效地址：EA＝（Rb）＋ A，基址寄存器的内容称为基址值，如下图所示。基址寻址示意图工30基址寻址和变址寻址在形成有效地址时所用的算法是相同的，而且在一些计算机中，这两种寻址方式都是由同样的硬件来实现的。但这两种寻址方式应用的场合不同，变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改。8.相对寻址相对寻址是基址寻址的一种变通，由程序计数器PC 提供基准地址，即：EA＝（PC）＋ A，A 是操作数和现行指令之间的相对位置，如下图所示。3132相对寻址示意图相对寻址方式的特点是：操作数的地址不是固定的，
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 它随着PC 值的变化而变化，并且与指令地址之间总是相差一个固定值A。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC 相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。指令中给出的位移量A 可正、可负，通常用补码表示，故对于指令地址而言，操作数地址可能在指令地址之前或之后。9.隐含寻址隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。如一地址指令格式，只给出一个操作数的地址，另一个操作数隐含在累加器ACC 中，故累加器ACC对一地址指令格式来说是隐含地址，如下图所示。33隐含寻址示意图10.堆栈寻址在堆栈寻址的指令字中没有形式地址码字段，它是一种零地址指令。堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组来实现，也可利用主存的一部分空间作堆栈，前者称为硬堆栈，后者称为软堆栈。【习题演练】1. 对某个寄存器中操作数的寻址方式称为( ) 寻址。A.直接B.间接C.寄存器34D.寄存器间接1.【答案】C。解析：操作数在寄存器中的寻址方式为：“寄存器直接寻址”，也叫“寄存器寻址
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ”。当操作数的有效地址在寄存器中时叫“寄存器间接寻址”。2.操作数所处的位置，可以决定指令的寻址方式。操作数的地址在寄存器中，寻址方式为（ ）。A.相对寻址B.直接寻址C.寄存器寻址D.寄存器间接寻址2.【答案】D。解析：操作数包含在指令中的寻址方式为立即寻址；操作数在寄存器中的寻址方式为寄存器寻址；操作数的地址在寄存器中的寻址方式为寄存器间接寻址。3.变址寻址和基址寻址的有效地址形成方式类似，但（ ）。35A.变址寄存器的内容在程序执行过程巾是不能改变的B.基址寄存器的内容在程序执行过程中是可以改变的C.在程序执行过程中，变址寄存器的内容不能改变而基址寄存器的内容可变D.在程序执行过程中，基址寄存器的内容不能改变而变址寄存器的内容可变3.【答案】D。解析：基址寄存器的内容由操作系统确定，而变址寄存器的内容由用户确定，因此基址寄存器的内容不能改变而变址寄存器的内容可变。知识点 6、存储芯片容量的计算存储芯片的容量与地址线的位数、数据线的位数均有关。地址线和数据线的位数共同反映存储芯片的容量。其公式可写为：36存储芯片容量=2A×D位，其中，A 为地址线根数，D 为数据线根数。如地址线为 10 根，数据线为4根
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，则存储芯片容量为 210×4＝4K 位；又如地址线为 14 根，数据线为 1根，则其容量为214×1＝16K 位。【习题演练】1.某DRAM 芯片，其存储容量为512K×8 位，该芯片的地址线和数据线数目为（ ）。A.8，512B.512，8C.18，8D.19，81.【答案】D。解析：512K X8 = 219 X 8，所以地址线和数据线分别为 19 和8。37知识点 7、DRAM 的刷新动态随机存储器刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。DRAM 是靠电容来存储信息的，由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对DRAM 的全部基本单元电路必作一次刷新，一般取2ms（2000μs），这个时间称为刷新周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本电路的逐行刷新，才能保证DRAM 内的信息不会丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。38（ 一）集中刷新集中刷新是在规定的一个刷新周期内，对全部存
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。如对 128×128 矩阵的存储芯片进行刷新，刷新的时间相当于 128 个读周期。若读/写周期为 0.5μs，则对 128 行集中刷新共需 128×0.5 =64μs，其余的 1936μs（=2000－64）用来读/写或维持信息。由于在这 64μs 时间内不能进行读写操作，故称为“死时间”。（ 二）分散刷新分散刷新把对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期分成两段，前半段用来读/写或维持信息，后半段用来刷新。若读/写周期为 0.5μs，则存取周期为 1μs，那么每隔128μs 就可将 128 行的存储芯片全部刷新一遍，但39这比允许的 2ms 间隔要短得多，且存取周期长了，整个系统的速度降低。（ 三）异步刷新前两种方式的集合，既可缩短“死时间”，又充分利用最大刷新间隔为 2ms 的特点。如可在 2ms内对 128 行各刷新一遍，即每隔 15.6μs（2000/ 128）刷新一行，每行的刷新时间仍为 0.5μs，但对每行来说，刷新间隔仍为2ms，“死时间”缩短为0.5μs。【习题演练】1.动态RAM 的刷新是以（ ）为单位进行的
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。A.存储矩阵B.行C.列D.存储单元1.【答案】B。解析：动态RAM 的刷新以行为单位进行。40知识点 8、存储器与 CPU 的扩展连接（一 ）存储容量的扩展由于单片存储芯片的容量总是有限的，很难满足实际的需要，因此，必须将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有位扩展和字扩展。1.位扩展位扩展是指增加存储字长，只在位数方向扩展（加大字长）。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。位扩展组成容量 地址 数据41存储器 64K×8 16 位 8 位存储芯片 64K×1 16 位 1 位如用 64K×1 的SRAM 芯片组成64K×8 的存储器，需要8 个芯片，如上表所示。当CPU 访问该存储器时，其发出的地址和控制信号同时传给8个芯片，选中每个芯片的同一单元，其单元的内容被同时读至数据总线的相应位，或将数据总线上的内容分别同时写入相应单元。2.字扩展字扩展是指增加存储器字的数量，它仅在字数方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。如用 16K×8 的SRAM 组成64K
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ×8 的存储器，需要4 个芯片，如下表所示。字扩展组成容量 地址 数据42存储器 64K×8 16 位 8 位存储芯片 16K×8 14 位 8 位在同一时间内四个芯片中只能有一个芯片被选中。3.字和位同时扩展字和位同时扩展组成容量 地址 数据存储器 64K×8 16 位 8 位存储芯片 16K×4 14 位 4 位字和位同时扩展是指既增加存储字的数量，又增加存储字长。当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展，这将是前两种扩展的组合，实现起来也较为容易。如用16K×4 的SRAM 组成64K×8 的存储器，需要8 个芯片，如上表所示。43（ 二）存储器与 CPU 的连接存储芯片与CPU 芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。1.地址线的连接存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU 地址线的低位与存储芯片的地址线相连。CPU 地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。2.数据线的连接CPU 的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU 
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的数据线数相等。3.读/写命令线的连接CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。4.片选线的连接44片选线的连接是CPU 与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端---cs是否能接收到来自CPU 的片选有效信号。5.合理选择存储芯片合理选择存储芯片主要是指存储芯片类型（RAM 或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM 则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单方便。【习题演练】1.用存储容量为16K×1 位的存储器芯片来组成一个 64K×8 位的存储器，则在字方向和位方向上分别扩展了（ ）倍。A.4 和2B.8 和4C.2 和445D.4 和81.【答案】D。解析：用64K 除以16K等于4，用8 除以1 等于8。2.RAM 芯片并联时可以使（ ）。A.存储器存储字长增加B.存储器地址范围增加C.存储器速度增加D.降低存储器的平均价格2.【答案】A。解析：并联时可以增加存储器的存储字长。知识点 9、死锁死锁是指多个进程在运行过程中因争夺资源而造成
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。如下图所示，有两个资源R1 和R2 供进程P1和P2 共享，P1 已占用资源R1，P2 已占用资源R2，46此时若 P2 继续要求R1,P1 要求R2，则 P1 和 P2 之间便会形成僵局，它们都在等待对方释放自己所需的资源，但同时又不释放自己已占用的资源，从而进入死锁状态。P1R2P2死锁示例（一 ）死锁产生的原因产生死锁的原因可归结为如下两点：1.竞争资源47R1当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。2.进程间推进顺序非法进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。（ 二）死锁产生的必要条件死锁的发生必须具备下列四个必要条件：1.互斥条件指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。2.请求和保持条件指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此48时请求进程阻塞，但又对自己已获得
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的其它资源保持不放。3.不剥夺条件指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。4.环路等待条件指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的P0 正在等待一个P1 占用的资源；P1 正在等待P2 占用的资源，……，Pn正在等待已被P0 占用的资源。（ 三）死锁的处理为保证系统中各进程的正常运行，应事先采取必要的措施，来预防发生死锁。系统已经出现死锁后，则应及时检测到死锁的发生，并采取适当措施来解除死锁。目前，处理死锁的方法可归结为以下四种：1.预防死锁49这是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。2.避免死锁该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。3.检测死锁这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机制，及时地检测出死锁的发
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 生，并精确地确定与死锁有关的进程和资源；然后，采取适当措施，从系统中将已发生的死锁清除掉。4.解除死锁这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱50出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。【习题演练】1.以下各种情况中，属于死锁现象的是（ ）。A.某进程执行了死循环B.某进程为了得到某资源，等待了很长的时间C.某进程为了得到某资源，等待了无限的时间D.操作系统故障1.【答案】C。解析：死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，它们都将无法再向前推进。由死锁概念可知，只有C 选项符合。2.死锁预防是保证系统不进入死锁状态的静态策略，其解决方法是破坏产生死锁的四个必要条件之一。下列方法中破坏了“循环等待”条件的是( )。51A.银行家算法B.一次性分配策略C.剥夺资源法D.资源有序分配法2.【答案】D。解析：资源有序分配法可以破坏“循环等待”条件。3.产生系统死锁的原因可能是由于（ ）。A.进程释放资源B.一个进程进入死循环C.多个进程竞争资源，出现了循环
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 等待D.多个进程竞争共享型设备3.【答案】C。解析：产生系统死锁的原因可能是多个进程竞争资源，从而出现了循环等待。52知识点 10、处理机调度的层次（ 一）作业调度作业调度又称高级调度，或宏观调度，根据某种算法，把外存上处于后备队列中的作业调入内存。（ 二）中级调度中级调度又称中程调度，将那些暂时不能运行的进程调至外存上去等待，此时的进程状态称为挂起状态。中级调度实际上就是存储器管理中的对换功能。（ 三）进程调度进程调度又称低级调度，或微观调度，它决定就绪队列中的哪个进程应获得处理机。53进程调度的方式有两种：非抢占方式和抢占方式。抢占方式基于的原则有三个：优先权原则、短作业/进程优先原则、时间片原则。【习题演练】1.操作系统中的高级调度是指（ ）。A.线程调度B.作业调度C.进程内、外存交换调D.进程调度1.【答案】B。解析：高级调度又称为作业调度、宏观调度或者长程调度，其主要任务是按照一定的原则从外存上处于后备状态的作业中选择一个或者多个，给它们分配内存、输入输出设备等必要的资源，并建立相应的进程，以使作业具有获得竞争处理器的权利。2.CPU 的调度分为高级、中级和低级三种，其中低级调度是指（ ）调度。5
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4A.作业B.交换C.进程D.线程2.【答案】C。解析：进程调度又称低级调度。知识点 11、调度算法（ 一 ）先来先服务调度算法先来先服务（First Come First Served，FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS 算法比较有利于长作业（进程），而不利于短作业（进程）。（ 二）短作业/进程优先调度算法短作业 / 进程优 先调度算法（ShortestJob/Process First，SJ/PF），是指对短作业或短进程55优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。需要注意的是短进程优先调度算法中，每次选择的是已进入系统的、要求服务时间最短的进程。SJ/PF 调度算法的缺点在于：该算法对长作业不利；完全未考虑作业的紧迫程度，因而不能保证紧迫性作业/进程会被及时处理；由于
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 作业/进程的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。56（ 三 ）高优先权优先调度算法作为作业调度算法，此算法常被用于批处理系统中，作为进程调度算法，还可用于实时系统中。对于最高优先权优先调度算法，其关键在于：它是使用静态优先权，还是用动态优先权，以及如何确定进程的优先权。1.静态优先权静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。确定进程优先权的依据：进程类型、进程对资源的需求和用户需求。2.动态优先权动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。动态优先权的变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间57= 响应时间/要求服务时间= 响应比这种算法即为高响应比优先调度算法（HighestResponse-ratio Next，HRN），它既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折中。但每次要进行调度之前，都须先做响应比的计算，这会增加系统开销。
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: （ 四 ）基于时间片的轮转调度算法1.时间片轮转法其基本思想是为每一个进程分配一个时间段，该时间段被称为时间片，即允许该进程运行的时间。每个进程只能依次循环轮流运行，如果时间片结束时进程还在运行，CPU 将剥夺该进程的使用权转而将CPU 分配给另一个进程。如果进程在时间片结束之前阻塞或结束，CPU 当即进行切换。为了实现进程的循环执行，将每次被中止运行的进程存入就绪58队列的末尾，同时将CPU 分配给就绪队列中的队首进程。该算法是一种简单而又公平的算法，使用非常广泛。2.多级反馈队列调度算法前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。【习题演练】1.为了对紧急进程或重要进程进行调度，调度算法应采用（ ）。A.先进先出调度算法B.优先数法59C.最短作业优先调度D.定时轮转法1.【答案】B。解析：为了对紧急进程或重要进程进行调度，可遵
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 循优先权准则，采用优先数法。2.按照作业到达的先后次序调度作业，排队等待时间最长的作业被优先调度，这是指（ ）调度算法。A.先来先服务B.最短作业优先C.定时轮转法D.优先数法2.【答案】A。解析：先来先服务按作业进入的先后次序安排。优点是实现简单，缺点是不利于运行时间短的作业。3.以下（ ）调度算法对CPU 繁忙型进程有利。A.FCFSB.时间片轮转60C.多级反馈队列D.短进程优先3.【答案】A。解析：CPU 繁忙型进程占用CPU时间比较多，更接近于长进程，故选A，FCFS 算法有利于长进程。知识点 12、内存的连续分配连续分配方式，是指为一个用户程序分配一个连续的内存空间。它又可进一步分为：单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配四种。（ 一）单一连续分配单一连续分配是最简单的一种存储管理方式，只能用于单用户、单任务的操作系统中。它将内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除61系统区以外的全部内存空间，提供给用户使用，其中仅能存放一道作业。（ 二）固定分区分配固定分区分配是最早的多道程序的存储管理方式，是指系统先把内存划分成若干个
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 大小固定的分区，一旦划分好，在系统运行期间便不再重新划分。为了满足不同程序的存储需求，各分区的大小可以不等，也可以相等，但在每个分区中只装入一道作业。采用固定分区分配方法存在以下缺点：（1）由于预先规定了分区的大小，使得大作业无法装入，用户不得不采取其他技术加以补救，增加了用户的负担；（2）内存利用率不高，作业很少能恰好填满分区；（3）固定分区无法实现动态扩充内存空间的要求；62（4）由于分区个数在系统初启时确定，因此会限制多道运行的程序个数，特别不适于分时系统交互型用户及内存变化很大的情形。（ 三）动态分区分配动态分区分配算法根据进程的实际需要，动态地分配内存空间。在实现可变分区分配时，涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作三个问题。常用的分配算法主要有以下几种：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。1.首次适应算法该算法将空闲分区按起始地址递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，直至找到第一个能满足要求的空闲分区为止，并按作业的大小从该分区中分割出一块内存空间分配给请求者，剩余的部分仍留在空闲分区表63或链中。该算法优先使用内存低
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 址部分的空闲分区，从而能在高址部分保留较大的空闲分区，但它会在内存的低端留下很多难以利用的小空闲分区，而每次分配时，对空闲分区的查找都必须经过这些分区，从而会增加查找的开销。2.循环首次适应算法该算法由首次适应算法演变而成，每次分配均从上次分配的位置之后开始查找，并将第一个能满足要求的空闲分区分割并分配出去。其特点是内存中的空闲分区分布得更均匀，从而减少查找空闲分区的开销，但它会使存储器中缺乏大的空闲分区。3.最佳适应算法该算法将空闲分区按大小递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，并将第一个能满足要求的空闲分区分割并分配出去。该算法尽管被称为“最佳”，但情况并非总是如此，因为每次分配后所切割下来的剩余部分总64是最小的，它会在内存中留下大量难以利用的小空闲分区。4.最坏适应算法该算法将空闲分区按大小递减的次序排列。当作业申请一个空闲区时，先检查空闲分区链（表）的第一个空闲区是否大于或等于所要求的内存长度，若该空闲区长度小于要求，则分配失败，否则分配相应的存储空间给用户，然后修改和调整空闲分区链（表）。该算法的优点是产生碎片的几率最小，缺点主要是使内存中缺乏大的空闲区。（四 ）可重定
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 位分区分配在动态分区分配方式中，经过一段时间的分配和回收后，内存中会产生很多小的空闲分区。此时，可能有用户程序因找不到足够大的空闲分区而难以装入，但所有空闲分区容量的总和却足以满足该程序的要求。65上述这些不能被利用的空闲分区可采用以下办法加以解决：将内存中的所有作业进行移动，从而将原来分散的多个空闲分区移到同一处拼接成一个大的空闲分区，以装入用户的作业。这种技术被称为“拼接”或“紧凑”。可重定位分区分配方式就是在动态分区分配方式的基础上增加紧凑功能，即在找不到足够大的空闲分区、而空闲分区总和却能满足用户的要求时，对内存空间进行紧凑。由于紧凑时，作业要在内存中移动位置，因此，它需要得到动态重定位技术的支持，这也是它被称为动态重定位分区分配的原因。【习题演练】1.分区存储管理中的首次适应算法，要求把空闲区按照（ ）的次序登记在空闲区表中。A.大小递减B.大小递增C.地址递减66D.地址递增1.【答案】D。解析：首次适应算法要求对空闲分区按地址从小到大的顺序排列。2.可重定位内存的分区分配目的为（ ）。A.解决碎片问题B.便于多作业共享内存C.回收空白区方便D.便于用户干预2.【答案】A。解析：可重定位内存的分区
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 增加了紧凑的功能，通常在找不到足够大的空闲分区来满足用户需求时使用，解决了碎片问题。3.在以下存储管理方案中，不适用于多道程序设计系统的是（ ）。A.单一连续分配B.固定式分区分配C.可变式分区分配D.页式存储管理673.【答案】A。解析：单一连续分配只能用于单用户、单任务的操作系统。知识点 13、基本的分页存储管理在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。（ 一）页面与页表基本的分页存储管理方式中，系统将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。相应地，将内存空间分成若干个与页面同样大小的块，称为物理块或页框。内存的分配以块为单位，并允许将一个进程的若干页分别装入到多个不相邻的物理块中。68为了地址映射的方便，页面的大小通常设置成2 的幂。如果页面的大小为2k 字节，逻辑地址的长度为 n 位，则分页系统的地址结构如下图所示，可将线性的逻辑地址分成两部分：右边的 k 位为页内位移量（即页内地址）W，左边的n-k 位为页号P。n-1 k k-1 0页号P 位移量W分页地址中的地址结构在进
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 程运行时，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页面映射表，简称页表，进程的每个页占页表的一个表项，其中记录了相应页对应的内存块的块号，以及用于分页保护的存取控制信息。下图给出了分页系统的一个内存分配实例，其中页面大小为4K，用户作业的大小为11K。由于进程的最后一页不足一块，因此造成了存放该页的物69理块中部分空间的浪费，这部分被浪费的空间被称为“页内碎片”。分页系统中的内存分配（ 二）地址变换机构页式存储管理系统中，逻辑地址到物理地址的转换是在进程执行的过程中，由硬件地址变换机构借助于页表自动进行的。1.基本的地址变换机构通常将作业的页表存放在内存中，而在系统中只设置一个页表寄存器PTR（Page-Table Register），当一进程因CPU 调度而转入执行状态时，其页表的70内存始址和长度将从该进程的 PCB 中装入页表寄存器。当进程要访问某个逻辑地址中的指令或数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号大于或等于页表长度，便产生越界中断，否则便以页号为索引去检索页表，从中得到该页的物理块号，送入物理地址寄存
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与页内地址拼接，形成对应的物理地址。2.具有快表的地址变换机构由于页表存放在内存中，故CPU 每存取一个指令或数据时都要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次才根据物理地址存取指令或数据，这使得计算机的处理速度降低近1/2。为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”或“快表”，用以存放当前访问的那些页表项。71在进行地址转换时，地址变换机构自动将逻辑地址中的页号并行地与快表中的所有页号进行比较，若其中有与此相匹配的页号，便可直接从快表中读出该页对应的物理块号，并送到物理地址寄存器中。如果在快表中未找到对应的页号，则仍需访问内存中的页表来进行地址转换，同时还必须将得到的页表项与页号—起装入到快表中，若快表已满，则还需根据置换算法淘汰某个快表项，以装入新的内容。（ 三）多级页表现代的大多数计算机系统都支持非常大的逻辑地址空间，此时，页表就变得非常大，要为它分配一大段连续的内存空间将变得十分困难。对于该问题，可利用将页表进行分页，并离散地将各个页表存放到内存块中的办法加以解决，此时，必须为离散分配的页表再建立一张页表，称为外层
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 页表，用来记录存放各页表页的内存块号，从72而形成了两级页表。在使用两级页表的分页系统中，每次访问一个数据需访问三次内存，故同样需增设快表来有效地提高访问速度。如果外层页表仍十分大，则可以将它再进行分页，并离散地存放到内存中，然后再通过一张第二级的外层页表来记录存放各外层页表页的内存块号，这样，便形成了三级页表，并可进一步形成更多级的页表。【习题演练】1.碎片现象的存在使得（ ）。A.内存空间利用率降低B.内存空间利用率提高C.内存空间利用率得以改善D.内存空间利用率不影响1.【答案】A。解析：碎片会占用计算机的内存，使部分内存空间不能满足程序运行的最低标准，从而不能被使用，降低内存的使用效率。732.基本分页存储管理中，若没有引入快表，则每次从主存取指令或取操作数，要（ ）访问主存。A.1 次B.2 次C.3 次D.4 次2.【答案】B。解析：要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次根据物理地址存取指令或操作数。知识点 14、基本的分段存储管理用户通常喜欢将自己的作业按逻辑关系划分成若干段，然后通过段名和段内地址来访问相应的程序或数据，还希望能以段为单位对程序和数据进行共享和保护，并
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 要求分段能动态增长。分页系统虽然能较好地解决动态分区的碎片问题，却难以满足74用户的上述要求，因此又引入了分段式存储管理方式。在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如主程序段、子程序段、数据段等。每个段都有自己的名字，都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，故各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，即其逻辑地址由段号和段内地址所组成。分段地址中的地址具有如下图的结构：段号 段内地址31 16 15 0分段地址中的地址结构在该地址结构中，允许一个作业最长有64K个段，每个段的最大长度为64KB。75（ 一）段表在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地放入内存不同的分区。系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，但更常多的是放在内存中。在配置了段表后，执行中的进程可通过查找段表找到每个段所对应的内存区。故段表是用于实现从逻辑段到物理内存区的映射。（ 二）地址变换机
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 构为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放正在执行进程的段表始址和长度。在进行地址转换时，地址变换机构将逻辑地址中的段号与段表寄存76器中的段表长度进行比较，若段号不小于段表长度，便产生越界中断；否则便以段号为索引去检索段表，从中得到该段的基址和长度；接着检查段内地址是否超过段长，若超过，则发出越界中断信号；若未超过，则将该段的基址与段内地址相加，从而得到对应的物理地址。（ 三 ）分页和分段的主要区别分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换，这是它们的相同之处，其不同主要表现在以下三个方面：①页是信息的物理单位，分页是为提高内存的利用率；段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。②页的大小固定且由系统决定，在系统中只能有一种大小的页面；而段的长度却不固定，取决于用户所编写的程序，通常由编译程序在编译时，根据信息的性质来划分。77③分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。（ 四）
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 段页式存储管理方式为了既能像分页系统那样有效地利用内存，又能像分段系统那样满足用户多方面的需要，操作系统中又引入了段页式存储管理方式。段页式系统的基本原理，是先将用户程序分成若干个段，再把每个段分成若干个页。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成。在段页式系统中，为获得一条指令或数据须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中78取出该页所在的物理块号，并将该块号与页内地址一起形成物理地址；第三次访问是取指令或数据。【习题演练】1.页是（ ）单位，由（ ）划分，它的长度（ ）。A.逻辑，系统，定长B.逻辑，用户，不定长C.物理，用户，不定长D.物理，系统，定长1.【答案】D。解析：页是物理单位，由系统划分，它的长度固定。2.下列方法中，解决碎片问题最好的存储管理方法是（ ）。A.基本页式存储管理B.基本分段存储管理C.固定大小分区管理D.不同大小分区管理792.【答案】A。解析：离散分配方式将一个作业离散地存放到内存中，从而使系统无须紧凑便能很好地解决碎片问题，而离散分配方式中，分页是为解决碎片问题，提高内存的利用率，分段的目的则是为了
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 能更好地满足用户的需要，故选A。3.分段管理提供（ ）维的地址结构。A.1B.2C.3D.43.【答案】B。解析：分段存储管理的地址空间是二维的，标识一个地址时，既需给出段名，又需给出段内地址。80知识点 15、虚拟存储器（一）局部性原理程序局部性原理是指程序在执行时将呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。局限性还表现在下述两方面：1.时间局限性如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。2.空间局限性一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。81基于局部性原理产生了虚拟存储器。（ 二）虚拟存储器的实现虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。虚拟存储器的实现，建
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 立在离散分配的存储管理方式的基础上。目前，所有的虚拟存储器都是采用下述方式之一实现的：1.请求分页系统在分页系统的基础上，增加了请求调页功能和页面置换功能，便形成页式虚拟存储系统。它允许只装入少数页面的程序及数据，便启动运行。之后再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。822.请求分段系统在分段系统的基础上，增加了请求调段及分段置换功能后，便形成段式虚拟存储系统。它允许只装入少数而非所有段的用户程序和数据，即可启动运行。之后再通过调段功能和段的置换功能将暂不运行的段调出，同时调入即将运行的段。（ 三）虚拟存储器的特征虚拟存储器具有多次性、对换性和虚拟性三大主要特征。1.多次性多次性是指虚拟存储器将一个作业分成多次调入内存。多次性是虚拟存储器最重要的特征，任何其它的存储管理方式都不具有这一特征。2.对换性在作业运行期间，虚拟存储器允许将内存中暂时不能运行的进程或暂时不用的程序或数据，调出到外存上，以便腾出足够的内存空间，再把具备运83行条件的进程或进程所需要的程序和数据调入内存。如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。这种对换被
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。而相应的，如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。它们是实现虚拟存储器的基础。3.虚拟性虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。虚拟性是实现虚拟存储器的最重要的目标。虚拟性是以多次性和对换性为基础的，仅当系统允许将作业分多次调入内存，并能将内存中暂时不运行的程序和数据换至盘上时，才有可能实现虚拟存储器；而多次性和对换性又必须建立在离散分配的基础上。84（ 四 ）请求分页存储管理方式请求分页系统是建立在基本分页存储管理基础上的，增加了请求调页功能和页面置换功能。请求分页便成为目前最常用的一种实现虚拟存储器的方式。为了确定所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：1.预调页策略如果进程的许多页是存放在外存的一个连续区域中，则一次调入若干个相邻的页，会比一次调入一页更高效些。但如果调入的一批页面中的大多数都未被访问，则又是低效的。可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。这种策
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。2.请求调页策略85当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由OS 将其所需页面调入内存。由请求调页策略所确定调入的页，是一定会被访问的，再加之请求调页策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。【习题演练】1.实现虚拟存储器的目的是（ ）。A.实现存储保护B.实现程序浮动C.扩充辅存容量D.扩充主存容量1.【答案】D。解析：实现虚拟存储器的目的是为了扩充主存容量。2.虚拟存储器的最大容量是由（ ）决定的。A.计算机系统的地址结构和外存空间B.页表长度86C.内存空间D.逻辑空间2.【答案】A。解析：虚存容量不是无限的，最大容量受外存可利用的总容量和计算机总线地址结构的限制。3.具有虚拟存储功能的管理方法包括（ ）。A.可变分区存储管理B.分页式存储管理C.请求分段存储管理D.段页式存储管理3.【答案】C。解析：虚拟存储功能涉及内存的存储空间扩充问题。请求分段存储管理：作业可以装入不连续的存储空间中，且作业不要求全部装入内存就可以运行，因此具有空间扩充功能；段页式存储管理：作业虽然可以装入不连续
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的存储空间中，但是作业仍要求全部装入才可运行，因此不具备空间扩充功能。87知识点 16、页面置换算法置换算法的好坏直接影响系统的性能。若采用的置换算法不合适，可能出现这样的现象：刚被换出的页，很快又被访问，为把它调入而换出另一页，之后又访问刚被换出的页……如此频繁地更换页面，以致系统的大部分时间花费在页面的调度和传输上。此时，系统看起来很忙，但实际效率却很低。这种现象称为“抖动”。好的页面置换算法能够适当降低页面更换频率（减少缺页率），尽量避免系统“抖动”。为评价一个算法的优劣，可将该算法应用于一个特定的存储访问序列上，并且计算缺页数量，存储访问序列也叫页面走向。（一）最佳（OPT）置换算法最佳置换算法（Optimal，OPT）是选择不再访问的页面或者是在未来最长时间内不再被访问的页88面予以淘汰。最佳页面置换算法是在理论上提出的一种算法，具有最好的性能，但实现是困难的，因为它需要人们预先知道一个进程在整个运行过程中页面走向的全部情况。不过，这个算法可用来衡量其他算法的优劣。（ 二 ）先进先出（FIFO） 页面置换算法FIFO 算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰，该算法的
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 出发点是最早调入内存中的页面，其不再被使用的可能性会比较高。其实现简单、直观，对按线性顺序访问的程序比较合适，面对其他情况则效率不高，因为经常被访问的页面，往往在内存中因停留得最久而被淘汰。一般而言，对于任一作业或进程，如果给它分配的内存页面数越接近于它所要求的页面数，则发生缺页的次数会越少。在极限情况下，这个推论是成立的，如果给一个进程分配了它所要求的全部页89面，则不会发生缺页现象。但是，使用 FIFO 算法时，在给进程或作业分配满足它所要求的页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为Belady 现象。（ 三）最近最久未使用（LRU） 置换算法LRU 算法是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能以“最近的过去”作为“最近的将来”的近似，选择在最近一段时间里最久没有使用过的页面予以置换。因此，LRU 算法是与每个页面最后使用的时间有关的，当必须置换一个页面时，LRU 算法选择过去一段时间内最久未使用的页面。LRU 置换算法是一种比较好的算法，但需要硬件的支持：移位寄存器或栈。关于确定最后使用时间的问题，对于移位寄存器而言，当进程访
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 问某物理块时，要将相应寄存器的位置成“1”。此时，定时信号将每隔一定时间将90寄存器右移一位。如果把 n 位寄存器的数看做是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。对于栈而言，每当访问一个页面时，便将它的页面号从栈中移出，压入栈顶。因此栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。（ 四）Clock 置换算法LRU 算法是较好的一种算法，但它要求有较多的硬件支持，故在实际应用中大多采用LRU 的近似算法。Clock 算法就是用得较多的一种LRU 近似算法。Clock 置换算法采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的表针，指向可能要淘汰的页面。它在存储分块表的每一表项中增加一个访问位，操作系统定期地将它们置为 0。当某一页被访问时，由硬件91将该位置为 1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0 后还未使用过，可把该位是0 的页淘汰出去，因为在最近一段时间里它未被访问过。由于该算法是循环地检查各页面的使用情况，故称为Clock 算法。但因该算法只有一位访问位，只能用它表示该页是否已经使
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用过，而置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法（Not Recently Used，NRU）。【习题演练】1.在请求调页中可采用多种置换算法，其中LRU 是（ ）置换算法。A.最佳B.最近最久未用C.最近未用D.最少使用921.【答案】B 。解析：LRU 是最近最久未用置换算法。2.Clock 置换算法又称为（ ）。A.最久驻留置换算法B.最近最久未使用置换算法C.最近未使用置换算法D.最少使用置换算法2.【答案】C。解析：最近未使用算法是Clock置换算法。知识点 17、线性表（ 一）概念线性表是最基本、最简单、也是最常用的一种数据结构。线性表是具有n （n≥0）个类型相同的数据元素组成的有限序列。93线性表的长度：线性表中元素的个数。空表：长度为0 的线性表。（ 二）特点线性表中一定存在唯一的“第一元素”。线性表中一定存在唯一的“最后元素”。除最后一个元素之外，均有唯一的后继（后件）。除第一个元素之外，均有唯一的前驱（前件）。（ 三）表示方式1.线性表的顺序表示线性表中的数据元素是用一组地址连续的存储单元依次存储的。顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。942.线性表的链式表示（1）线性链表用一组任意的存储单元存储线性表的数据元素，存储单元不一定是连续的，可以连续，也可以不连续。（2）循环链表循环链表中最后一个结点的后继指针指向头结点，使整个链表形成一个环形。（3）双向链表在双向链表中，每个结点有两个指针域，一个指向它的直接后继，另一个指向它的直接前驱。【习题演练】1.下列有关线性表的叙述中，正确的是（ ）。A.线性表中的元素之间是线性关系B.线性表中至少有一个元素C.线性表中任何一个元素有且仅有一个直接前驱95D.线性表中任何一个元素有且仅有一个直接后继1.【答案】A。解析：线性表可以为空，并且线性表中的第一个结点是没有前驱结点的，最后一个结点没有后继结点。知识点 18、栈和队列（ 一）栈的定义1.栈的定义栈是一种只能在一端进行插入或删除操作的线性表。栈中的数据元素是线性关系。栈顶：允许进行插入或删除操作的一端。栈底：不允许进行插入和删除操作，固定不变的一端。入栈：栈的插入操作。出栈：栈的删除操作。962.栈的
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 特点先进后出（First In Last Out，简称FILO）、后进先出（Last In First Out，简称LIFO）。3.栈的存储结构（1）顺序栈使用顺序存储结构存储栈。（2）链式栈使用链式存储结构存储栈。（ 二）队列的定义1.队列的定义97队列是一种运算受限制的线性表，元素的添加在表的一端进行，而元素的删除在表的另一端进行。队头：允许删除元素的一端。队尾：允许添加元素的一端。入队：向队列添加元素。出队：从队列中删除元素。2.队列的特点先进先出（FIFO）（先入队的元素先出队，后入队的元素后出队）。3.存储结构顺序队：使用顺序存储结构的队列。链队：使用链式存储结构的队列。98【习题演练】1. 下述有关栈和队列的区别，说法错误的是( )。A.栈是限定只能在表的一端进行插入和删除操作B.队列是限定只能在表的一端进行插入和在另一端进行删除操作C.栈和队列都属于线性表D.栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（n）1.【答案】D。解析：栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（1）。因为都是在端点处进行的操作。2.为解决计算机主机与打印机之间速度不匹配问题，
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是( )。99A.栈B.队列C.树D.图2.【答案】B。解析：主机将数据依次写入，打印机依次取出，应该属于先进先出的特点，既使用的逻辑结构是队列。知识点 19、树（ 一）定义树形结构是一种重要的非线性结构，树是n 个结点的有限集合，在任一棵非空树中：（1）有且仅有一个称为根的结点。（2）其余结点可分为m 个互不相交的集合，而且这些集合中的每一集合都本身又是一棵树，称为根的子树，因此树是递归结构。100（ 二）基本术语结点：包含一个数据元素及若干指向其子树的分支。结点的度数：结点的非空子树个数。树的度：树中各节点中度的最大值。分支结点：度不为0 的结点。叶子结点：度为0 的结点。孩子：结点的子树的根。双亲：结点的直接前驱。兄弟：同一个双亲的孩子之间互为兄弟。堂兄弟：双亲在同一层的结点互为堂兄弟。祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。子孙：以某结点为根的子树中的所有结点，都是该结点的子孙。层次：从根开始，根为第一层，根的孩子为第二层，以此类推。101树的深度（或者高度）：树
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 中结点的最大层数。结点的深度和高度：结点的深度是从根结点算起的，根结点的深度为 1；结点高度是从最底层的叶子结点算起的，最底层叶子结点的高度为 1。有序树：子树按照一定的次序从左向右排列，相对次序不能随意变换。无序树：子树无一定的次序排列，相对次序可以随意变换。丰满树：即理想平衡树，要求除最底层外，其他层都是满的。森林：是由零个或多个不相交的树所组成的集合。【习题演练】1.如果在数据结构中每个数据元素只可能有一个直接前驱，但可有多个直接后继，则该结构是( )。A.栈102B.队列C.树D.图1.【答案】C。解析：树结构的每个结点都有一个前驱，但可以有多个后继。知识点 20、二叉树（ 一）定义二叉树是一个连通的无环图，并且每一个顶点的度不大于 2。有根二叉树还要满足根结点的度不大于 2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2 个子结点。（ 二）主要性质①二叉树的第 i 层上至多有2i- 1 个结点。②深度为k 的二叉树至多有2k- 1 个结点。103（补充概念：a.满二叉树：深度为k，有2k- 1 个结点。b.完全二叉树：给满二叉树的结点编号，从上至下，从左至右，n 个结点的完全二叉树中结点在对应
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 满二叉树中的编号正好是从 1 到n。③叶子结点 n0，度为2 的结点为n2，则n0 =n2+1。④n个结点的完全二叉树深度为 l㎀ g2n」+1。⑤n 个结点的完全二叉树，结点按层次编号。a.i 的双亲是1 n/2，如果i =1时为根（无双亲）。b.i 的左孩子是2i，如果2i>n，则无左孩子。c.i 的右孩子是2i + 1，如果2i + 1>n 则无右孩子。（ 三）存储结构1.顺序存储结构顺序存储结构即用一个数组来存储一棵二叉树，这种存储方式最适合于完全二叉树，用于存储104一般二叉树则会浪费大量的存储空间。将完全二叉树中的结点值按编号依次存入一个一维数组中，即完成了一棵二叉树的顺序存储。例：结点 A B C D E数组下标 0 1 2 3 4 52.链式存储结构二叉树中的每个结点用一个链结点来存放，结点结构如下：lchild data rchild其中，data 表示结点数据域，用于存储对应的数据元素；lchild 和 rchild 分别表示左指针域和右指针域，分别用于存储左孩子结点和右孩子结点的位置。（ 四）遍历算法若以L、D、R 分别表示遍历左子树、遍历根结点和遍历右子树，则有六种遍历方案：DLR、L
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: DR、LRD.DRL、RDL、RLD。若规定先左后右，则只有105前三种情况，分别是：DLR--先（根）序遍历；LDR--中（根）序遍历；LRD--后（根）序遍历。【习题演练】1.设非空二叉树中度数为0 的结点数为n0，度数为 1 的结点数为n1，度数为2 的结点数为n2，则下列等式成立的是（ ）。A.n0=n1+n2B.n0=2n1+1C.n0=n2+1D.n0=n1+11.【答案】C。解析：二叉树中度为0 的结点个数等于度为2 的结点个数加一。2.一棵树高为k 的完全二叉树至少有（ ）个结点。A.2k- 1B.2k- 1- 1C.2k- 1106D.2k2.【答案】C。解析：完全二叉树层次最小为k时，前k- 1 层都是满的，第k 层有一个结点。3.深度为 5 的完全二叉树的结点数不可能是( )。A.15B.16C.17D.183.【答案】A。解析：深度为5 的完全二叉树结点最多为二的 5 次方减一个，即31 个，最少为 16个。4.二叉树的先序遍历和中序遍历如下：先序遍历：EFHIGJK，中序遍历：HFIEJKG，则二叉树根结点为（ ）。A.EB.FC.G107D.H4.【答案】A。解析：先序遍历顺序为根
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 左右，所以树根为E。知识点 21、图（ 一）图的定义图是由顶点集V 和集合E（边的集合）组成的，可以定义为G=（V，E）。V 是顶点的非空有穷集合，E 是可空的边的有穷集合。（ 二）图的术语1.无向图对于一个图，若每条边都是没有方向的，则称该图为无向图。如下图：108对于此无向图，(Vi，Vj)和(Vj，Vi)表示的是同一条边。无向图的顶点集和边集分别表示为：V(G)={V1，V2，V3，V4，V5}E(G)={(V1，V2)，(V1，V4)，(V2，V3)，(V2，V5)，(V3，V4)，(V3，V5)，(V4，V5)}2.有向图对于一个图，若每条边都是有方向的，则称该图为有向图。如下图：109在此有向图中，<Vi，Vj>和<Vj，Vi>是两条不同的有向边。有向边又称为弧。终端点也称为弧头，初始点也称为弧尾。有向图的顶点集和边集分别表示为：V(G)={V1，V2，V3}E(G)={<V1，V2>，<V2，V3>，<V3，V1>，<V1，V3>}3.无向完全图和有向完全图具有n(n- 1)/2 条边的无向图为无向完全图。具有n(n- 1)条边的有向图称为有向完全图。4.稀疏图有很少条边或弧的图。5.稠密图有很
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 多条边或弧的图1106.顶点图中的数据元素通常称为顶点。7.顶点的度无向图中，顶点的度表示以该顶点作为端点的边的数目。有向图中，顶点的度分为入度和出度。入度表示以该顶点为终点的边的数目，出度是以该顶点为起点的边的数目，该顶点的度等于其入度、出度之和。8.回路、环指一条路径的起点和终点为一个顶点。9.连通图在无向图中，如果从顶点v1 到顶点v2 有路径，则称v1 和v2 是连通的。如果图中任意两个顶点都是连通的，则称图是连通图。10.连通分量指的是无向图中的极大连通子图。11.强连通图111在有向图G 中，对任意一对顶点vi 和vj（vi≠vj），若从vi 到vj 和从vj 到vi 都存在路径，则称G 是强连通图。12.强连通分量有向图中的极大强连通子图称为有向图的强连通分量。（ 三）遍历算法从图的某一顶点出发，访问图中其余顶点，且使每个顶点仅被访问一次，这一过程称为图的遍历。图的遍历分为深度优先搜索遍历和广度优先搜索遍历。1.广度优先广度优先搜索类似于树的按层次遍历。选取图中任意一个顶点Vi作为出发点，按照下列步骤遍历图。（1）首先访问出发点Vi。112（2）接着依次访问Vi的所有未被访问过的邻接点Vi1，V
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: i2，Vi3，ⅆ , Vit并均标记为已访问过。（3）然后再按照Vi1，Vi2，ⅆ , Vit的次序，访问每一个顶点的所有未被访问过的顶点，并均标记为已访问过。（4）依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。2.深度优先深度优先搜索（DFS）类似于树的先序遍历。【习题演练】1.具有n 个结点的连通图至少有（ ）条边。A.n-1B.nC.n（n- 1）/2D.2n1.【答案】A。解析：具有n 个结点的连通图至少有n-1 条边。1132.在有向图中每个顶点的度等于该顶点的( ) 。A.入度B.出度C.入度与出度之和D.入度与出度之差2.【答案】C。解析：有向图的某个顶点v，把以 v 为终点的边的数目称为v 的入度；以v 为始点的边的数目称为v 的出度；v 的度则定义为该顶点的入度和出度之和。3.设连通图G 中的边集E={（a，b），（a，e），（a，c），（b，e），（e，d），（d，f），（f，c）}，则从顶点a 出发可以得到一种深度优先遍历的顶点序列为（ ）。A.abedfcB.acfebdC.aebdfcD.aedfcb1143.【答案】A。图的深度优先遍历类似于树的前序遍历。采
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用的搜索方法的特点是尽可能先对纵深方向进行搜索。知识点 22、数据模型（ 一）数据模型的概念数据模型是对现实世界数据特征的抽象。也就是说，数据模型是用来描述数据、组织数据和对数据进行操作的。（ 二）两类数据模型在数据库中模型主要分为两大类：一类为概念模型；另一类为逻辑模型和物理模型。概念模型也称为信息模型，在数据库设计阶段，由设计员按照用户观点建模实现对现实世界的概念抽象。115http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8656077逻辑模型包括网状、层次、关系和对象模型等，由设计人员按照计算机观点建模实现概念模型到适应某DBMS 的逻辑模型的转变。再由DBMS 完成逻辑到物理模型的转变。物理模型是数据最底层的抽象，描述数据的存储方式和方法。（ 三 ）现实世界的数据化过程现实世界 信息世界 数据世界概念模型现实世界的数据化过程【习题演练】1.常见的逻辑模型有3 种，它们是（ ）。A.字段名、字段类型和记录116DBMS支持下的数据模型事物本身B.层次、关系和网状C.环状、层次和关系D.网状、关系和语义1.【答案】B。解析：常见的数据模型有3 
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 种，即按图论理论建立的层次结构模型和网状结构模型以及按关系理论建立的关系结构模型。知识点 23、概念模型概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有利工具，也是数据库设计人员和用户之间进行交流的语言。（ 一）常用术语1.实体117客观存在并且可以区分的具体事物或者抽象概念。例如，一个学生、一个宿舍、一个操作流程等等。2.属性属性是对客观事物特征的一种反映，是实体具有的某个特征。例如，学生实体中有学号属性、姓名属性、性别属性，年龄属性、所在系属性等。属性有属性名称和属性值之分，例如，姓名为属性名，则“李白”就是这个属性的值。3.码在现实生活中，实体是可以互相区分的，所以没有两个完全相同的实体，即不能够有两个实体在各自对应属性上的属性值都是相同的。4.域一个属性的取值范围被称为域。例如，性别属性的属性值只能为“男”或者只能为“女”。5.实体型118实体集的名称及其所有属性名的集合称为实体型。例如，学生（学号，姓名，性别，年龄，所在系）就是学生实体集的实体型。6.实体集所有属性名完全相同的实体集合在一起，称为实体集。比如说学生实体集，教师实体集等。（ 二）概念模型
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的表示方法：实体-联系图E-R 图中文称为实体-联系图，它是概念模型中的一种表示形式。E-R 图主要包含三个概念，分别是：实体集、联系集和属性。1.实体-联系图的表示方法实体型：用矩形表示，矩形框内写明实体名。属性：用椭圆表示，并用无向边将其对应的实体型连接起来。联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或者M：N）。1192.联系两个实体集之间的联系可归纳为以下三类：（1）一对一联系（1:1）如果对于实体集A 中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A 与实体集B 具有一对一关系，记为 1：1。例如，一个学校只能有一个校长；一个账号只能提供给一个人使用等。（2）一对多联系（1：N）和多对一联系（N：1）如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集B 中的每一个实体，实体集A 中至多只有一个实体与之联系，则称实体集A 与实体集B 有一对多的联系，记为 1：n。例如，一个工厂可以有若干个员工，而一个员工只能属于一个工厂；一个导师可以有若干个学
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 员，而一个学员只能属于一个导师等。（3）多对多联系（M：N）120如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集 B 中的每一个实体，实体集A 中也有M 个实体（M>=0）与之联系，则称实体集A 与实体集B具有多对多的联系，记为M：N。例如，一门课程可以被多个学生选择，一个学生可以选择多门课程等。【习题演练】1.下列实体类型的联系中，属于一对一联系的是（ ）。A.教研室对教师的所属联系B.父亲对孩子的联系C.省对省会的所属联系D.供应商与工程项目的供货联系1.【答案】C。解析：实体之间的联系分为：一对一、一对多和多对多。因为每一个省都只有一个省会，而一个省会只属于一个省，所以省和省会之121间是一对一的联系。而A 选项属于一对多的关系；B 选项属于一对多的关系；D 选项属于多对多的关系。2.在E-R 图中，用长方形表示（ ），用椭圆表示（ ）。A.联系、属性B.属性、实体C.实体、属性D.什么也不代表、实体2.【答案】C。解析：矩形表示实体，椭圆表示属性。3.关系模型中，候选码（ ）。A.可由多个任意属性组成B.至多由一个属性组成C.可由一个或多个其值能惟一标识
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 该关系模式中任何元组的属性组成D.以上都不是1223.【答案】C。解析：候选码可以是一个也可以是多个，但是必须能唯一标识元组。知识点 24、关系模型（ 一）简介关系数据模型是目前最重要的一种数据模型。关系数据库系统采用关系数据模型作为数据的组织方式。有层次数据模型和网状模型相比，关系模型概念简单、清晰，并且具有严格的数据基础，形成了关系数据理论，操作也直观、容易，因此易学易用。支持关系数据模型的DBMS 称为关系型数据库管理系统RDBMS。与其他数据模型相同，关系数据模型也是由数据结构、数据操作和完整性约束三个部分组成。123（ 二）关系模型的性质列是同质的，即同一列的分量值应该出自相同的域。列名是唯一的，即在同一个关系中不能出现完全相同的两个属性名称。行的顺序无关，即元组与元组之间互换位置，不相互影响。列的顺序无关，即列于列之间互换位置，不相互影响。任何两行不能完全相同，即不能出现两个完全相同的元组。分量必须是原子量，即是不可分的基本数据项。【习题演练】1.下列叙述正确的为（ ）。A.关系中元组没有先后顺序，属性有先后顺序B.关系中元组有先后顺序，属性没有先后顺序124C.关系中元组没有先后顺序，属性也没有
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 先后顺序D.关系中元组有先后顺序，属性也有先后顺序1.【答案】C。解析：关系中元组的顺序无关，属性的顺序也无关。知识点 25、关系操作和完整性约束（一 ）基本的关系操作1.查询操作关系的查询表达能力很强，是关系操作最主要的部分。查询操作又可以分为：选择、投影、连接、除、并、差、交、笛卡尔积等。2.更新操作更新操作又可以分为：插入、删除、修改。3.基本操作125关系的基本操作有五种，分别是：选择、投影、并、差、笛卡尔积。其他操作是可以用基本操作来定义和导出的。就像乘法可以用加法定义和导出一样。4.关系操作的特点关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应地，非关系数据模型的数据操作方式则为一次一记录的方式。（ 二）关系的三类完整性关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。1.实体完整性126（1）规则若属性（指一个或者一组属性）A 是基本关系R 的
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 主属性，则A 不能取空值。按照实体完整性规则的规定基本关系的主码都不能取空值。如果主码由若干属性组成，则所有这些主属性都不能取空值。（2）具体说明①实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。②现实世界中的实体是可以区分的，即它们具有某种唯一性标识。③相应地，关系模型中以主码作为唯一标识。④主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与②点相矛盾，因此这个规则称为实体完整性。2.参照完整性127若属性（或属性组）F 是基本关系R 的外码，它与基本关系S 的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R 中每个元组在F上的值必须为：①或者取空值（F 的每个属性值均为空值）；②或者等于 S 中某个元组的主码值。3.用户自定义完整性任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件。它反映某一具体应用所涉及的数据必须满足的语义要求。例如某个属性必须取值唯一
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、某个非主属性也不能取空值等。【习题演练】1281.若属性A是关系R 的主属性，则A不能为空，该规则称为（ ）。A.实体完整性规则B.属性完整性规则C.参照完整性规则D.用户定义完整性规则1.【答案】A。解析：数据完整性包括：实体完整性、参照完整型和用户定义完整性。实体完整性即规定主键不能为空。2.关系模型有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。定义外键实现的是（ ）完整性。A.实体完整性B.参照完整性C.用户定义的完整性D.实体完整性、参照完整性和用户定义的完整性1292.【答案】B。解析：定义外键实现的是参照完整性。知识点 26、SQL 常用语句SQL（Structured Query Language），即结构化查询语言，是关系数据库的标准语言。当前，几乎所有的关系数据库管理系统软件都支持 SQL，许多软件厂商对 SQL 的基本命令集还进行了不同程度的扩充和修改。SQL 集数据查询、数据操纵、数据定义和数据控制功能于一体，是一个综合的、通用的、功能极强、简洁易学的语言。（ 一）数据查询1.语句格式SELECT [ALL|DISTINCT] column_listFROM table_
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: list130[WHERE search_condition][GROUP BY group_by_list][HAVING search_condition][ORDER BY order_list[ASC|DESC]]2.运算符算术比较运算符：=，<，<=，>，>=，<>，!>，!<逻辑运算符：AND、OR、NOT所属集合运算符：IN、NOT IN谓词：EXISTS（存在)、BETWEEN…AND（范围）、LIKE（匹配）、IS NULL（空值）3.统计函数常见的统计函数统计函数 描述COUNT（*） 计算记录的个数COUNT（[DISTINCT]列名） 对一列中的值计算个数SUM（[DISTINCT]列名） 求某一数值型列的总和AVG（[DISTINCT]列名） 求某一数值型列的平均值131统计函数 描述MAX（[DISTINCT]列名） 求某一列的最大值MIN（[DISTINCT]列名） 求某一列的最小值4.连接查询在查询的数据涉及到多个表时，必须用连接条件将这些表连接起来。5.嵌套查询在 SQL 语句中，可以将一个查询嵌入在另一个查询的WHERE 子句中，这类查询称为嵌套查询。一般内层的查询称为子查
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 询，将外层的查询称为父查询。嵌套的 SELECT 查询使得 SQL 可以实现各种复杂的查询，子查询必须用括号括起来。6.示例a.查询计算机系年龄在20 岁以下的学生姓名：SELECT SnameFROM StudentWHERE Sdept=’CS’ AND Sage<20；b.查询选修了3 门以上课程的学生学号：132SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*)>3;（ 二）数据更新1.INSERT 语句（1）语句格式INSERT INTO<表名>[（<属性名清单>）]VALUES（<常量清单>）;（2）实例：在Employee表中插入一职工记录。INSERT INTO EmployeeVALUES（’2032’，’张杉’，’男’，28，’工程师’，’01 ’）;2.UPDATE 语句（1）语句格式UPDATE<表名>133SET <列名>=<表达式>[,<列名>=<表达式>][WHERE<条件>];（2）实例：在工资表中，将所有职工的基本工资都增加500。UPDATE SalarySET Basepay=Basepay+500;3.DELETE 语句（1）语句格
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 式DELETE FROM <表名>[WHERE<条件>]（2）实例：从职工表中删除Eno（职工号）为1003 的记录。DELETE FROM EmployeeWHERE Eno=’1003’;【习题演练】1341.SQL 语言的标准库函数 COUNT 、SUM 、AVG、MAX 和MIN 等，不允许出现在下列哪个子句中（ ）。A.SELECTB.HAVINGC.WHERED.GROUP，HAVING1.【答案】C。解析：SQL 语言的标准库函数COUNT、SUM、AVG、MAX 和MIN 等，不允许出现在WHERE 子句中。2.在SQL 语句中，与X BETWEEN 20 AND 30等价的表达式是（ ）。A.X>=20 AND X<30B.X>=20 AND X<=30C.X>20 AND X<=30D.X>20 AND X<302.【答案】B。解析：BETWEEN A AND B 是指在 A-B 之间的范围，且包括A 和B 。故与X135BETWEEN 20 AND 30 等价的表达式是 X>=20AND X<=30。3.一个查询的结果成为另一个查询的条件，这种查询被称为（ ）。A.内查询B.连接查询C.
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 自查询D.子查询3.【答案】D。解析：一个查询的结果成为另一个查询的条件，这种查询被称为子查询，也叫嵌套查询。4.在考试表中，要将58 分、59 分的分数调整到60 分，下列SQL 语句中能实现的是（ ）。A.UPDATE 考试表 SET 分数 = 60 HAVING分数>=58 AND 分数<60B.UPDATE 考试表 SET 分数 = 60 WHERE分数>=58 AND 分数<60136C.UPDATE 考试表 SET 分数 = 60 WHERE分数 IN(58,59)D.UPDATE 考试表 SET 分数 = 60 WHERE分数 BETWEEN 58 AND 594.【答案】C。解析：由题知至包含58 分和59分，符合题意的只有C 选项。知识点 27、计算机网络分类（一）按作用范围1.局域网（LAN）局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，137http://baike.baidu.com/view/
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 7886.htmhttp://baike.baidu.com/view/4321959.htmhttp://baike.baidu.com/view/281640.htm可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。2.城域网（MAN）城域网（Metropolitan Area Network）是在一个城市范围内所建立的计算机通信网，简称MAN。属于宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在 100 兆比特/秒以上。3.广域网（WAN）广域网（WAN，Wide Area Network）也称远程网（Long Haul Network）。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。（ 二）按拓扑结构1.星型拓扑结构138星型拓扑结构是一种以中央结点为中心，把若干外围结点连接起来的辐射式互联结构，各结点与中央结点通过点与点方式连接，中央结点执行集中式通信控制策略，因此中央结点相当复杂，负担也重。2.树型拓扑结构树型拓扑结构是一种层次结构，
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结点按层次连接，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。3.总线型拓扑结构总线型拓扑结构是采用单根传输作为共用的传输介质，将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上。使用总线型拓扑结构需解决的是确保用户使用媒体发送数据时不能冲突。在点到点的链路配置时，如果链路是半双工操作，只需使用简单的机制便可保证两个用户轮流工作。在一点到多点方式中，对线路的访问依靠控制139http://baike.baidu.com/view/47398.htmhttp://baike.baidu.com/view/420833.htm端的探询来确定。采取分布式访问控制策略来协调网络上计算机数据的发送。4.环型拓扑结构环型拓扑结构是使用公共电缆组成一个封闭的环，各结点直接连到环上，信息沿着环按一定方向从一个结点传送到另一个结点。环接口一般由发送器、接收器、控制器、线控制器和线接收器组成。5.网状拓扑结构网状拓扑结构，这种拓扑结构主要指各结点通过传输线相互连接起来，并且每一个结点至少与其他两个结点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，不常用于局域网。（ 三）按使用范围1.公用网一般是国家的邮电部门建造的网络。“公用”的意思就是从所有愿意按邮电部门规定交纳费用的140人都可以使用。因此，公用网也可以称为公众网，例如CHINANET、CERNET 等。2.专用网“专用网”是某个部门为本单位的特殊工作的需要而建立的网络。专用网指专用于一些保密性要求较高的部门的网络，比如企业内部专用网、军队专用网，尤其是涉及国家机密的部门。这种网络不向本单位以外的人提供服务。例如，军队、铁路、电力等系统均有本系统的专用网。【习题演练】1.局域网常用的基本拓扑结构有（ ）、环型和星型。A.层次型B.总线型C.交换型D.分组型1411.【答案】B。解析：局域网常用的拓扑结构有星型、环型、树型、总线型。网状型通常应用于广域网。知识点 28、网络地址（ 一）物理地址网卡物理地址存储器中存储单元对应实际地址称物理地址。MAC（介质访问控制）地址是识别LAN（局域网）结点的标识。网卡的物理地址通常是由网卡生产厂家烧入网卡的EPROM（一种闪存芯片，通常可以通过程序擦写），它存储的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址。物理地址一般记作 06-2E-1
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4-F9-5A-23，48 比特的不同组合。142（ 二）IP 地址是为网络每台计算机分配的唯一标识，为了使连入网络的众多计算机主机在通信时能够互相识别，网络中的每一台主机都有唯一的32 位地址。IP 地址一般用小数点隔开的十进制数，即点分十进制表示，如202.120.70.23。以点分十进制的形式表示IP 地址时，用小数点将 IP 地址分为四部分，每个部分的范围为0～255。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志该主机（或路由器）。两级的IP 地址可以记为：IP 地址：：= { <网络号>，<主机号>}（ 三）IP 地址分类汇总143IP 地址分类类型 IP 范围 私有IPA 1-126 10.0.0.1-10.255.255.255B 128-191 172.16.0.1- 172.31.255.255C 192-223 192.168.0.1- 192.168.255.255D 224-239E 240-254（ 四）特殊的 IP 地址主机号全为 1 表示本网段的内部广播地址，不能分给计
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 算机使用。主机号全为0 表示本网络的网段，计算机所在网络。127 开头的本地回环地址，主要测试TCP/IP 协议正确性。D 类地址为组播地址。主要是路由协议OSPF等使用。14410.0.0.110.255.255.255172.16.0.1172.31.255.255192.168.0.1192.168.255.255E 类地址用于研究使用。169.254.*.*的地址是当计算机自动获取IP 地址失败后的标识，但不能用于计算机之间的通信。（五）IPv6 地址IPv6 是InternetProtocoLVersion 6 的缩写，是下一代 IP 地址，用于替代现行版本 IP 协议（IPv4）的下一代 IP 协议，目的是为解决 IP 地址紧缺的问题。扩大地址的可用空间，满足计算机网路增长的需求。IPv6 将地址32 位（IPv4）增大到了 128 位二进制，使得地址数量变为原来的2 的96 次方倍，地址数量更多，适应未来网络扩展的需求。【习题演练】1.以下IP地址中，属于A 类地址的是（ ）。A.52.213. 12.23B.210.123.23. 12145C.223.123.213.23D.156.123.
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 32. 121.【答案】A。解析：A 类地址的第一个部分范围是 1～126，符合的只有A 选项。2.IPv4 地址和IPv6 地址的位数分别为（ ）。A.4，6B.8，16C.16，24D.32，1282.【答案】D。解析：IPv4 地址和Ipv6 地址的位数分别为32，128。知识点 29、子网掩码（ 一）概念子网掩码是一种用来指明一个 IP 地址的网络位和主机位，知道了 IP 地址的网络位，就可以确定146计算机 IP 地址所在的网络，知道了主机位就可以确定该 IP 地址所在网络的位置。（ 二）功能子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码是一个32 位地址，一般在书写的时候也是点分十进制表示。在子网掩码中，1 表示网络位，0 表示主机位。（ 三）默认子网掩码A 类网络的子网掩码为255.0.0.0，B 类网络的子网掩码为 255.255.0.0，C 类网络的子网掩码为255.255.255.0。（ 四）求网络号主机号全为0 的地址表示网络号。第一步把IP 地址转化为二进制。147255.0.0.0255.255.0.0255.255.255.0第二步把子网掩码转化为二进制。第三步保留
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 子网掩码中 1 所对应的部分，主机位用0 填充。第四步转为点分十进制。（五） 求主机号第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 0 所对应的部分。（六） 求广播号主机号全为 1 的地址表示广播号。第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 1 所对应的部分，主机位用 1 填充。第四步转为点分十进制。148（七） 子网划分计算形成子网的数量计算：从主机位借位当网络位来使用。借位数 子网个数 借位数 子网个数1 21 = 2 4 24 =162 22 = 4 5 25 =323 23 =8 6 26 = 64【习题演练】1.以下关于子网掩码的作用，错误的是（ ）。A.标识 IP 地址的网络部分和主机部分B.主机部分对应的子网掩码部分全为“0”C.网络部分对应的子网掩码部分全为“1”D.通过子网掩码标识网络的类型1491.【答案】D。解析：子网掩码是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位。其中主机部分对应的子网掩码部分全为0，网络部分全为 1。2.一个子网掩码是 255.255.240.0
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，这个子网能拥有的最大主机数是（ ）。A.240B.255C.4094D.655342.【答案】C。解析：255.255.240.0，将子网掩码中的240 转换为二进制，240=11110000，所以进行子网划分的时候借走了4 位主机位充当网络位，能够形成 2^4= 16 个子网，每个子网中的 IP 数量2^ 12=4096 ，但是能够分配给计算机使用的只有4096-2=4094。150255.255.240.0知识点 30、网络设备（一）局域网设备1.中继器中继器（Repeater）是局域网互连的最简单设备，工作在OSI 体系结构的物理层，它接收并识别网络信号，然后再生信号并将其发送到网络的其他分支上。信号在传输线路上传输的时候，受到距离、噪音、电阻等影响，使得信号传输的距离不能是长到无限远，在传输一定距离后，信号需要加强。如果在线路中间插入放大器，则伴随信号的放大，噪音也被放大了。中继器的功能是对接收信号进行再生和发送。2.集线器集线器属于物理层设备。集线器是有多个端口的中继器，简称HUB。151集线器在创建网络时，一般是以星型或树型拓扑结构为主。集线器没有MAC地址表，采用广播方式发送，当网络中的主机数
2025-08-10 14:53:44.016 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 量过多的时候，就会在网络生成广播风暴。以集线器为主要网络设备的网络被称为共享式以太网。3.网卡网络接口卡NIC（Network Interface Card）又称网卡或网络适配器。网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。4.网桥在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据MAC 帧的目的地址对收到的帧进行转发。152网桥不隔绝广播风暴。5.交换机以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。（ 二）广域网设备1.网关网关（Gateway）又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。2.路由器153路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由
2025-08-10 14:53:44.017 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，以最佳路径，按前后顺序发送信号。3.调制解调器调制解调器（modem）是一种计算机硬件，它能把计算机的数字信号翻译成可沿普通电话线传送的模拟信号，是家用电话拨号上网的必不可上少的设备。调制：将数字信号转化为模拟信号。解调：将模拟信号转化为数字信号。【习题演练】1.集线器是工作在（ ）的设备。A.物理层B.链路层C.网络层D.运输层1541.【答案】A。解析：中继器和集线器就是物理层的设备。2.在下列网间连接器中，（ ）在数据链路层实现网络互连。A.中继器B.网桥C.路由器D.网关2.【答案】B。解析：网桥是数据链路层的设备，中继器是物理层设备，路由器是网络层设备，网关在传输层及其以上实现网络互联。155知识点 31、信息加密技术（ 一）信息加密信息加密是指使有用的信息变为看上去似为无用的乱码，使攻击者无法读懂信息的内容从而保护信息。任何一个加密系统至少由下面四个部分组成：1.未加密的信息，也称明文。2.加密后的信息，也称密文。3.加密解密设备或算法。4.加密解密的密钥。发送方用加密密钥，通过加密设备或算法，将信息加密后发送出去。接收方在收到密文后，用解密密钥将密文解密，恢复为明文。如果传输中有人窃取，他只能
2025-08-10 14:53:44.017 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 得到无法理解的密文，从而对信息起到保密作用。156其中，密钥是唯一能够控制明文与密文之间变换的关键，通常是一随机字符串，在计算机上实现的数据加密算法，其加密或解密变换是由一个密钥来控制的。（ 二）对称加密1.概念对称密码体制是指如果一个加密系统的加密密钥和解密密钥相同，或者虽然不相同，但是由其中的任意一个可以很容易地推导出另一个，即密钥是双方共享的，则该系统所采用的就是对称密码体制。2.加密过程3.对称加密算法特点157对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。常见的对称加密算法：DES 算法，3DES 算法，TDEA 算法，Blowfish 算法，RC5 算法， IDEA 算法。（ 三）非对称密钥加密1.概念公钥密码体制指一个加密系统的加密密钥和解密密钥是不一样的，或者说不能由一个推导出另一158个。其中一个称为公
2025-08-10 14:53:44.017 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 钥用于加密，是公开的，另一个称为私钥用于解密，是保密的。公钥密码体制解决了密钥的管理和发布问题，每个用户都可以把自己的公开密钥进行公开，如发布到一个公钥数据库中。2.工作原理A要给B发送信息时，A用B 的公钥加密信息，因为A 知道B 的公钥。A 将这个消息发给B。B 收到这个消息后，B 用自己的私钥解密A 的消息。其他所有收到这个报文的人都无法解密，因为只有B 才有B 的私钥。3.RSA 算法159RSA 是Rivest、Shamire 和Adleman 于 1978 年在美国麻省理工学院研制出来的，它是一种比较典型的公开密钥加密算法。【习题演练】1.在数据加密技术中，将待加密的报文称为( )。A.密文B.正文C.短文D.明文1.【答案】D。解析：待加密的报文称为明文。2.在公钥密码体制中，公开的是（ ）。A.公钥和私钥B.公钥和算法C.明文和密文D.加密密钥和解密密钥1602.【答案】B。解析：公钥加密算法是计算机网络中经常使用的算法，能跟好的保证网络安全。其中有两个秘钥，公钥和算法是公开的，可以在服务器上查找到，这样方便用于加密。私钥是用户自己保存的一种密钥。3. 以下关于对称与非对称加密算法叙述中正确的
2025-08-10 14:53:44.017 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 是（ ）。A.对称加密比非对称加密的安全性好B.对称加密比非对称加密的解密速度慢C.非对称加密算法中公钥是公开的，算法是保密的D.非对称加密与对称加密相比，用户需要保管的密钥数量少3.【答案】D。解析：非对称加密使用了一对密钥，即公钥与私钥，公钥是公开的，私钥个人持有，不公开，故D 选择正确。161知识点 32、计算机病毒（ 一）计算机病毒的概念广义上，能够引起计算机故障、破坏计算机数据的程序都可称为计算机病毒；狭义上，计算机病毒是指编制者在计算机程序中插入的破坏计算机或者毁坏数据，影响计算机的使用，并能自我复制的一组计算机指令或者程序代码。（ 二）计算机病毒的特性目前，计算机病毒有数十万种，各有其不同的特征，但总的说来，计算机病毒又有明显的共性。计算机病毒主要有以下几种特征：1.传染性传染性是计算机病毒的基本特征。计算机病毒能通过自我复制来感染正常的文件，达到破坏计算162机系统正常运行的目的。但传染性是有条件的，只有病毒程序被执行之后才具有传染性，才能感染其他文件。2.破坏性任何计算机病毒只要侵入计算机系统，都会对系统及应用程序产生不同程度的影响和破坏，轻则降低计算机的工作效率，占用系统资源，重则破坏数据
2025-08-10 14:53:44.017 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，删除文件，甚至导致系统崩溃，给用户造成不可挽回的损失。3.寄生性虽然计算机病毒是一种程序，但这种程序通常不是以独立文件的形式存在的，它寄生在合法的程序之中。这些合法的程序可以是系统引导程序、可执行程序、一般应用程序等。现在的某些病毒本身就是一个完整的程序，如广义病毒中的网络蠕虫。4.欺骗性黑客常常会把带有病毒程序的名字起成一些用户比较关心的程序名字。1635.隐蔽性和潜伏性计算机病毒要有效的传染和传播，就应该尽量在用户能够觉察的范围之外进行。6.衍生性既然计算机病毒是一段特殊的程序，了解病毒程序的人就可以根据其个人意图随意改动，从而衍生出另一种不同于原版病毒的新病毒。7.可触发性编制计算机病毒的人，一般都为病毒程序设定了一些触发条件，例如系统时钟的某个时间或日期、系统运行了某些程序等。一旦条件满足，计算机病毒就会“发作”，使系统遭到破坏。（ 三）计算机病毒的传播方式计算机病毒的传播方式主要有：（1）移动存储设备传播；（2）计算机网络传播；（3）电子邮件传播。164【习题演练】1.计算机病毒是可以造成计算机故障的（ ）。A.一种微生物B.一种特殊的程序C.一块特殊芯片D.一个程序逻辑错误1.【答案】B。解析：
2025-08-10 14:53:44.017 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 计算机病毒指人为编制的一段具有破坏性的，能够自我复制的程序或者代码。2.计算机病毒具有破坏性、（ ）、潜伏性和传染性等特点。A.必然性B.再生性C.隐蔽性D.易读性2.【答案】C。解析：计算机病毒具有寄生性、传染性、潜伏性、隐蔽性。1653.根据统计，当前计算机病毒扩散最快的途径是（ ）。A.软件复制B.网络传播C.磁盘拷贝D.运行游戏软件3.【答案】B。解析：计算机病毒扩散最快的是网络传播，需要提前安装使用杀毒软件来做好防范。166目录知识点 1 、进制转换知识点 2 、常见数据编码知识点 3 、机器数知识点 4 、补码溢出知识点 5 、寻址方式知识点 6 、存储芯片容量的计算知识点 7 、DRAM 的刷新知识点 8、存储器与 CPU 的扩展连接知识点 9 、死锁知识点 10 、处理机调度的层次知识点 11 、调度算法知识点 12 、内存的连续分配知识点 13 、基本的分页存储管理知识点 14 、基本的分段存储管理知识点 15 、虚拟存储器知识点 16 、页面置换算法知识点 17 、线性表知识点 18 、栈和队列知识点 19 、树知识点 20 、二叉树知识点 21 、图知识点 22 、数据模型知识点 23 
2025-08-10 14:53:44.017 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、概念模型知识点 24 、关系模型知识点 25 、关系操作和完整性约束知识点 26 、SQL 常用语句知识点 27 、计算机网络分类知识点 28 、网络地址知识点 29 、子网掩码知识点 30 、网络设备知识点 31 、信息加密技术知识点 32 、计算机病毒
2025-08-10 14:53:44.192 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:44.192 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:44.192 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.yizhaoqi.smartpai.service.VectorizationService - 开始向量化文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:44.195 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 261
2025-08-10 14:53:44.196 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:44.196 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:44.450 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] [2f214867-9] Response 400 BAD_REQUEST
2025-08-10 14:53:44.450 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] [2f214867-9] Read 312 bytes
2025-08-10 14:53:45.462 [parallel-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:45.463 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:45.704 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] [2f214867-10] Response 400 BAD_REQUEST
2025-08-10 14:53:45.705 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] [2f214867-10] Read 312 bytes
2025-08-10 14:53:46.705 [parallel-8] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:46.705 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:46.914 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] [2f214867-11] Response 400 BAD_REQUEST
2025-08-10 14:53:46.915 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] [2f214867-11] Read 312 bytes
2025-08-10 14:53:47.918 [parallel-9] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:47.918 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:48.164 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] [2f214867-12] Response 400 BAD_REQUEST
2025-08-10 14:53:48.164 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [1f66742d] [2f214867-12] Read 312 bytes
2025-08-10 14:53:48.164 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [1f66742d] Cancel signal (to close connection)
2025-08-10 14:53:48.165 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR com.yizhaoqi.smartpai.client.EmbeddingClient - 调用向量化 API 失败: Retries exhausted: 3/3
reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:840)
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:48.165 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.yizhaoqi.smartpai.service.VectorizationService - 向量化失败，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:48.166 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.y.smartpai.consumer.FileProcessingConsumer - Error processing task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:51.214 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR o.s.kafka.listener.KafkaMessageListenerContainer - Error handler threw an exception
org.springframework.kafka.KafkaException: Seek to current after exception
	at org.springframework.kafka.listener.SeekUtils.seekOrRecover(SeekUtils.java:227)
	at org.springframework.kafka.listener.DefaultErrorHandler.handleRemaining(DefaultErrorHandler.java:168)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeErrorHandler(KafkaMessageListenerContainer.java:2836)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2713)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: org.springframework.kafka.listener.ListenerExecutionFailedException: Listener method 'public void com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(com.yizhaoqi.smartpai.model.FileProcessingTask)' threw exception
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.decorateException(KafkaMessageListenerContainer.java:2869)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2814)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	... 10 common frames omitted
	Suppressed: org.springframework.kafka.listener.ListenerExecutionFailedException: Restored Stack Trace
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:435)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
Caused by: java.lang.RuntimeException: Error processing task
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:67)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	... 12 common frames omitted
Caused by: java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	... 25 common frames omitted
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:51.222 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Received task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
2025-08-10 14:53:51.222 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件权限信息: userId=1, orgTag=PRIVATE_sy, isPublic=false
2025-08-10 14:53:51.222 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Downloading file from storage: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:51.223 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Detected remote URL: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:51.228 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Successfully connected to URL, starting download...
2025-08-10 14:53:51.228 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 开始解析文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:51.370 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] WARN  org.apache.pdfbox.pdmodel.font.PDCIDFontType2 - Found CFF/OTF but expected embedded TTF font THDZFH+AppleSDGothicNeo-Regular
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文件元数据:
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:unmappedUnicodeCharsPerPage: 0
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:PDFVersion: 1.7
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmp:CreatorTool: WPS 文字
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXFA: false
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:modify_annotations: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print_degraded: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By-Full-Set: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:creator: Sky123.Org
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:num3DAnnotations: 0
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:format: application/pdf; version=1.7
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator_tool: WPS 文字
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:overallPercentageUnmappedUnicodeChars: 0.0
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:fill_in_form: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasCollection: false
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:encrypted: false
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsNonEmbeddedFont: false
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:custom:SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasMarkedContent: false
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - Content-Type: application/pdf
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator: Sky123.Org
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:totalUnmappedUnicodeChars: 0
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_for_accessibility: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:assemble_document: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmpTPg:NPages: 166
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXMP: false
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:charsPerPage: 15
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_content: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:trapped: False
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationTypes: null
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_modify: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationSubtypes: Link
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsDamagedFont: true
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 提取的文本内容长度: 44161
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换............................................................ 6知识点 2、常见数据编码....................................................8知识点 3、机器数.............................................................. 14知识点 4、补码溢出..........................................................19知识点 5、寻址方式..........................................................22知识点 6、存储芯片容量的计算..................................... 39知识点 7、DRAM 的刷新................................................ 40知识点 8、存储
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与 CPU 的扩展连接...........................43知识点 9、死锁.................................................................. 48知识点 10、处理机调度的层次....................................... 553知识点 11、调度算法........................................................57知识点 12、内存的连续分配........................................... 63知识点 13、基本的分页存储管理................................... 70知识点 14、基本的分段存储管理................................... 76知识点 15、虚拟存储器....................................................83知识点 16、页面置换算法....................
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ........................... 90知识点 17、线性表............................................................ 95知识点 18、栈和队列........................................................98知识点 19、树.................................................................. 102知识点 20、二叉树.......................................................... 105知识点 21、图.................................................................. 1104知识点 22、数据模型......................................................117知识点 23、概念模型................................
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ......................119知识点 24、关系模型......................................................125知识点 25、关系操作和完整性约束.............................127知识点 26、SQL 常用语句............................................ 132知识点 27、计算机网络分类......................................... 139知识点 28、网络地址......................................................144知识点 29、子网掩码......................................................148知识点 30、网络设备......................................................153知识点 31、信息加密技术...............................
2025-08-10 14:53:51.426 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: .............. 158知识点 32、计算机病毒..................................................1645知识点 1、进制转换常用数制数制 数码 运算规则 尾符十进制 0—9 逢十进一 D或10二进制 0—1 逢二进一 B或2八进制 0—7 逢八进一 O或8十六进制 0—9，A—F 逢十六进一 H或16（ 一 ）非十进制数转换成十进制数方法每位上的数码×基的位次方，然后求和。（ 二 ）十进制数转换成非十进制数方法整数部分：除N 取余数，直至商为0，余数倒输出。小数部分：乘N 取整数，直至积为0（或满足精度），整数正输出。6（N 为进制数，N 可取2、8、16。）（ 三 ）二/八/十六进制数的互相转换方法由于一位八/十六进制数相当于三/四位二进制数，因此，要将八/十六进制数转换成二进制数时，只需以小数点为界，向左或向右每一位八/十六进制数用相应的三/四位二进制数取代即可。如果不足三/四位，可用零补足。反之，二进制数转换成相应的八/十六进制数，只是上述方法的逆过程，即以小数点为界，向左或向右，每三/四位二进制数用相应的一位八/十六进制数取代即可。【习题
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 演练】1.二进制数 1101.01 转换成十进制数是（ ）。A.17.256B.13.5C.13.25D.17.571.【答案】C。解析：（1101.01）2= 1 x23+1 x22+1+1 x 2—2 = 13.25。2.下列数中最大的数是（ ）。A.227OB.1FFHC. 10100001BD.1789D2.【答案】D。解析：将所有数都统一转换为十进制进行比较，227O=151D ， 1FFH=511D ，10100001B= 161D，对比可知应选D 选项。知识点 2、常见数据编码（ 一）ASCII码美国信息交换标准代码（American StrandardCode for Information Interchage，ASCII）是一种西8文机内码，是计算机中使用最广泛的字符编码，已经作为国际通用的信息交换标准代码。ASCII 码包括 0～9 十个数字，大小写英文字母和专用符号等95 种可打印字符，以及33 种控制字符（如回车、换行等），通常采用一个字节编码，由7 位二进制编码组成，字节的最高位一般规定为0，或用作校验码，可表示 128 个不同的字符。（ 二）汉字的编码1.国标码《信息交换用汉字编
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 码字符集·基本集》是我国于 1980 年制定的国家标准GB2312—80，简称国标码，是国家规定的用于汉字信息交换使用的代码的依据。GB2312—80 中规定了信息交换用的6763个汉字和682 个非汉字图形符号（包括外文字母、数字和符号）的代码。国标码用两个字节表示一个汉字，每个字节只使用低7 位，最高位为0。2.汉字机内码9汉字的机内码是供计算机系统内部进行存储、加工处理、传输统一使用的代码，又称为汉字内部码或汉字内码。汉字机内码是将国标码的两个字节的最高位分别置为 1 而得到的。其最大优点是机内码表示简单，同时也解决了中西文机内码存在的二义性的问题。3.汉字输入码汉字输入码是为了将汉字通过键盘输入计算机而设计的代码。汉字输入编码方案很多，其表示形式大多用字母、数字或符号。输入码的长度也不同，多数为四个字节。综合起来可分为流水码、音码、形码和音形码几大类。4.汉字字形码汉字字形码是汉字字库中存储的汉字字形的数字化信息，用于汉字的显示和打印。目前汉字字形的产生方式大多是数字式，即以点阵方式形成汉字。因此，汉字字形码主要是指汉字字形点阵的代码，10主要有 16×16 点阵、32×32 点阵、256×256 点
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 阵等。如 24×24 的点阵，每字需要72 字节；32×32的点阵，每字需要 128 字节。与每个汉字对应的这一串字节就是汉字的字形码。（ 三）二-十进制编码人们习惯于使用十进制数，而计算机内部多采用二进制数表示和处理数值数据，因此在计算机输入和输出数据时，就要进行由十进制到二进制和从二进制到十进制的转换处理，显然，这项事务性工作如果由人工来完成，势必造成大量时间浪费。因此，必须采用一种编码的方法，由计算机自己来完成这种识别和转换工作。人们通常采用把十进制数的每一位分别写成二进制数形式的编码，称为二-十进制编码或BCD 编码。BCD 编码方法很多，通常采用的是8421 编码。其方法是用四位二进制数表示一位十进制数，自左11至右每一位对应的位权分别是8，4，2，1。值得注意的是，四位二进制数有 0000～1111 十六种状态，这里只取了0000～1001 十种状态，而 1010～1111六种状态在这种编码中没有意义。如十进制数864，其BCD进制编码为 100001100100。8 6 4↓ ↓ ↓1000 0110 0100BCD 码有压缩和非压缩两种。上述的编码方法属于压缩BCD 码，特点是用 1 个字节表
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 示2 位BCD码；非压缩 BCD 码用 1 个字节的低 4 位表示 1 位BCD 码，高4 位为0（无意义）。如 13 的压缩BCD码为 0001 0011 ，非压缩 BCD 码为 0000000100000011。【习题演练】1.已知字符0 的ASCII码为48D，用ASCII 码（7 位）表示字符5 和7 是（ ）。12A.0110010 和0110111B.0100011 和0111011C. 1000101和1100011D.0110101 和01101111.【答案】D。解析：ASCII 码表中字符5 和7的码值分别为 53 和 55 ，转换为二进制表示为0110101 和 0110111。2.某数用压缩BCD 码表示为 10010101，其真值为（ ）。A.135B.95C.95HD. 10010101B2.【答案】B。解析：BCD码是二-十进制编码，1001 和0101 分别对应十进制的9 和5，故选择B选项。3.一个 16×16 点阵的汉字要占用（ ）。A.24 个字节13B.32 个字节C.48 个字节D.256 个字节3.【答案】B。解析：16×16 点阵的汉字要用16×16/8=32 个
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 字节。知识点 3、机器数对于数的符号“＋”和“－”，计算机是无法识别的，需要把符号数码化。通常，约定二进制数的最高位为符号位，“0”表示正号，“1”表示负号。这种在计算机中使用的表示数的形式称为机器数，常见的机器数有原码、反码、补码等。（ 一）原码原码表示法是机器数的一种简单的表示法。其符号位用0 表示正号，用 1 表示负号，数值一般用14二进制形式表示。设有一数用X 表示真值，则原码表示可记作[X]原，例如：X1=＋1010110X2=－1001010其原码记作：[X1]原=[＋1010110]原=01010110[X2]原=[－1001010]原= 11001010在原码表示法中，对 0 有两种表示形式：[＋0]原=00000000[－0]原=10000000（ 二）反码机器数的反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。假设有一数用X表示真值，那么X 的反码表示记作[X]反，例如：X1=＋101011015X2=－1001010那么[X1]原=01010110[X1]反=[X1]原=01010110[X2]
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 原=11001010[X2]反=10110101在反码表示法中，对 0 也有两种表示形式：[＋0]反=00000000[－0]反=11111111反码通常作为求补过程的中间形式，即在一个负数的反码的末位上加 1，就得到该负数的补码。（ 三）补码机器数的补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在末位加 1 而得到的。设有一数用X 表示真值，则X 的补码表示记作[X]补，例如：16X1=＋1010110X2= – 1001010那么[X1]原=01010110[X1]补= [X1]原=01010110[X2]原=11001010[X2]补= 10110101+1=10110110在补码表示法中，0 只有一种表示形式：[＋0]补=00000000[－0]补= 11111111＋1=00000000所以有[＋0]补=[－0]补=00000000。【习题演练】1.采用补码表示的 8 位二进制数真值范围是( )。A.- 127～+127B.- 127～+128C.- 128～+12717D.- 128～+1281.【答案】C。
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 解析：补码表示的8 位二进制数真值范围是- 128～+127 ，原码和反码的范围是- 127～+127。2.补码25H 的真值是（ ）。A.25B.-25C.-37D.372.【答案】D。解析：正数的原码、反码与补码都相同。3.在机器中，（ ）的零的表示形式是唯一的。A.原码B.补码C.反码D.原码和反码3.【答案】B。解析：补码零的表示形式唯一，而原码和反码不唯一。18知识点 4、补码溢出（一 ）补码溢出的产生在补码加减运算中，有时会遇到这样的情况：两个正数相加，而结果的符号位却为 1（结果为负）；两个负数相加，而结果的符号位却为0（结果为正）。发生这种错误的原因在于两数相加之和的数值已超过了机器允许的表示范围。字长为n+1 位的定点整数（其中一位为符号位），采用补码表示，当运算结果大于2n- 1 或小于-2n 时，就产生溢出。设参加运算的两数为X、Y，做加法运算：①若X、Y 异号，不会溢出；②若X、Y 同号，运算结果为正且大于所能表示的最大正数或运算结果为负且小于所能表示的最小负数时，产生溢出。将两正数相加产生的溢出称为正溢；反之，两负数相加产生的溢出称为负溢。19（ 二）补码溢出的检测设被操作数为[X]
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 补=XsX1X2…Xn，操作数为[Y]补=YsY1Y2…Yn，其和（差）为[S]补=SsS1S2…Sn，则判断溢出的方法有以下三种：1.采用一个符号位两正数相加，结果为负表明产生正溢；两负数相加，结果为正表明产生负溢。因此可得出采用一个符号位检测溢出的方法：当Xs=Ys=0，Ss=1 时，产生正溢；当Xs=Ys=1，Ss=0 时，产生负溢。2.采用进位位两数运算时，产生的进位为：CsC1C2…Cn，其中：Cs 为符号位产生的进位，C1 为最高数值位产生的进位。两正数相加，当最高有效位产生进位（C1= 1）而符号位不产生进位（Cs=0）时，发生正溢。20两负数相加，当最高有效位没有进位（C1=0）而符号位产生进位（Cs= 1）时，发生负溢。3.采用变形补码（双符号位补码）在双符号位的情况下，把左边的符号位 Ss1 叫做真符，因为它代表了该数真正的符号，两个符号位都作为数的一部分参加运算。这种编码又称为变形补码。双符号位的含义如下：Ss1Ss2=00，结果为正数，无溢出；Ss1Ss2=01，结果正溢；Ss1Ss2=10，结果负溢；Ss1Ss2= 11，结果为负数，无溢出。【习题演练】1.算式65H-3EH 的运算
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结果是否有溢出，结果的真值为（ ）。A.有、39B.有、27C.无、39D.无、27211.【答案】C。解析：65H-3EH=101D-62D=39D，无溢出。知识点 5、寻址方式存储器既可用来存放操作数，又可用来存放指令。当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。因此，寻址方式可以分为数据寻址和指令寻址。寻找操作数的地址称为数据寻址，数据寻址方式较多，其最终目的都是寻找所需要的操作数。寻找下一条将要执行的指令地址称为指令寻址。（ 一）指令寻址指令寻址比较简单，它又可以细分为顺序寻址和跳跃寻址。顺序寻址可通过程序计数器PC 加 1，22自动形成下一条指令的地址；跳跃寻址是程序转移执行时的指令寻址方式，它通过转移类指令实现。跳跃寻址的转移地址形成方式有三种：直接（绝对）、相对和间接寻址，它与数据寻址方式中的直接、相对和间接寻址是相同的，只不过寻找到的不是操作数的有效地址而是转移的有效地址而已。（ 二）数据寻址数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 真实地址称为有效地址，记作 EA，它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如下所示。操作码OP 寻址特征# 形式地址A寻址方式是根据指令中给出的地址码字段寻找真实操作数地址的方式。23指令中的形式地址A—（寻址方式）→有效地址EA1.立即寻址在取指令时，操作码和操作数被同时取出，不必再次访问存储器，从而提高了指令的执行速度，如下图所示。立即寻址的特点是操作数本身设在指令字内，即形式地址A 不是操作数的地址，而是操作数本身，也称立即数。由于操作数是指令的一部分，故立即数的大小将受到指令长度的限制。立即寻址示意图2.直接寻址指令中地址码字段给出的地址A 就是操作数的有效地址：EA=A，如下图所示。直接寻址的缺点在于A 的位数限制了操作数的寻址范围，且必须修改A 的值，才能修改操作数的地址。24直接寻址示意图3.间接寻址指令中给出的地址A 不是操作数的地址，而是存放操作数地址的地址：EA=（A），如下图所示。间接寻址要比直接寻址灵活得多，它的主要优点为：一是扩大了寻址范围，可用指令的短地址访问大的主存空间，二是可将主存单元作为程序的地址指针，用以指示操作数在主存中的位置。当操作数的地址需要改变时，
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 不必修改指令，只需修改存放有效地址的那个主存单元（间接地址单元）的内容就可以了。25一级间接寻址二级间接寻址26除去一级间接寻址外，还有多级间接寻址。多级间接寻址为取得操作数需要多次访问主存，即使在找到操作数有效地址后，还需再访问一次主存才可得到真正的操作数。4.寄存器寻址指令中地址码部分给出某一通用寄存器的编号，所指定的寄存器中存放着操作数，如下图所示。它有两个明显的优点：一是从寄存器存取数据比主存快得多；二是由于寄存器的数量较少，其地址码字段比主存单元地址字段短得多。寄存器寻址示意图5.寄存器间接寻址27寄存器间接寻址示意图指令中的地址码给出某一通用寄存器的编号，被指定的寄存器中存放操作数的有效地址，而操作数则存放在主存单元中，如上图所示。这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数。6.变址寻址把指令给出的形式地址A 与变址寄存器Rx 的内容相加，形成操作数有效地址：EA ＝ A +（Rx），Rx 的内容为变址值，如下图所示。28变址寻址是一种广泛采用的寻址方式，通常指令中的形式地址作为基准地址，而 Rx 的内容作为修改量。在遇到需要频繁修改地址时，无须修改指令，只要修改变址值就可以了
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。变址寻址示意图如要把一组连续存放在主存单元中的数据（首地址是A）依次传送到另一存储区（首地址为B）中去，则只需在指令中指明两个存储区的首地址A和B（形式地址），用同一变址寄存器提供修改量29K，即可实现（A＋K）→B＋K。变址寄存器的内容在每次传送之后自动地修改。7.基址寻址将基址寄存器Rb 的内容与形式地址A 相加，形成操作数有效地址：EA＝（Rb）＋ A，基址寄存器的内容称为基址值，如下图所示。基址寻址示意图工30基址寻址和变址寻址在形成有效地址时所用的算法是相同的，而且在一些计算机中，这两种寻址方式都是由同样的硬件来实现的。但这两种寻址方式应用的场合不同，变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改。8.相对寻址相对寻址是基址寻址的一种变通，由程序计数器PC 提供基准地址，即：EA＝（PC）＋ A，A 是操作数和现行指令之间的相对位置，如下图所示。3132相对寻址示意图相对寻址方式的特点是：操作数的地址不是固定的，
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 它随着PC 值的变化而变化，并且与指令地址之间总是相差一个固定值A。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC 相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。指令中给出的位移量A 可正、可负，通常用补码表示，故对于指令地址而言，操作数地址可能在指令地址之前或之后。9.隐含寻址隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。如一地址指令格式，只给出一个操作数的地址，另一个操作数隐含在累加器ACC 中，故累加器ACC对一地址指令格式来说是隐含地址，如下图所示。33隐含寻址示意图10.堆栈寻址在堆栈寻址的指令字中没有形式地址码字段，它是一种零地址指令。堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组来实现，也可利用主存的一部分空间作堆栈，前者称为硬堆栈，后者称为软堆栈。【习题演练】1. 对某个寄存器中操作数的寻址方式称为( ) 寻址。A.直接B.间接C.寄存器34D.寄存器间接1.【答案】C。解析：操作数在寄存器中的寻址方式为：“寄存器直接寻址”，也叫“寄存器寻址
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ”。当操作数的有效地址在寄存器中时叫“寄存器间接寻址”。2.操作数所处的位置，可以决定指令的寻址方式。操作数的地址在寄存器中，寻址方式为（ ）。A.相对寻址B.直接寻址C.寄存器寻址D.寄存器间接寻址2.【答案】D。解析：操作数包含在指令中的寻址方式为立即寻址；操作数在寄存器中的寻址方式为寄存器寻址；操作数的地址在寄存器中的寻址方式为寄存器间接寻址。3.变址寻址和基址寻址的有效地址形成方式类似，但（ ）。35A.变址寄存器的内容在程序执行过程巾是不能改变的B.基址寄存器的内容在程序执行过程中是可以改变的C.在程序执行过程中，变址寄存器的内容不能改变而基址寄存器的内容可变D.在程序执行过程中，基址寄存器的内容不能改变而变址寄存器的内容可变3.【答案】D。解析：基址寄存器的内容由操作系统确定，而变址寄存器的内容由用户确定，因此基址寄存器的内容不能改变而变址寄存器的内容可变。知识点 6、存储芯片容量的计算存储芯片的容量与地址线的位数、数据线的位数均有关。地址线和数据线的位数共同反映存储芯片的容量。其公式可写为：36存储芯片容量=2A×D位，其中，A 为地址线根数，D 为数据线根数。如地址线为 10 根，数据线为4根
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，则存储芯片容量为 210×4＝4K 位；又如地址线为 14 根，数据线为 1根，则其容量为214×1＝16K 位。【习题演练】1.某DRAM 芯片，其存储容量为512K×8 位，该芯片的地址线和数据线数目为（ ）。A.8，512B.512，8C.18，8D.19，81.【答案】D。解析：512K X8 = 219 X 8，所以地址线和数据线分别为 19 和8。37知识点 7、DRAM 的刷新动态随机存储器刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。DRAM 是靠电容来存储信息的，由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对DRAM 的全部基本单元电路必作一次刷新，一般取2ms（2000μs），这个时间称为刷新周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本电路的逐行刷新，才能保证DRAM 内的信息不会丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。38（ 一）集中刷新集中刷新是在规定的一个刷新周期内，对全部存
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。如对 128×128 矩阵的存储芯片进行刷新，刷新的时间相当于 128 个读周期。若读/写周期为 0.5μs，则对 128 行集中刷新共需 128×0.5 =64μs，其余的 1936μs（=2000－64）用来读/写或维持信息。由于在这 64μs 时间内不能进行读写操作，故称为“死时间”。（ 二）分散刷新分散刷新把对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期分成两段，前半段用来读/写或维持信息，后半段用来刷新。若读/写周期为 0.5μs，则存取周期为 1μs，那么每隔128μs 就可将 128 行的存储芯片全部刷新一遍，但39这比允许的 2ms 间隔要短得多，且存取周期长了，整个系统的速度降低。（ 三）异步刷新前两种方式的集合，既可缩短“死时间”，又充分利用最大刷新间隔为 2ms 的特点。如可在 2ms内对 128 行各刷新一遍，即每隔 15.6μs（2000/ 128）刷新一行，每行的刷新时间仍为 0.5μs，但对每行来说，刷新间隔仍为2ms，“死时间”缩短为0.5μs。【习题演练】1.动态RAM 的刷新是以（ ）为单位进行的
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。A.存储矩阵B.行C.列D.存储单元1.【答案】B。解析：动态RAM 的刷新以行为单位进行。40知识点 8、存储器与 CPU 的扩展连接（一 ）存储容量的扩展由于单片存储芯片的容量总是有限的，很难满足实际的需要，因此，必须将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有位扩展和字扩展。1.位扩展位扩展是指增加存储字长，只在位数方向扩展（加大字长）。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。位扩展组成容量 地址 数据41存储器 64K×8 16 位 8 位存储芯片 64K×1 16 位 1 位如用 64K×1 的SRAM 芯片组成64K×8 的存储器，需要8 个芯片，如上表所示。当CPU 访问该存储器时，其发出的地址和控制信号同时传给8个芯片，选中每个芯片的同一单元，其单元的内容被同时读至数据总线的相应位，或将数据总线上的内容分别同时写入相应单元。2.字扩展字扩展是指增加存储器字的数量，它仅在字数方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。如用 16K×8 的SRAM 组成64K
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ×8 的存储器，需要4 个芯片，如下表所示。字扩展组成容量 地址 数据42存储器 64K×8 16 位 8 位存储芯片 16K×8 14 位 8 位在同一时间内四个芯片中只能有一个芯片被选中。3.字和位同时扩展字和位同时扩展组成容量 地址 数据存储器 64K×8 16 位 8 位存储芯片 16K×4 14 位 4 位字和位同时扩展是指既增加存储字的数量，又增加存储字长。当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展，这将是前两种扩展的组合，实现起来也较为容易。如用16K×4 的SRAM 组成64K×8 的存储器，需要8 个芯片，如上表所示。43（ 二）存储器与 CPU 的连接存储芯片与CPU 芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。1.地址线的连接存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU 地址线的低位与存储芯片的地址线相连。CPU 地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。2.数据线的连接CPU 的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU 
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的数据线数相等。3.读/写命令线的连接CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。4.片选线的连接44片选线的连接是CPU 与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端---cs是否能接收到来自CPU 的片选有效信号。5.合理选择存储芯片合理选择存储芯片主要是指存储芯片类型（RAM 或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM 则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单方便。【习题演练】1.用存储容量为16K×1 位的存储器芯片来组成一个 64K×8 位的存储器，则在字方向和位方向上分别扩展了（ ）倍。A.4 和2B.8 和4C.2 和445D.4 和81.【答案】D。解析：用64K 除以16K等于4，用8 除以1 等于8。2.RAM 芯片并联时可以使（ ）。A.存储器存储字长增加B.存储器地址范围增加C.存储器速度增加D.降低存储器的平均价格2.【答案】A。解析：并联时可以增加存储器的存储字长。知识点 9、死锁死锁是指多个进程在运行过程中因争夺资源而造成
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。如下图所示，有两个资源R1 和R2 供进程P1和P2 共享，P1 已占用资源R1，P2 已占用资源R2，46此时若 P2 继续要求R1,P1 要求R2，则 P1 和 P2 之间便会形成僵局，它们都在等待对方释放自己所需的资源，但同时又不释放自己已占用的资源，从而进入死锁状态。P1R2P2死锁示例（一 ）死锁产生的原因产生死锁的原因可归结为如下两点：1.竞争资源47R1当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。2.进程间推进顺序非法进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。（ 二）死锁产生的必要条件死锁的发生必须具备下列四个必要条件：1.互斥条件指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。2.请求和保持条件指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此48时请求进程阻塞，但又对自己已获得
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的其它资源保持不放。3.不剥夺条件指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。4.环路等待条件指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的P0 正在等待一个P1 占用的资源；P1 正在等待P2 占用的资源，……，Pn正在等待已被P0 占用的资源。（ 三）死锁的处理为保证系统中各进程的正常运行，应事先采取必要的措施，来预防发生死锁。系统已经出现死锁后，则应及时检测到死锁的发生，并采取适当措施来解除死锁。目前，处理死锁的方法可归结为以下四种：1.预防死锁49这是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。2.避免死锁该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。3.检测死锁这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机制，及时地检测出死锁的发
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 生，并精确地确定与死锁有关的进程和资源；然后，采取适当措施，从系统中将已发生的死锁清除掉。4.解除死锁这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱50出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。【习题演练】1.以下各种情况中，属于死锁现象的是（ ）。A.某进程执行了死循环B.某进程为了得到某资源，等待了很长的时间C.某进程为了得到某资源，等待了无限的时间D.操作系统故障1.【答案】C。解析：死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，它们都将无法再向前推进。由死锁概念可知，只有C 选项符合。2.死锁预防是保证系统不进入死锁状态的静态策略，其解决方法是破坏产生死锁的四个必要条件之一。下列方法中破坏了“循环等待”条件的是( )。51A.银行家算法B.一次性分配策略C.剥夺资源法D.资源有序分配法2.【答案】D。解析：资源有序分配法可以破坏“循环等待”条件。3.产生系统死锁的原因可能是由于（ ）。A.进程释放资源B.一个进程进入死循环C.多个进程竞争资源，出现了循环
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 等待D.多个进程竞争共享型设备3.【答案】C。解析：产生系统死锁的原因可能是多个进程竞争资源，从而出现了循环等待。52知识点 10、处理机调度的层次（ 一）作业调度作业调度又称高级调度，或宏观调度，根据某种算法，把外存上处于后备队列中的作业调入内存。（ 二）中级调度中级调度又称中程调度，将那些暂时不能运行的进程调至外存上去等待，此时的进程状态称为挂起状态。中级调度实际上就是存储器管理中的对换功能。（ 三）进程调度进程调度又称低级调度，或微观调度，它决定就绪队列中的哪个进程应获得处理机。53进程调度的方式有两种：非抢占方式和抢占方式。抢占方式基于的原则有三个：优先权原则、短作业/进程优先原则、时间片原则。【习题演练】1.操作系统中的高级调度是指（ ）。A.线程调度B.作业调度C.进程内、外存交换调D.进程调度1.【答案】B。解析：高级调度又称为作业调度、宏观调度或者长程调度，其主要任务是按照一定的原则从外存上处于后备状态的作业中选择一个或者多个，给它们分配内存、输入输出设备等必要的资源，并建立相应的进程，以使作业具有获得竞争处理器的权利。2.CPU 的调度分为高级、中级和低级三种，其中低级调度是指（ ）调度。5
2025-08-10 14:53:51.427 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4A.作业B.交换C.进程D.线程2.【答案】C。解析：进程调度又称低级调度。知识点 11、调度算法（ 一 ）先来先服务调度算法先来先服务（First Come First Served，FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS 算法比较有利于长作业（进程），而不利于短作业（进程）。（ 二）短作业/进程优先调度算法短作业 / 进程优 先调度算法（ShortestJob/Process First，SJ/PF），是指对短作业或短进程55优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。需要注意的是短进程优先调度算法中，每次选择的是已进入系统的、要求服务时间最短的进程。SJ/PF 调度算法的缺点在于：该算法对长作业不利；完全未考虑作业的紧迫程度，因而不能保证紧迫性作业/进程会被及时处理；由于
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 作业/进程的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。56（ 三 ）高优先权优先调度算法作为作业调度算法，此算法常被用于批处理系统中，作为进程调度算法，还可用于实时系统中。对于最高优先权优先调度算法，其关键在于：它是使用静态优先权，还是用动态优先权，以及如何确定进程的优先权。1.静态优先权静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。确定进程优先权的依据：进程类型、进程对资源的需求和用户需求。2.动态优先权动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。动态优先权的变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间57= 响应时间/要求服务时间= 响应比这种算法即为高响应比优先调度算法（HighestResponse-ratio Next，HRN），它既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折中。但每次要进行调度之前，都须先做响应比的计算，这会增加系统开销。
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: （ 四 ）基于时间片的轮转调度算法1.时间片轮转法其基本思想是为每一个进程分配一个时间段，该时间段被称为时间片，即允许该进程运行的时间。每个进程只能依次循环轮流运行，如果时间片结束时进程还在运行，CPU 将剥夺该进程的使用权转而将CPU 分配给另一个进程。如果进程在时间片结束之前阻塞或结束，CPU 当即进行切换。为了实现进程的循环执行，将每次被中止运行的进程存入就绪58队列的末尾，同时将CPU 分配给就绪队列中的队首进程。该算法是一种简单而又公平的算法，使用非常广泛。2.多级反馈队列调度算法前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。【习题演练】1.为了对紧急进程或重要进程进行调度，调度算法应采用（ ）。A.先进先出调度算法B.优先数法59C.最短作业优先调度D.定时轮转法1.【答案】B。解析：为了对紧急进程或重要进程进行调度，可遵
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 循优先权准则，采用优先数法。2.按照作业到达的先后次序调度作业，排队等待时间最长的作业被优先调度，这是指（ ）调度算法。A.先来先服务B.最短作业优先C.定时轮转法D.优先数法2.【答案】A。解析：先来先服务按作业进入的先后次序安排。优点是实现简单，缺点是不利于运行时间短的作业。3.以下（ ）调度算法对CPU 繁忙型进程有利。A.FCFSB.时间片轮转60C.多级反馈队列D.短进程优先3.【答案】A。解析：CPU 繁忙型进程占用CPU时间比较多，更接近于长进程，故选A，FCFS 算法有利于长进程。知识点 12、内存的连续分配连续分配方式，是指为一个用户程序分配一个连续的内存空间。它又可进一步分为：单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配四种。（ 一）单一连续分配单一连续分配是最简单的一种存储管理方式，只能用于单用户、单任务的操作系统中。它将内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除61系统区以外的全部内存空间，提供给用户使用，其中仅能存放一道作业。（ 二）固定分区分配固定分区分配是最早的多道程序的存储管理方式，是指系统先把内存划分成若干个
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 大小固定的分区，一旦划分好，在系统运行期间便不再重新划分。为了满足不同程序的存储需求，各分区的大小可以不等，也可以相等，但在每个分区中只装入一道作业。采用固定分区分配方法存在以下缺点：（1）由于预先规定了分区的大小，使得大作业无法装入，用户不得不采取其他技术加以补救，增加了用户的负担；（2）内存利用率不高，作业很少能恰好填满分区；（3）固定分区无法实现动态扩充内存空间的要求；62（4）由于分区个数在系统初启时确定，因此会限制多道运行的程序个数，特别不适于分时系统交互型用户及内存变化很大的情形。（ 三）动态分区分配动态分区分配算法根据进程的实际需要，动态地分配内存空间。在实现可变分区分配时，涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作三个问题。常用的分配算法主要有以下几种：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。1.首次适应算法该算法将空闲分区按起始地址递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，直至找到第一个能满足要求的空闲分区为止，并按作业的大小从该分区中分割出一块内存空间分配给请求者，剩余的部分仍留在空闲分区表63或链中。该算法优先使用内存低
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 址部分的空闲分区，从而能在高址部分保留较大的空闲分区，但它会在内存的低端留下很多难以利用的小空闲分区，而每次分配时，对空闲分区的查找都必须经过这些分区，从而会增加查找的开销。2.循环首次适应算法该算法由首次适应算法演变而成，每次分配均从上次分配的位置之后开始查找，并将第一个能满足要求的空闲分区分割并分配出去。其特点是内存中的空闲分区分布得更均匀，从而减少查找空闲分区的开销，但它会使存储器中缺乏大的空闲分区。3.最佳适应算法该算法将空闲分区按大小递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，并将第一个能满足要求的空闲分区分割并分配出去。该算法尽管被称为“最佳”，但情况并非总是如此，因为每次分配后所切割下来的剩余部分总64是最小的，它会在内存中留下大量难以利用的小空闲分区。4.最坏适应算法该算法将空闲分区按大小递减的次序排列。当作业申请一个空闲区时，先检查空闲分区链（表）的第一个空闲区是否大于或等于所要求的内存长度，若该空闲区长度小于要求，则分配失败，否则分配相应的存储空间给用户，然后修改和调整空闲分区链（表）。该算法的优点是产生碎片的几率最小，缺点主要是使内存中缺乏大的空闲区。（四 ）可重定
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 位分区分配在动态分区分配方式中，经过一段时间的分配和回收后，内存中会产生很多小的空闲分区。此时，可能有用户程序因找不到足够大的空闲分区而难以装入，但所有空闲分区容量的总和却足以满足该程序的要求。65上述这些不能被利用的空闲分区可采用以下办法加以解决：将内存中的所有作业进行移动，从而将原来分散的多个空闲分区移到同一处拼接成一个大的空闲分区，以装入用户的作业。这种技术被称为“拼接”或“紧凑”。可重定位分区分配方式就是在动态分区分配方式的基础上增加紧凑功能，即在找不到足够大的空闲分区、而空闲分区总和却能满足用户的要求时，对内存空间进行紧凑。由于紧凑时，作业要在内存中移动位置，因此，它需要得到动态重定位技术的支持，这也是它被称为动态重定位分区分配的原因。【习题演练】1.分区存储管理中的首次适应算法，要求把空闲区按照（ ）的次序登记在空闲区表中。A.大小递减B.大小递增C.地址递减66D.地址递增1.【答案】D。解析：首次适应算法要求对空闲分区按地址从小到大的顺序排列。2.可重定位内存的分区分配目的为（ ）。A.解决碎片问题B.便于多作业共享内存C.回收空白区方便D.便于用户干预2.【答案】A。解析：可重定位内存的分区
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 增加了紧凑的功能，通常在找不到足够大的空闲分区来满足用户需求时使用，解决了碎片问题。3.在以下存储管理方案中，不适用于多道程序设计系统的是（ ）。A.单一连续分配B.固定式分区分配C.可变式分区分配D.页式存储管理673.【答案】A。解析：单一连续分配只能用于单用户、单任务的操作系统。知识点 13、基本的分页存储管理在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。（ 一）页面与页表基本的分页存储管理方式中，系统将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。相应地，将内存空间分成若干个与页面同样大小的块，称为物理块或页框。内存的分配以块为单位，并允许将一个进程的若干页分别装入到多个不相邻的物理块中。68为了地址映射的方便，页面的大小通常设置成2 的幂。如果页面的大小为2k 字节，逻辑地址的长度为 n 位，则分页系统的地址结构如下图所示，可将线性的逻辑地址分成两部分：右边的 k 位为页内位移量（即页内地址）W，左边的n-k 位为页号P。n-1 k k-1 0页号P 位移量W分页地址中的地址结构在进
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 程运行时，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页面映射表，简称页表，进程的每个页占页表的一个表项，其中记录了相应页对应的内存块的块号，以及用于分页保护的存取控制信息。下图给出了分页系统的一个内存分配实例，其中页面大小为4K，用户作业的大小为11K。由于进程的最后一页不足一块，因此造成了存放该页的物69理块中部分空间的浪费，这部分被浪费的空间被称为“页内碎片”。分页系统中的内存分配（ 二）地址变换机构页式存储管理系统中，逻辑地址到物理地址的转换是在进程执行的过程中，由硬件地址变换机构借助于页表自动进行的。1.基本的地址变换机构通常将作业的页表存放在内存中，而在系统中只设置一个页表寄存器PTR（Page-Table Register），当一进程因CPU 调度而转入执行状态时，其页表的70内存始址和长度将从该进程的 PCB 中装入页表寄存器。当进程要访问某个逻辑地址中的指令或数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号大于或等于页表长度，便产生越界中断，否则便以页号为索引去检索页表，从中得到该页的物理块号，送入物理地址寄存
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与页内地址拼接，形成对应的物理地址。2.具有快表的地址变换机构由于页表存放在内存中，故CPU 每存取一个指令或数据时都要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次才根据物理地址存取指令或数据，这使得计算机的处理速度降低近1/2。为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”或“快表”，用以存放当前访问的那些页表项。71在进行地址转换时，地址变换机构自动将逻辑地址中的页号并行地与快表中的所有页号进行比较，若其中有与此相匹配的页号，便可直接从快表中读出该页对应的物理块号，并送到物理地址寄存器中。如果在快表中未找到对应的页号，则仍需访问内存中的页表来进行地址转换，同时还必须将得到的页表项与页号—起装入到快表中，若快表已满，则还需根据置换算法淘汰某个快表项，以装入新的内容。（ 三）多级页表现代的大多数计算机系统都支持非常大的逻辑地址空间，此时，页表就变得非常大，要为它分配一大段连续的内存空间将变得十分困难。对于该问题，可利用将页表进行分页，并离散地将各个页表存放到内存块中的办法加以解决，此时，必须为离散分配的页表再建立一张页表，称为外层
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 页表，用来记录存放各页表页的内存块号，从72而形成了两级页表。在使用两级页表的分页系统中，每次访问一个数据需访问三次内存，故同样需增设快表来有效地提高访问速度。如果外层页表仍十分大，则可以将它再进行分页，并离散地存放到内存中，然后再通过一张第二级的外层页表来记录存放各外层页表页的内存块号，这样，便形成了三级页表，并可进一步形成更多级的页表。【习题演练】1.碎片现象的存在使得（ ）。A.内存空间利用率降低B.内存空间利用率提高C.内存空间利用率得以改善D.内存空间利用率不影响1.【答案】A。解析：碎片会占用计算机的内存，使部分内存空间不能满足程序运行的最低标准，从而不能被使用，降低内存的使用效率。732.基本分页存储管理中，若没有引入快表，则每次从主存取指令或取操作数，要（ ）访问主存。A.1 次B.2 次C.3 次D.4 次2.【答案】B。解析：要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次根据物理地址存取指令或操作数。知识点 14、基本的分段存储管理用户通常喜欢将自己的作业按逻辑关系划分成若干段，然后通过段名和段内地址来访问相应的程序或数据，还希望能以段为单位对程序和数据进行共享和保护，并
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 要求分段能动态增长。分页系统虽然能较好地解决动态分区的碎片问题，却难以满足74用户的上述要求，因此又引入了分段式存储管理方式。在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如主程序段、子程序段、数据段等。每个段都有自己的名字，都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，故各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，即其逻辑地址由段号和段内地址所组成。分段地址中的地址具有如下图的结构：段号 段内地址31 16 15 0分段地址中的地址结构在该地址结构中，允许一个作业最长有64K个段，每个段的最大长度为64KB。75（ 一）段表在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地放入内存不同的分区。系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，但更常多的是放在内存中。在配置了段表后，执行中的进程可通过查找段表找到每个段所对应的内存区。故段表是用于实现从逻辑段到物理内存区的映射。（ 二）地址变换机
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 构为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放正在执行进程的段表始址和长度。在进行地址转换时，地址变换机构将逻辑地址中的段号与段表寄存76器中的段表长度进行比较，若段号不小于段表长度，便产生越界中断；否则便以段号为索引去检索段表，从中得到该段的基址和长度；接着检查段内地址是否超过段长，若超过，则发出越界中断信号；若未超过，则将该段的基址与段内地址相加，从而得到对应的物理地址。（ 三 ）分页和分段的主要区别分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换，这是它们的相同之处，其不同主要表现在以下三个方面：①页是信息的物理单位，分页是为提高内存的利用率；段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。②页的大小固定且由系统决定，在系统中只能有一种大小的页面；而段的长度却不固定，取决于用户所编写的程序，通常由编译程序在编译时，根据信息的性质来划分。77③分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。（ 四）
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 段页式存储管理方式为了既能像分页系统那样有效地利用内存，又能像分段系统那样满足用户多方面的需要，操作系统中又引入了段页式存储管理方式。段页式系统的基本原理，是先将用户程序分成若干个段，再把每个段分成若干个页。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成。在段页式系统中，为获得一条指令或数据须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中78取出该页所在的物理块号，并将该块号与页内地址一起形成物理地址；第三次访问是取指令或数据。【习题演练】1.页是（ ）单位，由（ ）划分，它的长度（ ）。A.逻辑，系统，定长B.逻辑，用户，不定长C.物理，用户，不定长D.物理，系统，定长1.【答案】D。解析：页是物理单位，由系统划分，它的长度固定。2.下列方法中，解决碎片问题最好的存储管理方法是（ ）。A.基本页式存储管理B.基本分段存储管理C.固定大小分区管理D.不同大小分区管理792.【答案】A。解析：离散分配方式将一个作业离散地存放到内存中，从而使系统无须紧凑便能很好地解决碎片问题，而离散分配方式中，分页是为解决碎片问题，提高内存的利用率，分段的目的则是为了
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 能更好地满足用户的需要，故选A。3.分段管理提供（ ）维的地址结构。A.1B.2C.3D.43.【答案】B。解析：分段存储管理的地址空间是二维的，标识一个地址时，既需给出段名，又需给出段内地址。80知识点 15、虚拟存储器（一）局部性原理程序局部性原理是指程序在执行时将呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。局限性还表现在下述两方面：1.时间局限性如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。2.空间局限性一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。81基于局部性原理产生了虚拟存储器。（ 二）虚拟存储器的实现虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。虚拟存储器的实现，建
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 立在离散分配的存储管理方式的基础上。目前，所有的虚拟存储器都是采用下述方式之一实现的：1.请求分页系统在分页系统的基础上，增加了请求调页功能和页面置换功能，便形成页式虚拟存储系统。它允许只装入少数页面的程序及数据，便启动运行。之后再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。822.请求分段系统在分段系统的基础上，增加了请求调段及分段置换功能后，便形成段式虚拟存储系统。它允许只装入少数而非所有段的用户程序和数据，即可启动运行。之后再通过调段功能和段的置换功能将暂不运行的段调出，同时调入即将运行的段。（ 三）虚拟存储器的特征虚拟存储器具有多次性、对换性和虚拟性三大主要特征。1.多次性多次性是指虚拟存储器将一个作业分成多次调入内存。多次性是虚拟存储器最重要的特征，任何其它的存储管理方式都不具有这一特征。2.对换性在作业运行期间，虚拟存储器允许将内存中暂时不能运行的进程或暂时不用的程序或数据，调出到外存上，以便腾出足够的内存空间，再把具备运83行条件的进程或进程所需要的程序和数据调入内存。如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。这种对换被
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。而相应的，如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。它们是实现虚拟存储器的基础。3.虚拟性虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。虚拟性是实现虚拟存储器的最重要的目标。虚拟性是以多次性和对换性为基础的，仅当系统允许将作业分多次调入内存，并能将内存中暂时不运行的程序和数据换至盘上时，才有可能实现虚拟存储器；而多次性和对换性又必须建立在离散分配的基础上。84（ 四 ）请求分页存储管理方式请求分页系统是建立在基本分页存储管理基础上的，增加了请求调页功能和页面置换功能。请求分页便成为目前最常用的一种实现虚拟存储器的方式。为了确定所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：1.预调页策略如果进程的许多页是存放在外存的一个连续区域中，则一次调入若干个相邻的页，会比一次调入一页更高效些。但如果调入的一批页面中的大多数都未被访问，则又是低效的。可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。这种策
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。2.请求调页策略85当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由OS 将其所需页面调入内存。由请求调页策略所确定调入的页，是一定会被访问的，再加之请求调页策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。【习题演练】1.实现虚拟存储器的目的是（ ）。A.实现存储保护B.实现程序浮动C.扩充辅存容量D.扩充主存容量1.【答案】D。解析：实现虚拟存储器的目的是为了扩充主存容量。2.虚拟存储器的最大容量是由（ ）决定的。A.计算机系统的地址结构和外存空间B.页表长度86C.内存空间D.逻辑空间2.【答案】A。解析：虚存容量不是无限的，最大容量受外存可利用的总容量和计算机总线地址结构的限制。3.具有虚拟存储功能的管理方法包括（ ）。A.可变分区存储管理B.分页式存储管理C.请求分段存储管理D.段页式存储管理3.【答案】C。解析：虚拟存储功能涉及内存的存储空间扩充问题。请求分段存储管理：作业可以装入不连续的存储空间中，且作业不要求全部装入内存就可以运行，因此具有空间扩充功能；段页式存储管理：作业虽然可以装入不连续
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的存储空间中，但是作业仍要求全部装入才可运行，因此不具备空间扩充功能。87知识点 16、页面置换算法置换算法的好坏直接影响系统的性能。若采用的置换算法不合适，可能出现这样的现象：刚被换出的页，很快又被访问，为把它调入而换出另一页，之后又访问刚被换出的页……如此频繁地更换页面，以致系统的大部分时间花费在页面的调度和传输上。此时，系统看起来很忙，但实际效率却很低。这种现象称为“抖动”。好的页面置换算法能够适当降低页面更换频率（减少缺页率），尽量避免系统“抖动”。为评价一个算法的优劣，可将该算法应用于一个特定的存储访问序列上，并且计算缺页数量，存储访问序列也叫页面走向。（一）最佳（OPT）置换算法最佳置换算法（Optimal，OPT）是选择不再访问的页面或者是在未来最长时间内不再被访问的页88面予以淘汰。最佳页面置换算法是在理论上提出的一种算法，具有最好的性能，但实现是困难的，因为它需要人们预先知道一个进程在整个运行过程中页面走向的全部情况。不过，这个算法可用来衡量其他算法的优劣。（ 二 ）先进先出（FIFO） 页面置换算法FIFO 算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰，该算法的
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 出发点是最早调入内存中的页面，其不再被使用的可能性会比较高。其实现简单、直观，对按线性顺序访问的程序比较合适，面对其他情况则效率不高，因为经常被访问的页面，往往在内存中因停留得最久而被淘汰。一般而言，对于任一作业或进程，如果给它分配的内存页面数越接近于它所要求的页面数，则发生缺页的次数会越少。在极限情况下，这个推论是成立的，如果给一个进程分配了它所要求的全部页89面，则不会发生缺页现象。但是，使用 FIFO 算法时，在给进程或作业分配满足它所要求的页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为Belady 现象。（ 三）最近最久未使用（LRU） 置换算法LRU 算法是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能以“最近的过去”作为“最近的将来”的近似，选择在最近一段时间里最久没有使用过的页面予以置换。因此，LRU 算法是与每个页面最后使用的时间有关的，当必须置换一个页面时，LRU 算法选择过去一段时间内最久未使用的页面。LRU 置换算法是一种比较好的算法，但需要硬件的支持：移位寄存器或栈。关于确定最后使用时间的问题，对于移位寄存器而言，当进程访
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 问某物理块时，要将相应寄存器的位置成“1”。此时，定时信号将每隔一定时间将90寄存器右移一位。如果把 n 位寄存器的数看做是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。对于栈而言，每当访问一个页面时，便将它的页面号从栈中移出，压入栈顶。因此栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。（ 四）Clock 置换算法LRU 算法是较好的一种算法，但它要求有较多的硬件支持，故在实际应用中大多采用LRU 的近似算法。Clock 算法就是用得较多的一种LRU 近似算法。Clock 置换算法采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的表针，指向可能要淘汰的页面。它在存储分块表的每一表项中增加一个访问位，操作系统定期地将它们置为 0。当某一页被访问时，由硬件91将该位置为 1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0 后还未使用过，可把该位是0 的页淘汰出去，因为在最近一段时间里它未被访问过。由于该算法是循环地检查各页面的使用情况，故称为Clock 算法。但因该算法只有一位访问位，只能用它表示该页是否已经使
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用过，而置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法（Not Recently Used，NRU）。【习题演练】1.在请求调页中可采用多种置换算法，其中LRU 是（ ）置换算法。A.最佳B.最近最久未用C.最近未用D.最少使用921.【答案】B 。解析：LRU 是最近最久未用置换算法。2.Clock 置换算法又称为（ ）。A.最久驻留置换算法B.最近最久未使用置换算法C.最近未使用置换算法D.最少使用置换算法2.【答案】C。解析：最近未使用算法是Clock置换算法。知识点 17、线性表（ 一）概念线性表是最基本、最简单、也是最常用的一种数据结构。线性表是具有n （n≥0）个类型相同的数据元素组成的有限序列。93线性表的长度：线性表中元素的个数。空表：长度为0 的线性表。（ 二）特点线性表中一定存在唯一的“第一元素”。线性表中一定存在唯一的“最后元素”。除最后一个元素之外，均有唯一的后继（后件）。除第一个元素之外，均有唯一的前驱（前件）。（ 三）表示方式1.线性表的顺序表示线性表中的数据元素是用一组地址连续的存储单元依次存储的。顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。942.线性表的链式表示（1）线性链表用一组任意的存储单元存储线性表的数据元素，存储单元不一定是连续的，可以连续，也可以不连续。（2）循环链表循环链表中最后一个结点的后继指针指向头结点，使整个链表形成一个环形。（3）双向链表在双向链表中，每个结点有两个指针域，一个指向它的直接后继，另一个指向它的直接前驱。【习题演练】1.下列有关线性表的叙述中，正确的是（ ）。A.线性表中的元素之间是线性关系B.线性表中至少有一个元素C.线性表中任何一个元素有且仅有一个直接前驱95D.线性表中任何一个元素有且仅有一个直接后继1.【答案】A。解析：线性表可以为空，并且线性表中的第一个结点是没有前驱结点的，最后一个结点没有后继结点。知识点 18、栈和队列（ 一）栈的定义1.栈的定义栈是一种只能在一端进行插入或删除操作的线性表。栈中的数据元素是线性关系。栈顶：允许进行插入或删除操作的一端。栈底：不允许进行插入和删除操作，固定不变的一端。入栈：栈的插入操作。出栈：栈的删除操作。962.栈的
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 特点先进后出（First In Last Out，简称FILO）、后进先出（Last In First Out，简称LIFO）。3.栈的存储结构（1）顺序栈使用顺序存储结构存储栈。（2）链式栈使用链式存储结构存储栈。（ 二）队列的定义1.队列的定义97队列是一种运算受限制的线性表，元素的添加在表的一端进行，而元素的删除在表的另一端进行。队头：允许删除元素的一端。队尾：允许添加元素的一端。入队：向队列添加元素。出队：从队列中删除元素。2.队列的特点先进先出（FIFO）（先入队的元素先出队，后入队的元素后出队）。3.存储结构顺序队：使用顺序存储结构的队列。链队：使用链式存储结构的队列。98【习题演练】1. 下述有关栈和队列的区别，说法错误的是( )。A.栈是限定只能在表的一端进行插入和删除操作B.队列是限定只能在表的一端进行插入和在另一端进行删除操作C.栈和队列都属于线性表D.栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（n）1.【答案】D。解析：栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（1）。因为都是在端点处进行的操作。2.为解决计算机主机与打印机之间速度不匹配问题，
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是( )。99A.栈B.队列C.树D.图2.【答案】B。解析：主机将数据依次写入，打印机依次取出，应该属于先进先出的特点，既使用的逻辑结构是队列。知识点 19、树（ 一）定义树形结构是一种重要的非线性结构，树是n 个结点的有限集合，在任一棵非空树中：（1）有且仅有一个称为根的结点。（2）其余结点可分为m 个互不相交的集合，而且这些集合中的每一集合都本身又是一棵树，称为根的子树，因此树是递归结构。100（ 二）基本术语结点：包含一个数据元素及若干指向其子树的分支。结点的度数：结点的非空子树个数。树的度：树中各节点中度的最大值。分支结点：度不为0 的结点。叶子结点：度为0 的结点。孩子：结点的子树的根。双亲：结点的直接前驱。兄弟：同一个双亲的孩子之间互为兄弟。堂兄弟：双亲在同一层的结点互为堂兄弟。祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。子孙：以某结点为根的子树中的所有结点，都是该结点的子孙。层次：从根开始，根为第一层，根的孩子为第二层，以此类推。101树的深度（或者高度）：树
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 中结点的最大层数。结点的深度和高度：结点的深度是从根结点算起的，根结点的深度为 1；结点高度是从最底层的叶子结点算起的，最底层叶子结点的高度为 1。有序树：子树按照一定的次序从左向右排列，相对次序不能随意变换。无序树：子树无一定的次序排列，相对次序可以随意变换。丰满树：即理想平衡树，要求除最底层外，其他层都是满的。森林：是由零个或多个不相交的树所组成的集合。【习题演练】1.如果在数据结构中每个数据元素只可能有一个直接前驱，但可有多个直接后继，则该结构是( )。A.栈102B.队列C.树D.图1.【答案】C。解析：树结构的每个结点都有一个前驱，但可以有多个后继。知识点 20、二叉树（ 一）定义二叉树是一个连通的无环图，并且每一个顶点的度不大于 2。有根二叉树还要满足根结点的度不大于 2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2 个子结点。（ 二）主要性质①二叉树的第 i 层上至多有2i- 1 个结点。②深度为k 的二叉树至多有2k- 1 个结点。103（补充概念：a.满二叉树：深度为k，有2k- 1 个结点。b.完全二叉树：给满二叉树的结点编号，从上至下，从左至右，n 个结点的完全二叉树中结点在对应
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 满二叉树中的编号正好是从 1 到n。③叶子结点 n0，度为2 的结点为n2，则n0 =n2+1。④n个结点的完全二叉树深度为 l㎀ g2n」+1。⑤n 个结点的完全二叉树，结点按层次编号。a.i 的双亲是1 n/2，如果i =1时为根（无双亲）。b.i 的左孩子是2i，如果2i>n，则无左孩子。c.i 的右孩子是2i + 1，如果2i + 1>n 则无右孩子。（ 三）存储结构1.顺序存储结构顺序存储结构即用一个数组来存储一棵二叉树，这种存储方式最适合于完全二叉树，用于存储104一般二叉树则会浪费大量的存储空间。将完全二叉树中的结点值按编号依次存入一个一维数组中，即完成了一棵二叉树的顺序存储。例：结点 A B C D E数组下标 0 1 2 3 4 52.链式存储结构二叉树中的每个结点用一个链结点来存放，结点结构如下：lchild data rchild其中，data 表示结点数据域，用于存储对应的数据元素；lchild 和 rchild 分别表示左指针域和右指针域，分别用于存储左孩子结点和右孩子结点的位置。（ 四）遍历算法若以L、D、R 分别表示遍历左子树、遍历根结点和遍历右子树，则有六种遍历方案：DLR、L
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: DR、LRD.DRL、RDL、RLD。若规定先左后右，则只有105前三种情况，分别是：DLR--先（根）序遍历；LDR--中（根）序遍历；LRD--后（根）序遍历。【习题演练】1.设非空二叉树中度数为0 的结点数为n0，度数为 1 的结点数为n1，度数为2 的结点数为n2，则下列等式成立的是（ ）。A.n0=n1+n2B.n0=2n1+1C.n0=n2+1D.n0=n1+11.【答案】C。解析：二叉树中度为0 的结点个数等于度为2 的结点个数加一。2.一棵树高为k 的完全二叉树至少有（ ）个结点。A.2k- 1B.2k- 1- 1C.2k- 1106D.2k2.【答案】C。解析：完全二叉树层次最小为k时，前k- 1 层都是满的，第k 层有一个结点。3.深度为 5 的完全二叉树的结点数不可能是( )。A.15B.16C.17D.183.【答案】A。解析：深度为5 的完全二叉树结点最多为二的 5 次方减一个，即31 个，最少为 16个。4.二叉树的先序遍历和中序遍历如下：先序遍历：EFHIGJK，中序遍历：HFIEJKG，则二叉树根结点为（ ）。A.EB.FC.G107D.H4.【答案】A。解析：先序遍历顺序为根
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 左右，所以树根为E。知识点 21、图（ 一）图的定义图是由顶点集V 和集合E（边的集合）组成的，可以定义为G=（V，E）。V 是顶点的非空有穷集合，E 是可空的边的有穷集合。（ 二）图的术语1.无向图对于一个图，若每条边都是没有方向的，则称该图为无向图。如下图：108对于此无向图，(Vi，Vj)和(Vj，Vi)表示的是同一条边。无向图的顶点集和边集分别表示为：V(G)={V1，V2，V3，V4，V5}E(G)={(V1，V2)，(V1，V4)，(V2，V3)，(V2，V5)，(V3，V4)，(V3，V5)，(V4，V5)}2.有向图对于一个图，若每条边都是有方向的，则称该图为有向图。如下图：109在此有向图中，<Vi，Vj>和<Vj，Vi>是两条不同的有向边。有向边又称为弧。终端点也称为弧头，初始点也称为弧尾。有向图的顶点集和边集分别表示为：V(G)={V1，V2，V3}E(G)={<V1，V2>，<V2，V3>，<V3，V1>，<V1，V3>}3.无向完全图和有向完全图具有n(n- 1)/2 条边的无向图为无向完全图。具有n(n- 1)条边的有向图称为有向完全图。4.稀疏图有很少条边或弧的图。5.稠密图有很
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 多条边或弧的图1106.顶点图中的数据元素通常称为顶点。7.顶点的度无向图中，顶点的度表示以该顶点作为端点的边的数目。有向图中，顶点的度分为入度和出度。入度表示以该顶点为终点的边的数目，出度是以该顶点为起点的边的数目，该顶点的度等于其入度、出度之和。8.回路、环指一条路径的起点和终点为一个顶点。9.连通图在无向图中，如果从顶点v1 到顶点v2 有路径，则称v1 和v2 是连通的。如果图中任意两个顶点都是连通的，则称图是连通图。10.连通分量指的是无向图中的极大连通子图。11.强连通图111在有向图G 中，对任意一对顶点vi 和vj（vi≠vj），若从vi 到vj 和从vj 到vi 都存在路径，则称G 是强连通图。12.强连通分量有向图中的极大强连通子图称为有向图的强连通分量。（ 三）遍历算法从图的某一顶点出发，访问图中其余顶点，且使每个顶点仅被访问一次，这一过程称为图的遍历。图的遍历分为深度优先搜索遍历和广度优先搜索遍历。1.广度优先广度优先搜索类似于树的按层次遍历。选取图中任意一个顶点Vi作为出发点，按照下列步骤遍历图。（1）首先访问出发点Vi。112（2）接着依次访问Vi的所有未被访问过的邻接点Vi1，V
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: i2，Vi3，ⅆ , Vit并均标记为已访问过。（3）然后再按照Vi1，Vi2，ⅆ , Vit的次序，访问每一个顶点的所有未被访问过的顶点，并均标记为已访问过。（4）依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。2.深度优先深度优先搜索（DFS）类似于树的先序遍历。【习题演练】1.具有n 个结点的连通图至少有（ ）条边。A.n-1B.nC.n（n- 1）/2D.2n1.【答案】A。解析：具有n 个结点的连通图至少有n-1 条边。1132.在有向图中每个顶点的度等于该顶点的( ) 。A.入度B.出度C.入度与出度之和D.入度与出度之差2.【答案】C。解析：有向图的某个顶点v，把以 v 为终点的边的数目称为v 的入度；以v 为始点的边的数目称为v 的出度；v 的度则定义为该顶点的入度和出度之和。3.设连通图G 中的边集E={（a，b），（a，e），（a，c），（b，e），（e，d），（d，f），（f，c）}，则从顶点a 出发可以得到一种深度优先遍历的顶点序列为（ ）。A.abedfcB.acfebdC.aebdfcD.aedfcb1143.【答案】A。图的深度优先遍历类似于树的前序遍历。采
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用的搜索方法的特点是尽可能先对纵深方向进行搜索。知识点 22、数据模型（ 一）数据模型的概念数据模型是对现实世界数据特征的抽象。也就是说，数据模型是用来描述数据、组织数据和对数据进行操作的。（ 二）两类数据模型在数据库中模型主要分为两大类：一类为概念模型；另一类为逻辑模型和物理模型。概念模型也称为信息模型，在数据库设计阶段，由设计员按照用户观点建模实现对现实世界的概念抽象。115http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8656077逻辑模型包括网状、层次、关系和对象模型等，由设计人员按照计算机观点建模实现概念模型到适应某DBMS 的逻辑模型的转变。再由DBMS 完成逻辑到物理模型的转变。物理模型是数据最底层的抽象，描述数据的存储方式和方法。（ 三 ）现实世界的数据化过程现实世界 信息世界 数据世界概念模型现实世界的数据化过程【习题演练】1.常见的逻辑模型有3 种，它们是（ ）。A.字段名、字段类型和记录116DBMS支持下的数据模型事物本身B.层次、关系和网状C.环状、层次和关系D.网状、关系和语义1.【答案】B。解析：常见的数据模型有3 
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 种，即按图论理论建立的层次结构模型和网状结构模型以及按关系理论建立的关系结构模型。知识点 23、概念模型概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有利工具，也是数据库设计人员和用户之间进行交流的语言。（ 一）常用术语1.实体117客观存在并且可以区分的具体事物或者抽象概念。例如，一个学生、一个宿舍、一个操作流程等等。2.属性属性是对客观事物特征的一种反映，是实体具有的某个特征。例如，学生实体中有学号属性、姓名属性、性别属性，年龄属性、所在系属性等。属性有属性名称和属性值之分，例如，姓名为属性名，则“李白”就是这个属性的值。3.码在现实生活中，实体是可以互相区分的，所以没有两个完全相同的实体，即不能够有两个实体在各自对应属性上的属性值都是相同的。4.域一个属性的取值范围被称为域。例如，性别属性的属性值只能为“男”或者只能为“女”。5.实体型118实体集的名称及其所有属性名的集合称为实体型。例如，学生（学号，姓名，性别，年龄，所在系）就是学生实体集的实体型。6.实体集所有属性名完全相同的实体集合在一起，称为实体集。比如说学生实体集，教师实体集等。（ 二）概念模型
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的表示方法：实体-联系图E-R 图中文称为实体-联系图，它是概念模型中的一种表示形式。E-R 图主要包含三个概念，分别是：实体集、联系集和属性。1.实体-联系图的表示方法实体型：用矩形表示，矩形框内写明实体名。属性：用椭圆表示，并用无向边将其对应的实体型连接起来。联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或者M：N）。1192.联系两个实体集之间的联系可归纳为以下三类：（1）一对一联系（1:1）如果对于实体集A 中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A 与实体集B 具有一对一关系，记为 1：1。例如，一个学校只能有一个校长；一个账号只能提供给一个人使用等。（2）一对多联系（1：N）和多对一联系（N：1）如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集B 中的每一个实体，实体集A 中至多只有一个实体与之联系，则称实体集A 与实体集B 有一对多的联系，记为 1：n。例如，一个工厂可以有若干个员工，而一个员工只能属于一个工厂；一个导师可以有若干个学
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 员，而一个学员只能属于一个导师等。（3）多对多联系（M：N）120如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集 B 中的每一个实体，实体集A 中也有M 个实体（M>=0）与之联系，则称实体集A 与实体集B具有多对多的联系，记为M：N。例如，一门课程可以被多个学生选择，一个学生可以选择多门课程等。【习题演练】1.下列实体类型的联系中，属于一对一联系的是（ ）。A.教研室对教师的所属联系B.父亲对孩子的联系C.省对省会的所属联系D.供应商与工程项目的供货联系1.【答案】C。解析：实体之间的联系分为：一对一、一对多和多对多。因为每一个省都只有一个省会，而一个省会只属于一个省，所以省和省会之121间是一对一的联系。而A 选项属于一对多的关系；B 选项属于一对多的关系；D 选项属于多对多的关系。2.在E-R 图中，用长方形表示（ ），用椭圆表示（ ）。A.联系、属性B.属性、实体C.实体、属性D.什么也不代表、实体2.【答案】C。解析：矩形表示实体，椭圆表示属性。3.关系模型中，候选码（ ）。A.可由多个任意属性组成B.至多由一个属性组成C.可由一个或多个其值能惟一标识
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 该关系模式中任何元组的属性组成D.以上都不是1223.【答案】C。解析：候选码可以是一个也可以是多个，但是必须能唯一标识元组。知识点 24、关系模型（ 一）简介关系数据模型是目前最重要的一种数据模型。关系数据库系统采用关系数据模型作为数据的组织方式。有层次数据模型和网状模型相比，关系模型概念简单、清晰，并且具有严格的数据基础，形成了关系数据理论，操作也直观、容易，因此易学易用。支持关系数据模型的DBMS 称为关系型数据库管理系统RDBMS。与其他数据模型相同，关系数据模型也是由数据结构、数据操作和完整性约束三个部分组成。123（ 二）关系模型的性质列是同质的，即同一列的分量值应该出自相同的域。列名是唯一的，即在同一个关系中不能出现完全相同的两个属性名称。行的顺序无关，即元组与元组之间互换位置，不相互影响。列的顺序无关，即列于列之间互换位置，不相互影响。任何两行不能完全相同，即不能出现两个完全相同的元组。分量必须是原子量，即是不可分的基本数据项。【习题演练】1.下列叙述正确的为（ ）。A.关系中元组没有先后顺序，属性有先后顺序B.关系中元组有先后顺序，属性没有先后顺序124C.关系中元组没有先后顺序，属性也没有
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 先后顺序D.关系中元组有先后顺序，属性也有先后顺序1.【答案】C。解析：关系中元组的顺序无关，属性的顺序也无关。知识点 25、关系操作和完整性约束（一 ）基本的关系操作1.查询操作关系的查询表达能力很强，是关系操作最主要的部分。查询操作又可以分为：选择、投影、连接、除、并、差、交、笛卡尔积等。2.更新操作更新操作又可以分为：插入、删除、修改。3.基本操作125关系的基本操作有五种，分别是：选择、投影、并、差、笛卡尔积。其他操作是可以用基本操作来定义和导出的。就像乘法可以用加法定义和导出一样。4.关系操作的特点关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应地，非关系数据模型的数据操作方式则为一次一记录的方式。（ 二）关系的三类完整性关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。1.实体完整性126（1）规则若属性（指一个或者一组属性）A 是基本关系R 的
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 主属性，则A 不能取空值。按照实体完整性规则的规定基本关系的主码都不能取空值。如果主码由若干属性组成，则所有这些主属性都不能取空值。（2）具体说明①实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。②现实世界中的实体是可以区分的，即它们具有某种唯一性标识。③相应地，关系模型中以主码作为唯一标识。④主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与②点相矛盾，因此这个规则称为实体完整性。2.参照完整性127若属性（或属性组）F 是基本关系R 的外码，它与基本关系S 的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R 中每个元组在F上的值必须为：①或者取空值（F 的每个属性值均为空值）；②或者等于 S 中某个元组的主码值。3.用户自定义完整性任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件。它反映某一具体应用所涉及的数据必须满足的语义要求。例如某个属性必须取值唯一
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、某个非主属性也不能取空值等。【习题演练】1281.若属性A是关系R 的主属性，则A不能为空，该规则称为（ ）。A.实体完整性规则B.属性完整性规则C.参照完整性规则D.用户定义完整性规则1.【答案】A。解析：数据完整性包括：实体完整性、参照完整型和用户定义完整性。实体完整性即规定主键不能为空。2.关系模型有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。定义外键实现的是（ ）完整性。A.实体完整性B.参照完整性C.用户定义的完整性D.实体完整性、参照完整性和用户定义的完整性1292.【答案】B。解析：定义外键实现的是参照完整性。知识点 26、SQL 常用语句SQL（Structured Query Language），即结构化查询语言，是关系数据库的标准语言。当前，几乎所有的关系数据库管理系统软件都支持 SQL，许多软件厂商对 SQL 的基本命令集还进行了不同程度的扩充和修改。SQL 集数据查询、数据操纵、数据定义和数据控制功能于一体，是一个综合的、通用的、功能极强、简洁易学的语言。（ 一）数据查询1.语句格式SELECT [ALL|DISTINCT] column_listFROM table_
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: list130[WHERE search_condition][GROUP BY group_by_list][HAVING search_condition][ORDER BY order_list[ASC|DESC]]2.运算符算术比较运算符：=，<，<=，>，>=，<>，!>，!<逻辑运算符：AND、OR、NOT所属集合运算符：IN、NOT IN谓词：EXISTS（存在)、BETWEEN…AND（范围）、LIKE（匹配）、IS NULL（空值）3.统计函数常见的统计函数统计函数 描述COUNT（*） 计算记录的个数COUNT（[DISTINCT]列名） 对一列中的值计算个数SUM（[DISTINCT]列名） 求某一数值型列的总和AVG（[DISTINCT]列名） 求某一数值型列的平均值131统计函数 描述MAX（[DISTINCT]列名） 求某一列的最大值MIN（[DISTINCT]列名） 求某一列的最小值4.连接查询在查询的数据涉及到多个表时，必须用连接条件将这些表连接起来。5.嵌套查询在 SQL 语句中，可以将一个查询嵌入在另一个查询的WHERE 子句中，这类查询称为嵌套查询。一般内层的查询称为子查
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 询，将外层的查询称为父查询。嵌套的 SELECT 查询使得 SQL 可以实现各种复杂的查询，子查询必须用括号括起来。6.示例a.查询计算机系年龄在20 岁以下的学生姓名：SELECT SnameFROM StudentWHERE Sdept=’CS’ AND Sage<20；b.查询选修了3 门以上课程的学生学号：132SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*)>3;（ 二）数据更新1.INSERT 语句（1）语句格式INSERT INTO<表名>[（<属性名清单>）]VALUES（<常量清单>）;（2）实例：在Employee表中插入一职工记录。INSERT INTO EmployeeVALUES（’2032’，’张杉’，’男’，28，’工程师’，’01 ’）;2.UPDATE 语句（1）语句格式UPDATE<表名>133SET <列名>=<表达式>[,<列名>=<表达式>][WHERE<条件>];（2）实例：在工资表中，将所有职工的基本工资都增加500。UPDATE SalarySET Basepay=Basepay+500;3.DELETE 语句（1）语句格
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 式DELETE FROM <表名>[WHERE<条件>]（2）实例：从职工表中删除Eno（职工号）为1003 的记录。DELETE FROM EmployeeWHERE Eno=’1003’;【习题演练】1341.SQL 语言的标准库函数 COUNT 、SUM 、AVG、MAX 和MIN 等，不允许出现在下列哪个子句中（ ）。A.SELECTB.HAVINGC.WHERED.GROUP，HAVING1.【答案】C。解析：SQL 语言的标准库函数COUNT、SUM、AVG、MAX 和MIN 等，不允许出现在WHERE 子句中。2.在SQL 语句中，与X BETWEEN 20 AND 30等价的表达式是（ ）。A.X>=20 AND X<30B.X>=20 AND X<=30C.X>20 AND X<=30D.X>20 AND X<302.【答案】B。解析：BETWEEN A AND B 是指在 A-B 之间的范围，且包括A 和B 。故与X135BETWEEN 20 AND 30 等价的表达式是 X>=20AND X<=30。3.一个查询的结果成为另一个查询的条件，这种查询被称为（ ）。A.内查询B.连接查询C.
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 自查询D.子查询3.【答案】D。解析：一个查询的结果成为另一个查询的条件，这种查询被称为子查询，也叫嵌套查询。4.在考试表中，要将58 分、59 分的分数调整到60 分，下列SQL 语句中能实现的是（ ）。A.UPDATE 考试表 SET 分数 = 60 HAVING分数>=58 AND 分数<60B.UPDATE 考试表 SET 分数 = 60 WHERE分数>=58 AND 分数<60136C.UPDATE 考试表 SET 分数 = 60 WHERE分数 IN(58,59)D.UPDATE 考试表 SET 分数 = 60 WHERE分数 BETWEEN 58 AND 594.【答案】C。解析：由题知至包含58 分和59分，符合题意的只有C 选项。知识点 27、计算机网络分类（一）按作用范围1.局域网（LAN）局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，137http://baike.baidu.com/view/
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 7886.htmhttp://baike.baidu.com/view/4321959.htmhttp://baike.baidu.com/view/281640.htm可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。2.城域网（MAN）城域网（Metropolitan Area Network）是在一个城市范围内所建立的计算机通信网，简称MAN。属于宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在 100 兆比特/秒以上。3.广域网（WAN）广域网（WAN，Wide Area Network）也称远程网（Long Haul Network）。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。（ 二）按拓扑结构1.星型拓扑结构138星型拓扑结构是一种以中央结点为中心，把若干外围结点连接起来的辐射式互联结构，各结点与中央结点通过点与点方式连接，中央结点执行集中式通信控制策略，因此中央结点相当复杂，负担也重。2.树型拓扑结构树型拓扑结构是一种层次结构，
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结点按层次连接，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。3.总线型拓扑结构总线型拓扑结构是采用单根传输作为共用的传输介质，将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上。使用总线型拓扑结构需解决的是确保用户使用媒体发送数据时不能冲突。在点到点的链路配置时，如果链路是半双工操作，只需使用简单的机制便可保证两个用户轮流工作。在一点到多点方式中，对线路的访问依靠控制139http://baike.baidu.com/view/47398.htmhttp://baike.baidu.com/view/420833.htm端的探询来确定。采取分布式访问控制策略来协调网络上计算机数据的发送。4.环型拓扑结构环型拓扑结构是使用公共电缆组成一个封闭的环，各结点直接连到环上，信息沿着环按一定方向从一个结点传送到另一个结点。环接口一般由发送器、接收器、控制器、线控制器和线接收器组成。5.网状拓扑结构网状拓扑结构，这种拓扑结构主要指各结点通过传输线相互连接起来，并且每一个结点至少与其他两个结点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，不常用于局域网。（ 三）按使用范围1.公用网一般是国家的邮电部门建造的网络。“公用”的意思就是从所有愿意按邮电部门规定交纳费用的140人都可以使用。因此，公用网也可以称为公众网，例如CHINANET、CERNET 等。2.专用网“专用网”是某个部门为本单位的特殊工作的需要而建立的网络。专用网指专用于一些保密性要求较高的部门的网络，比如企业内部专用网、军队专用网，尤其是涉及国家机密的部门。这种网络不向本单位以外的人提供服务。例如，军队、铁路、电力等系统均有本系统的专用网。【习题演练】1.局域网常用的基本拓扑结构有（ ）、环型和星型。A.层次型B.总线型C.交换型D.分组型1411.【答案】B。解析：局域网常用的拓扑结构有星型、环型、树型、总线型。网状型通常应用于广域网。知识点 28、网络地址（ 一）物理地址网卡物理地址存储器中存储单元对应实际地址称物理地址。MAC（介质访问控制）地址是识别LAN（局域网）结点的标识。网卡的物理地址通常是由网卡生产厂家烧入网卡的EPROM（一种闪存芯片，通常可以通过程序擦写），它存储的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址。物理地址一般记作 06-2E-1
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4-F9-5A-23，48 比特的不同组合。142（ 二）IP 地址是为网络每台计算机分配的唯一标识，为了使连入网络的众多计算机主机在通信时能够互相识别，网络中的每一台主机都有唯一的32 位地址。IP 地址一般用小数点隔开的十进制数，即点分十进制表示，如202.120.70.23。以点分十进制的形式表示IP 地址时，用小数点将 IP 地址分为四部分，每个部分的范围为0～255。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志该主机（或路由器）。两级的IP 地址可以记为：IP 地址：：= { <网络号>，<主机号>}（ 三）IP 地址分类汇总143IP 地址分类类型 IP 范围 私有IPA 1-126 10.0.0.1-10.255.255.255B 128-191 172.16.0.1- 172.31.255.255C 192-223 192.168.0.1- 192.168.255.255D 224-239E 240-254（ 四）特殊的 IP 地址主机号全为 1 表示本网段的内部广播地址，不能分给计
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 算机使用。主机号全为0 表示本网络的网段，计算机所在网络。127 开头的本地回环地址，主要测试TCP/IP 协议正确性。D 类地址为组播地址。主要是路由协议OSPF等使用。14410.0.0.110.255.255.255172.16.0.1172.31.255.255192.168.0.1192.168.255.255E 类地址用于研究使用。169.254.*.*的地址是当计算机自动获取IP 地址失败后的标识，但不能用于计算机之间的通信。（五）IPv6 地址IPv6 是InternetProtocoLVersion 6 的缩写，是下一代 IP 地址，用于替代现行版本 IP 协议（IPv4）的下一代 IP 协议，目的是为解决 IP 地址紧缺的问题。扩大地址的可用空间，满足计算机网路增长的需求。IPv6 将地址32 位（IPv4）增大到了 128 位二进制，使得地址数量变为原来的2 的96 次方倍，地址数量更多，适应未来网络扩展的需求。【习题演练】1.以下IP地址中，属于A 类地址的是（ ）。A.52.213. 12.23B.210.123.23. 12145C.223.123.213.23D.156.123.
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 32. 121.【答案】A。解析：A 类地址的第一个部分范围是 1～126，符合的只有A 选项。2.IPv4 地址和IPv6 地址的位数分别为（ ）。A.4，6B.8，16C.16，24D.32，1282.【答案】D。解析：IPv4 地址和Ipv6 地址的位数分别为32，128。知识点 29、子网掩码（ 一）概念子网掩码是一种用来指明一个 IP 地址的网络位和主机位，知道了 IP 地址的网络位，就可以确定146计算机 IP 地址所在的网络，知道了主机位就可以确定该 IP 地址所在网络的位置。（ 二）功能子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码是一个32 位地址，一般在书写的时候也是点分十进制表示。在子网掩码中，1 表示网络位，0 表示主机位。（ 三）默认子网掩码A 类网络的子网掩码为255.0.0.0，B 类网络的子网掩码为 255.255.0.0，C 类网络的子网掩码为255.255.255.0。（ 四）求网络号主机号全为0 的地址表示网络号。第一步把IP 地址转化为二进制。147255.0.0.0255.255.0.0255.255.255.0第二步把子网掩码转化为二进制。第三步保留
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 子网掩码中 1 所对应的部分，主机位用0 填充。第四步转为点分十进制。（五） 求主机号第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 0 所对应的部分。（六） 求广播号主机号全为 1 的地址表示广播号。第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 1 所对应的部分，主机位用 1 填充。第四步转为点分十进制。148（七） 子网划分计算形成子网的数量计算：从主机位借位当网络位来使用。借位数 子网个数 借位数 子网个数1 21 = 2 4 24 =162 22 = 4 5 25 =323 23 =8 6 26 = 64【习题演练】1.以下关于子网掩码的作用，错误的是（ ）。A.标识 IP 地址的网络部分和主机部分B.主机部分对应的子网掩码部分全为“0”C.网络部分对应的子网掩码部分全为“1”D.通过子网掩码标识网络的类型1491.【答案】D。解析：子网掩码是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位。其中主机部分对应的子网掩码部分全为0，网络部分全为 1。2.一个子网掩码是 255.255.240.0
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，这个子网能拥有的最大主机数是（ ）。A.240B.255C.4094D.655342.【答案】C。解析：255.255.240.0，将子网掩码中的240 转换为二进制，240=11110000，所以进行子网划分的时候借走了4 位主机位充当网络位，能够形成 2^4= 16 个子网，每个子网中的 IP 数量2^ 12=4096 ，但是能够分配给计算机使用的只有4096-2=4094。150255.255.240.0知识点 30、网络设备（一）局域网设备1.中继器中继器（Repeater）是局域网互连的最简单设备，工作在OSI 体系结构的物理层，它接收并识别网络信号，然后再生信号并将其发送到网络的其他分支上。信号在传输线路上传输的时候，受到距离、噪音、电阻等影响，使得信号传输的距离不能是长到无限远，在传输一定距离后，信号需要加强。如果在线路中间插入放大器，则伴随信号的放大，噪音也被放大了。中继器的功能是对接收信号进行再生和发送。2.集线器集线器属于物理层设备。集线器是有多个端口的中继器，简称HUB。151集线器在创建网络时，一般是以星型或树型拓扑结构为主。集线器没有MAC地址表，采用广播方式发送，当网络中的主机数
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 量过多的时候，就会在网络生成广播风暴。以集线器为主要网络设备的网络被称为共享式以太网。3.网卡网络接口卡NIC（Network Interface Card）又称网卡或网络适配器。网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。4.网桥在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据MAC 帧的目的地址对收到的帧进行转发。152网桥不隔绝广播风暴。5.交换机以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。（ 二）广域网设备1.网关网关（Gateway）又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。2.路由器153路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，以最佳路径，按前后顺序发送信号。3.调制解调器调制解调器（modem）是一种计算机硬件，它能把计算机的数字信号翻译成可沿普通电话线传送的模拟信号，是家用电话拨号上网的必不可上少的设备。调制：将数字信号转化为模拟信号。解调：将模拟信号转化为数字信号。【习题演练】1.集线器是工作在（ ）的设备。A.物理层B.链路层C.网络层D.运输层1541.【答案】A。解析：中继器和集线器就是物理层的设备。2.在下列网间连接器中，（ ）在数据链路层实现网络互连。A.中继器B.网桥C.路由器D.网关2.【答案】B。解析：网桥是数据链路层的设备，中继器是物理层设备，路由器是网络层设备，网关在传输层及其以上实现网络互联。155知识点 31、信息加密技术（ 一）信息加密信息加密是指使有用的信息变为看上去似为无用的乱码，使攻击者无法读懂信息的内容从而保护信息。任何一个加密系统至少由下面四个部分组成：1.未加密的信息，也称明文。2.加密后的信息，也称密文。3.加密解密设备或算法。4.加密解密的密钥。发送方用加密密钥，通过加密设备或算法，将信息加密后发送出去。接收方在收到密文后，用解密密钥将密文解密，恢复为明文。如果传输中有人窃取，他只能
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 得到无法理解的密文，从而对信息起到保密作用。156其中，密钥是唯一能够控制明文与密文之间变换的关键，通常是一随机字符串，在计算机上实现的数据加密算法，其加密或解密变换是由一个密钥来控制的。（ 二）对称加密1.概念对称密码体制是指如果一个加密系统的加密密钥和解密密钥相同，或者虽然不相同，但是由其中的任意一个可以很容易地推导出另一个，即密钥是双方共享的，则该系统所采用的就是对称密码体制。2.加密过程3.对称加密算法特点157对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。常见的对称加密算法：DES 算法，3DES 算法，TDEA 算法，Blowfish 算法，RC5 算法， IDEA 算法。（ 三）非对称密钥加密1.概念公钥密码体制指一个加密系统的加密密钥和解密密钥是不一样的，或者说不能由一个推导出另一158个。其中一个称为公
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 钥用于加密，是公开的，另一个称为私钥用于解密，是保密的。公钥密码体制解决了密钥的管理和发布问题，每个用户都可以把自己的公开密钥进行公开，如发布到一个公钥数据库中。2.工作原理A要给B发送信息时，A用B 的公钥加密信息，因为A 知道B 的公钥。A 将这个消息发给B。B 收到这个消息后，B 用自己的私钥解密A 的消息。其他所有收到这个报文的人都无法解密，因为只有B 才有B 的私钥。3.RSA 算法159RSA 是Rivest、Shamire 和Adleman 于 1978 年在美国麻省理工学院研制出来的，它是一种比较典型的公开密钥加密算法。【习题演练】1.在数据加密技术中，将待加密的报文称为( )。A.密文B.正文C.短文D.明文1.【答案】D。解析：待加密的报文称为明文。2.在公钥密码体制中，公开的是（ ）。A.公钥和私钥B.公钥和算法C.明文和密文D.加密密钥和解密密钥1602.【答案】B。解析：公钥加密算法是计算机网络中经常使用的算法，能跟好的保证网络安全。其中有两个秘钥，公钥和算法是公开的，可以在服务器上查找到，这样方便用于加密。私钥是用户自己保存的一种密钥。3. 以下关于对称与非对称加密算法叙述中正确的
2025-08-10 14:53:51.429 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 是（ ）。A.对称加密比非对称加密的安全性好B.对称加密比非对称加密的解密速度慢C.非对称加密算法中公钥是公开的，算法是保密的D.非对称加密与对称加密相比，用户需要保管的密钥数量少3.【答案】D。解析：非对称加密使用了一对密钥，即公钥与私钥，公钥是公开的，私钥个人持有，不公开，故D 选择正确。161知识点 32、计算机病毒（ 一）计算机病毒的概念广义上，能够引起计算机故障、破坏计算机数据的程序都可称为计算机病毒；狭义上，计算机病毒是指编制者在计算机程序中插入的破坏计算机或者毁坏数据，影响计算机的使用，并能自我复制的一组计算机指令或者程序代码。（ 二）计算机病毒的特性目前，计算机病毒有数十万种，各有其不同的特征，但总的说来，计算机病毒又有明显的共性。计算机病毒主要有以下几种特征：1.传染性传染性是计算机病毒的基本特征。计算机病毒能通过自我复制来感染正常的文件，达到破坏计算162机系统正常运行的目的。但传染性是有条件的，只有病毒程序被执行之后才具有传染性，才能感染其他文件。2.破坏性任何计算机病毒只要侵入计算机系统，都会对系统及应用程序产生不同程度的影响和破坏，轻则降低计算机的工作效率，占用系统资源，重则破坏数据
2025-08-10 14:53:51.430 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，删除文件，甚至导致系统崩溃，给用户造成不可挽回的损失。3.寄生性虽然计算机病毒是一种程序，但这种程序通常不是以独立文件的形式存在的，它寄生在合法的程序之中。这些合法的程序可以是系统引导程序、可执行程序、一般应用程序等。现在的某些病毒本身就是一个完整的程序，如广义病毒中的网络蠕虫。4.欺骗性黑客常常会把带有病毒程序的名字起成一些用户比较关心的程序名字。1635.隐蔽性和潜伏性计算机病毒要有效的传染和传播，就应该尽量在用户能够觉察的范围之外进行。6.衍生性既然计算机病毒是一段特殊的程序，了解病毒程序的人就可以根据其个人意图随意改动，从而衍生出另一种不同于原版病毒的新病毒。7.可触发性编制计算机病毒的人，一般都为病毒程序设定了一些触发条件，例如系统时钟的某个时间或日期、系统运行了某些程序等。一旦条件满足，计算机病毒就会“发作”，使系统遭到破坏。（ 三）计算机病毒的传播方式计算机病毒的传播方式主要有：（1）移动存储设备传播；（2）计算机网络传播；（3）电子邮件传播。164【习题演练】1.计算机病毒是可以造成计算机故障的（ ）。A.一种微生物B.一种特殊的程序C.一块特殊芯片D.一个程序逻辑错误1.【答案】B。解析：
2025-08-10 14:53:51.430 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 计算机病毒指人为编制的一段具有破坏性的，能够自我复制的程序或者代码。2.计算机病毒具有破坏性、（ ）、潜伏性和传染性等特点。A.必然性B.再生性C.隐蔽性D.易读性2.【答案】C。解析：计算机病毒具有寄生性、传染性、潜伏性、隐蔽性。1653.根据统计，当前计算机病毒扩散最快的途径是（ ）。A.软件复制B.网络传播C.磁盘拷贝D.运行游戏软件3.【答案】B。解析：计算机病毒扩散最快的是网络传播，需要提前安装使用杀毒软件来做好防范。166目录知识点 1 、进制转换知识点 2 、常见数据编码知识点 3 、机器数知识点 4 、补码溢出知识点 5 、寻址方式知识点 6 、存储芯片容量的计算知识点 7 、DRAM 的刷新知识点 8、存储器与 CPU 的扩展连接知识点 9 、死锁知识点 10 、处理机调度的层次知识点 11 、调度算法知识点 12 、内存的连续分配知识点 13 、基本的分页存储管理知识点 14 、基本的分段存储管理知识点 15 、虚拟存储器知识点 16 、页面置换算法知识点 17 、线性表知识点 18 、栈和队列知识点 19 、树知识点 20 、二叉树知识点 21 、图知识点 22 、数据模型知识点 23 
2025-08-10 14:53:51.430 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、概念模型知识点 24 、关系模型知识点 25 、关系操作和完整性约束知识点 26 、SQL 常用语句知识点 27 、计算机网络分类知识点 28 、网络地址知识点 29 、子网掩码知识点 30 、网络设备知识点 31 、信息加密技术知识点 32 、计算机病毒
2025-08-10 14:53:51.660 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:51.660 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:51.660 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.yizhaoqi.smartpai.service.VectorizationService - 开始向量化文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:51.665 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 348
2025-08-10 14:53:51.665 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:51.666 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:51.826 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] [2f214867-13] Response 400 BAD_REQUEST
2025-08-10 14:53:51.826 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] [2f214867-13] Read 312 bytes
2025-08-10 14:53:52.843 [parallel-10] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:52.844 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:53.080 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] [2f214867-14] Response 400 BAD_REQUEST
2025-08-10 14:53:53.080 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] [2f214867-14] Read 312 bytes
2025-08-10 14:53:54.088 [parallel-11] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:54.089 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:54.312 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] [2f214867-15] Response 400 BAD_REQUEST
2025-08-10 14:53:54.313 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] [2f214867-15] Read 312 bytes
2025-08-10 14:53:55.328 [parallel-12] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:55.330 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:55.551 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] [2f214867-16] Response 400 BAD_REQUEST
2025-08-10 14:53:55.551 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7235a7e5] [2f214867-16] Read 312 bytes
2025-08-10 14:53:55.551 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7235a7e5] Cancel signal (to close connection)
2025-08-10 14:53:55.551 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR com.yizhaoqi.smartpai.client.EmbeddingClient - 调用向量化 API 失败: Retries exhausted: 3/3
reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:840)
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:55.552 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.yizhaoqi.smartpai.service.VectorizationService - 向量化失败，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:55.553 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.y.smartpai.consumer.FileProcessingConsumer - Error processing task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:58.605 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR o.s.kafka.listener.KafkaMessageListenerContainer - Error handler threw an exception
org.springframework.kafka.KafkaException: Seek to current after exception
	at org.springframework.kafka.listener.SeekUtils.seekOrRecover(SeekUtils.java:227)
	at org.springframework.kafka.listener.DefaultErrorHandler.handleRemaining(DefaultErrorHandler.java:168)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeErrorHandler(KafkaMessageListenerContainer.java:2836)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2713)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: org.springframework.kafka.listener.ListenerExecutionFailedException: Listener method 'public void com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(com.yizhaoqi.smartpai.model.FileProcessingTask)' threw exception
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.decorateException(KafkaMessageListenerContainer.java:2869)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2814)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	... 10 common frames omitted
	Suppressed: org.springframework.kafka.listener.ListenerExecutionFailedException: Restored Stack Trace
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:435)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
Caused by: java.lang.RuntimeException: Error processing task
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:67)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	... 12 common frames omitted
Caused by: java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	... 25 common frames omitted
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:53:58.608 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Received task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
2025-08-10 14:53:58.608 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件权限信息: userId=1, orgTag=PRIVATE_sy, isPublic=false
2025-08-10 14:53:58.608 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Downloading file from storage: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:58.608 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Detected remote URL: http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec
2025-08-10 14:53:58.612 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - Successfully connected to URL, starting download...
2025-08-10 14:53:58.612 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 开始解析文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:58.738 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] WARN  org.apache.pdfbox.pdmodel.font.PDCIDFontType2 - Found CFF/OTF but expected embedded TTF font THDZFH+AppleSDGothicNeo-Regular
2025-08-10 14:53:58.802 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文件元数据:
2025-08-10 14:53:58.802 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:unmappedUnicodeCharsPerPage: 0
2025-08-10 14:53:58.802 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:PDFVersion: 1.7
2025-08-10 14:53:58.802 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmp:CreatorTool: WPS 文字
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXFA: false
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:modify_annotations: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print_degraded: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By-Full-Set: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:creator: Sky123.Org
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:num3DAnnotations: 0
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dcterms:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:format: application/pdf; version=1.7
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator_tool: WPS 文字
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:overallPercentageUnmappedUnicodeChars: 0.0
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:fill_in_form: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:modified: 2024-04-09T08:00:32Z
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasCollection: false
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:encrypted: false
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - dc:title: 一 根据所给图表，回答下列问题。
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsNonEmbeddedFont: false
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:custom:SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasMarkedContent: false
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - Content-Type: application/pdf
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:creator: Sky123.Org
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:totalUnmappedUnicodeChars: 0
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_for_accessibility: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:assemble_document: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - xmpTPg:NPages: 166
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:hasXMP: false
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:charsPerPage: 15
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:extract_content: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_print: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:trapped: False
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - SourceModified: D:20240409165032+08'50'
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - X-TIKA:Parsed-By: org.apache.tika.parser.DefaultParser
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationTypes: null
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - access_permission:can_modify: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:producer: macOS 版本12.4（版号21F79） Quartz PDFContext
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:docinfo:created: 2024-04-09T08:00:32Z
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:annotationSubtypes: Link
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - pdf:containsDamagedFont: true
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 提取的文本内容长度: 44161
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换............................................................ 6知识点 2、常见数据编码....................................................8知识点 3、机器数.............................................................. 14知识点 4、补码溢出..........................................................19知识点 5、寻址方式..........................................................22知识点 6、存储芯片容量的计算..................................... 39知识点 7、DRAM 的刷新................................................ 40知识点 8、存储
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与 CPU 的扩展连接...........................43知识点 9、死锁.................................................................. 48知识点 10、处理机调度的层次....................................... 553知识点 11、调度算法........................................................57知识点 12、内存的连续分配........................................... 63知识点 13、基本的分页存储管理................................... 70知识点 14、基本的分段存储管理................................... 76知识点 15、虚拟存储器....................................................83知识点 16、页面置换算法....................
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ........................... 90知识点 17、线性表............................................................ 95知识点 18、栈和队列........................................................98知识点 19、树.................................................................. 102知识点 20、二叉树.......................................................... 105知识点 21、图.................................................................. 1104知识点 22、数据模型......................................................117知识点 23、概念模型................................
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ......................119知识点 24、关系模型......................................................125知识点 25、关系操作和完整性约束.............................127知识点 26、SQL 常用语句............................................ 132知识点 27、计算机网络分类......................................... 139知识点 28、网络地址......................................................144知识点 29、子网掩码......................................................148知识点 30、网络设备......................................................153知识点 31、信息加密技术...............................
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: .............. 158知识点 32、计算机病毒..................................................1645知识点 1、进制转换常用数制数制 数码 运算规则 尾符十进制 0—9 逢十进一 D或10二进制 0—1 逢二进一 B或2八进制 0—7 逢八进一 O或8十六进制 0—9，A—F 逢十六进一 H或16（ 一 ）非十进制数转换成十进制数方法每位上的数码×基的位次方，然后求和。（ 二 ）十进制数转换成非十进制数方法整数部分：除N 取余数，直至商为0，余数倒输出。小数部分：乘N 取整数，直至积为0（或满足精度），整数正输出。6（N 为进制数，N 可取2、8、16。）（ 三 ）二/八/十六进制数的互相转换方法由于一位八/十六进制数相当于三/四位二进制数，因此，要将八/十六进制数转换成二进制数时，只需以小数点为界，向左或向右每一位八/十六进制数用相应的三/四位二进制数取代即可。如果不足三/四位，可用零补足。反之，二进制数转换成相应的八/十六进制数，只是上述方法的逆过程，即以小数点为界，向左或向右，每三/四位二进制数用相应的一位八/十六进制数取代即可。【习题
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 演练】1.二进制数 1101.01 转换成十进制数是（ ）。A.17.256B.13.5C.13.25D.17.571.【答案】C。解析：（1101.01）2= 1 x23+1 x22+1+1 x 2—2 = 13.25。2.下列数中最大的数是（ ）。A.227OB.1FFHC. 10100001BD.1789D2.【答案】D。解析：将所有数都统一转换为十进制进行比较，227O=151D ， 1FFH=511D ，10100001B= 161D，对比可知应选D 选项。知识点 2、常见数据编码（ 一）ASCII码美国信息交换标准代码（American StrandardCode for Information Interchage，ASCII）是一种西8文机内码，是计算机中使用最广泛的字符编码，已经作为国际通用的信息交换标准代码。ASCII 码包括 0～9 十个数字，大小写英文字母和专用符号等95 种可打印字符，以及33 种控制字符（如回车、换行等），通常采用一个字节编码，由7 位二进制编码组成，字节的最高位一般规定为0，或用作校验码，可表示 128 个不同的字符。（ 二）汉字的编码1.国标码《信息交换用汉字编
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 码字符集·基本集》是我国于 1980 年制定的国家标准GB2312—80，简称国标码，是国家规定的用于汉字信息交换使用的代码的依据。GB2312—80 中规定了信息交换用的6763个汉字和682 个非汉字图形符号（包括外文字母、数字和符号）的代码。国标码用两个字节表示一个汉字，每个字节只使用低7 位，最高位为0。2.汉字机内码9汉字的机内码是供计算机系统内部进行存储、加工处理、传输统一使用的代码，又称为汉字内部码或汉字内码。汉字机内码是将国标码的两个字节的最高位分别置为 1 而得到的。其最大优点是机内码表示简单，同时也解决了中西文机内码存在的二义性的问题。3.汉字输入码汉字输入码是为了将汉字通过键盘输入计算机而设计的代码。汉字输入编码方案很多，其表示形式大多用字母、数字或符号。输入码的长度也不同，多数为四个字节。综合起来可分为流水码、音码、形码和音形码几大类。4.汉字字形码汉字字形码是汉字字库中存储的汉字字形的数字化信息，用于汉字的显示和打印。目前汉字字形的产生方式大多是数字式，即以点阵方式形成汉字。因此，汉字字形码主要是指汉字字形点阵的代码，10主要有 16×16 点阵、32×32 点阵、256×256 点
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 阵等。如 24×24 的点阵，每字需要72 字节；32×32的点阵，每字需要 128 字节。与每个汉字对应的这一串字节就是汉字的字形码。（ 三）二-十进制编码人们习惯于使用十进制数，而计算机内部多采用二进制数表示和处理数值数据，因此在计算机输入和输出数据时，就要进行由十进制到二进制和从二进制到十进制的转换处理，显然，这项事务性工作如果由人工来完成，势必造成大量时间浪费。因此，必须采用一种编码的方法，由计算机自己来完成这种识别和转换工作。人们通常采用把十进制数的每一位分别写成二进制数形式的编码，称为二-十进制编码或BCD 编码。BCD 编码方法很多，通常采用的是8421 编码。其方法是用四位二进制数表示一位十进制数，自左11至右每一位对应的位权分别是8，4，2，1。值得注意的是，四位二进制数有 0000～1111 十六种状态，这里只取了0000～1001 十种状态，而 1010～1111六种状态在这种编码中没有意义。如十进制数864，其BCD进制编码为 100001100100。8 6 4↓ ↓ ↓1000 0110 0100BCD 码有压缩和非压缩两种。上述的编码方法属于压缩BCD 码，特点是用 1 个字节表
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 示2 位BCD码；非压缩 BCD 码用 1 个字节的低 4 位表示 1 位BCD 码，高4 位为0（无意义）。如 13 的压缩BCD码为 0001 0011 ，非压缩 BCD 码为 0000000100000011。【习题演练】1.已知字符0 的ASCII码为48D，用ASCII 码（7 位）表示字符5 和7 是（ ）。12A.0110010 和0110111B.0100011 和0111011C. 1000101和1100011D.0110101 和01101111.【答案】D。解析：ASCII 码表中字符5 和7的码值分别为 53 和 55 ，转换为二进制表示为0110101 和 0110111。2.某数用压缩BCD 码表示为 10010101，其真值为（ ）。A.135B.95C.95HD. 10010101B2.【答案】B。解析：BCD码是二-十进制编码，1001 和0101 分别对应十进制的9 和5，故选择B选项。3.一个 16×16 点阵的汉字要占用（ ）。A.24 个字节13B.32 个字节C.48 个字节D.256 个字节3.【答案】B。解析：16×16 点阵的汉字要用16×16/8=32 个
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 字节。知识点 3、机器数对于数的符号“＋”和“－”，计算机是无法识别的，需要把符号数码化。通常，约定二进制数的最高位为符号位，“0”表示正号，“1”表示负号。这种在计算机中使用的表示数的形式称为机器数，常见的机器数有原码、反码、补码等。（ 一）原码原码表示法是机器数的一种简单的表示法。其符号位用0 表示正号，用 1 表示负号，数值一般用14二进制形式表示。设有一数用X 表示真值，则原码表示可记作[X]原，例如：X1=＋1010110X2=－1001010其原码记作：[X1]原=[＋1010110]原=01010110[X2]原=[－1001010]原= 11001010在原码表示法中，对 0 有两种表示形式：[＋0]原=00000000[－0]原=10000000（ 二）反码机器数的反码可由原码得到。如果机器数是正数，则该机器数的反码与原码一样；如果机器数是负数，则该机器数的反码是对它的原码（符号位除外）各位取反而得到的。假设有一数用X表示真值，那么X 的反码表示记作[X]反，例如：X1=＋101011015X2=－1001010那么[X1]原=01010110[X1]反=[X1]原=01010110[X2]
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 原=11001010[X2]反=10110101在反码表示法中，对 0 也有两种表示形式：[＋0]反=00000000[－0]反=11111111反码通常作为求补过程的中间形式，即在一个负数的反码的末位上加 1，就得到该负数的补码。（ 三）补码机器数的补码可由原码得到。如果机器数是正数，则该机器数的补码与原码一样；如果机器数是负数，则该机器数的补码是对它的原码（除符号位外）各位取反，并在末位加 1 而得到的。设有一数用X 表示真值，则X 的补码表示记作[X]补，例如：16X1=＋1010110X2= – 1001010那么[X1]原=01010110[X1]补= [X1]原=01010110[X2]原=11001010[X2]补= 10110101+1=10110110在补码表示法中，0 只有一种表示形式：[＋0]补=00000000[－0]补= 11111111＋1=00000000所以有[＋0]补=[－0]补=00000000。【习题演练】1.采用补码表示的 8 位二进制数真值范围是( )。A.- 127～+127B.- 127～+128C.- 128～+12717D.- 128～+1281.【答案】C。
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 解析：补码表示的8 位二进制数真值范围是- 128～+127 ，原码和反码的范围是- 127～+127。2.补码25H 的真值是（ ）。A.25B.-25C.-37D.372.【答案】D。解析：正数的原码、反码与补码都相同。3.在机器中，（ ）的零的表示形式是唯一的。A.原码B.补码C.反码D.原码和反码3.【答案】B。解析：补码零的表示形式唯一，而原码和反码不唯一。18知识点 4、补码溢出（一 ）补码溢出的产生在补码加减运算中，有时会遇到这样的情况：两个正数相加，而结果的符号位却为 1（结果为负）；两个负数相加，而结果的符号位却为0（结果为正）。发生这种错误的原因在于两数相加之和的数值已超过了机器允许的表示范围。字长为n+1 位的定点整数（其中一位为符号位），采用补码表示，当运算结果大于2n- 1 或小于-2n 时，就产生溢出。设参加运算的两数为X、Y，做加法运算：①若X、Y 异号，不会溢出；②若X、Y 同号，运算结果为正且大于所能表示的最大正数或运算结果为负且小于所能表示的最小负数时，产生溢出。将两正数相加产生的溢出称为正溢；反之，两负数相加产生的溢出称为负溢。19（ 二）补码溢出的检测设被操作数为[X]
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 补=XsX1X2…Xn，操作数为[Y]补=YsY1Y2…Yn，其和（差）为[S]补=SsS1S2…Sn，则判断溢出的方法有以下三种：1.采用一个符号位两正数相加，结果为负表明产生正溢；两负数相加，结果为正表明产生负溢。因此可得出采用一个符号位检测溢出的方法：当Xs=Ys=0，Ss=1 时，产生正溢；当Xs=Ys=1，Ss=0 时，产生负溢。2.采用进位位两数运算时，产生的进位为：CsC1C2…Cn，其中：Cs 为符号位产生的进位，C1 为最高数值位产生的进位。两正数相加，当最高有效位产生进位（C1= 1）而符号位不产生进位（Cs=0）时，发生正溢。20两负数相加，当最高有效位没有进位（C1=0）而符号位产生进位（Cs= 1）时，发生负溢。3.采用变形补码（双符号位补码）在双符号位的情况下，把左边的符号位 Ss1 叫做真符，因为它代表了该数真正的符号，两个符号位都作为数的一部分参加运算。这种编码又称为变形补码。双符号位的含义如下：Ss1Ss2=00，结果为正数，无溢出；Ss1Ss2=01，结果正溢；Ss1Ss2=10，结果负溢；Ss1Ss2= 11，结果为负数，无溢出。【习题演练】1.算式65H-3EH 的运算
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结果是否有溢出，结果的真值为（ ）。A.有、39B.有、27C.无、39D.无、27211.【答案】C。解析：65H-3EH=101D-62D=39D，无溢出。知识点 5、寻址方式存储器既可用来存放操作数，又可用来存放指令。当某个操作数或某条指令存放在某个存储单元时，其存储单元的编号，就是该操作数或指令在存储器中的地址。因此，寻址方式可以分为数据寻址和指令寻址。寻找操作数的地址称为数据寻址，数据寻址方式较多，其最终目的都是寻找所需要的操作数。寻找下一条将要执行的指令地址称为指令寻址。（ 一）指令寻址指令寻址比较简单，它又可以细分为顺序寻址和跳跃寻址。顺序寻址可通过程序计数器PC 加 1，22自动形成下一条指令的地址；跳跃寻址是程序转移执行时的指令寻址方式，它通过转移类指令实现。跳跃寻址的转移地址形成方式有三种：直接（绝对）、相对和间接寻址，它与数据寻址方式中的直接、相对和间接寻址是相同的，只不过寻找到的不是操作数的有效地址而是转移的有效地址而已。（ 二）数据寻址数据寻址方式种类较多，在指令字中必须设一字段来指明属于哪一种寻址方式。指令的地址码字段通常都不代表操作数的真实地址，把它称为形式地址，记作A。操作数的
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 真实地址称为有效地址，记作 EA，它是由寻址方式和形式地址共同来确定的。由此可得指令的格式应如下所示。操作码OP 寻址特征# 形式地址A寻址方式是根据指令中给出的地址码字段寻找真实操作数地址的方式。23指令中的形式地址A—（寻址方式）→有效地址EA1.立即寻址在取指令时，操作码和操作数被同时取出，不必再次访问存储器，从而提高了指令的执行速度，如下图所示。立即寻址的特点是操作数本身设在指令字内，即形式地址A 不是操作数的地址，而是操作数本身，也称立即数。由于操作数是指令的一部分，故立即数的大小将受到指令长度的限制。立即寻址示意图2.直接寻址指令中地址码字段给出的地址A 就是操作数的有效地址：EA=A，如下图所示。直接寻址的缺点在于A 的位数限制了操作数的寻址范围，且必须修改A 的值，才能修改操作数的地址。24直接寻址示意图3.间接寻址指令中给出的地址A 不是操作数的地址，而是存放操作数地址的地址：EA=（A），如下图所示。间接寻址要比直接寻址灵活得多，它的主要优点为：一是扩大了寻址范围，可用指令的短地址访问大的主存空间，二是可将主存单元作为程序的地址指针，用以指示操作数在主存中的位置。当操作数的地址需要改变时，
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 不必修改指令，只需修改存放有效地址的那个主存单元（间接地址单元）的内容就可以了。25一级间接寻址二级间接寻址26除去一级间接寻址外，还有多级间接寻址。多级间接寻址为取得操作数需要多次访问主存，即使在找到操作数有效地址后，还需再访问一次主存才可得到真正的操作数。4.寄存器寻址指令中地址码部分给出某一通用寄存器的编号，所指定的寄存器中存放着操作数，如下图所示。它有两个明显的优点：一是从寄存器存取数据比主存快得多；二是由于寄存器的数量较少，其地址码字段比主存单元地址字段短得多。寄存器寻址示意图5.寄存器间接寻址27寄存器间接寻址示意图指令中的地址码给出某一通用寄存器的编号，被指定的寄存器中存放操作数的有效地址，而操作数则存放在主存单元中，如上图所示。这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数。6.变址寻址把指令给出的形式地址A 与变址寄存器Rx 的内容相加，形成操作数有效地址：EA ＝ A +（Rx），Rx 的内容为变址值，如下图所示。28变址寻址是一种广泛采用的寻址方式，通常指令中的形式地址作为基准地址，而 Rx 的内容作为修改量。在遇到需要频繁修改地址时，无须修改指令，只要修改变址值就可以了
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。变址寻址示意图如要把一组连续存放在主存单元中的数据（首地址是A）依次传送到另一存储区（首地址为B）中去，则只需在指令中指明两个存储区的首地址A和B（形式地址），用同一变址寄存器提供修改量29K，即可实现（A＋K）→B＋K。变址寄存器的内容在每次传送之后自动地修改。7.基址寻址将基址寄存器Rb 的内容与形式地址A 相加，形成操作数有效地址：EA＝（Rb）＋ A，基址寄存器的内容称为基址值，如下图所示。基址寻址示意图工30基址寻址和变址寻址在形成有效地址时所用的算法是相同的，而且在一些计算机中，这两种寻址方式都是由同样的硬件来实现的。但这两种寻址方式应用的场合不同，变址寻址是面向用户的，用于访问字符串、向量和数组等成批数据；而基址寻址面向系统，主要用于逻辑地址和物理地址的变换，用以解决程序在主存中的再定位和扩大寻址空间等问题。在某些大型机中，基址寄存器只能由特权指令来管理，用户指令无权操作和修改。8.相对寻址相对寻址是基址寻址的一种变通，由程序计数器PC 提供基准地址，即：EA＝（PC）＋ A，A 是操作数和现行指令之间的相对位置，如下图所示。3132相对寻址示意图相对寻址方式的特点是：操作数的地址不是固定的，
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 它随着PC 值的变化而变化，并且与指令地址之间总是相差一个固定值A。当指令地址改变时，由于其位移量不变，使得操作数与指令在可用的存储区内一起移动，所以仍能保证程序的正确执行。采用PC 相对寻址方式编写的程序可在主存中任意浮动，它放在主存的任何地方，所执行的效果都是一样的。指令中给出的位移量A 可正、可负，通常用补码表示，故对于指令地址而言，操作数地址可能在指令地址之前或之后。9.隐含寻址隐含寻址是指指令字中不明显地给出操作数的地址，其操作数的地址隐含在操作码或某个寄存器中。如一地址指令格式，只给出一个操作数的地址，另一个操作数隐含在累加器ACC 中，故累加器ACC对一地址指令格式来说是隐含地址，如下图所示。33隐含寻址示意图10.堆栈寻址在堆栈寻址的指令字中没有形式地址码字段，它是一种零地址指令。堆栈寻址要求计算机中设有堆栈。堆栈既可用寄存器组来实现，也可利用主存的一部分空间作堆栈，前者称为硬堆栈，后者称为软堆栈。【习题演练】1. 对某个寄存器中操作数的寻址方式称为( ) 寻址。A.直接B.间接C.寄存器34D.寄存器间接1.【答案】C。解析：操作数在寄存器中的寻址方式为：“寄存器直接寻址”，也叫“寄存器寻址
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ”。当操作数的有效地址在寄存器中时叫“寄存器间接寻址”。2.操作数所处的位置，可以决定指令的寻址方式。操作数的地址在寄存器中，寻址方式为（ ）。A.相对寻址B.直接寻址C.寄存器寻址D.寄存器间接寻址2.【答案】D。解析：操作数包含在指令中的寻址方式为立即寻址；操作数在寄存器中的寻址方式为寄存器寻址；操作数的地址在寄存器中的寻址方式为寄存器间接寻址。3.变址寻址和基址寻址的有效地址形成方式类似，但（ ）。35A.变址寄存器的内容在程序执行过程巾是不能改变的B.基址寄存器的内容在程序执行过程中是可以改变的C.在程序执行过程中，变址寄存器的内容不能改变而基址寄存器的内容可变D.在程序执行过程中，基址寄存器的内容不能改变而变址寄存器的内容可变3.【答案】D。解析：基址寄存器的内容由操作系统确定，而变址寄存器的内容由用户确定，因此基址寄存器的内容不能改变而变址寄存器的内容可变。知识点 6、存储芯片容量的计算存储芯片的容量与地址线的位数、数据线的位数均有关。地址线和数据线的位数共同反映存储芯片的容量。其公式可写为：36存储芯片容量=2A×D位，其中，A 为地址线根数，D 为数据线根数。如地址线为 10 根，数据线为4根
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，则存储芯片容量为 210×4＝4K 位；又如地址线为 14 根，数据线为 1根，则其容量为214×1＝16K 位。【习题演练】1.某DRAM 芯片，其存储容量为512K×8 位，该芯片的地址线和数据线数目为（ ）。A.8，512B.512，8C.18，8D.19，81.【答案】D。解析：512K X8 = 219 X 8，所以地址线和数据线分别为 19 和8。37知识点 7、DRAM 的刷新动态随机存储器刷新的过程实质上是先将原存信息读出，再由刷新放大器形成原信息并重新写入的再生过程。DRAM 是靠电容来存储信息的，由于存储单元被访问是随机的，有可能某些存储单元长期得不到访问，不进行存储器的读/写操作，其存储单元内的原信息将会慢慢消失。为此，必须采用定时刷新的方法，它规定在一定的时间内，对DRAM 的全部基本单元电路必作一次刷新，一般取2ms（2000μs），这个时间称为刷新周期。刷新是一行行进行的，必须在刷新周期内，由专用的刷新电路来完成对基本电路的逐行刷新，才能保证DRAM 内的信息不会丢失。通常有三种方式刷新：集中刷新、分散刷新和异步刷新。38（ 一）集中刷新集中刷新是在规定的一个刷新周期内，对全部存
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 储单元集中一段时间逐行进行刷新，此刻必须停止读/写操作。如对 128×128 矩阵的存储芯片进行刷新，刷新的时间相当于 128 个读周期。若读/写周期为 0.5μs，则对 128 行集中刷新共需 128×0.5 =64μs，其余的 1936μs（=2000－64）用来读/写或维持信息。由于在这 64μs 时间内不能进行读写操作，故称为“死时间”。（ 二）分散刷新分散刷新把对每行存储单元的刷新分散到每个存取周期内完成。其中，把机器的存取周期分成两段，前半段用来读/写或维持信息，后半段用来刷新。若读/写周期为 0.5μs，则存取周期为 1μs，那么每隔128μs 就可将 128 行的存储芯片全部刷新一遍，但39这比允许的 2ms 间隔要短得多，且存取周期长了，整个系统的速度降低。（ 三）异步刷新前两种方式的集合，既可缩短“死时间”，又充分利用最大刷新间隔为 2ms 的特点。如可在 2ms内对 128 行各刷新一遍，即每隔 15.6μs（2000/ 128）刷新一行，每行的刷新时间仍为 0.5μs，但对每行来说，刷新间隔仍为2ms，“死时间”缩短为0.5μs。【习题演练】1.动态RAM 的刷新是以（ ）为单位进行的
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 。A.存储矩阵B.行C.列D.存储单元1.【答案】B。解析：动态RAM 的刷新以行为单位进行。40知识点 8、存储器与 CPU 的扩展连接（一 ）存储容量的扩展由于单片存储芯片的容量总是有限的，很难满足实际的需要，因此，必须将若干存储芯片连在一起才能组成足够容量的存储器，称为存储容量的扩展，通常有位扩展和字扩展。1.位扩展位扩展是指增加存储字长，只在位数方向扩展（加大字长）。位扩展的连接方式是将各存储芯片的地址线、片选线和读/写线相应地并联起来，而将各芯片的数据线单独列出。位扩展组成容量 地址 数据41存储器 64K×8 16 位 8 位存储芯片 64K×1 16 位 1 位如用 64K×1 的SRAM 芯片组成64K×8 的存储器，需要8 个芯片，如上表所示。当CPU 访问该存储器时，其发出的地址和控制信号同时传给8个芯片，选中每个芯片的同一单元，其单元的内容被同时读至数据总线的相应位，或将数据总线上的内容分别同时写入相应单元。2.字扩展字扩展是指增加存储器字的数量，它仅在字数方向扩展，而位数不变。字扩展将芯片的地址线、数据线、读/写线并联，由片选信号来区分各个芯片。如用 16K×8 的SRAM 组成64K
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ×8 的存储器，需要4 个芯片，如下表所示。字扩展组成容量 地址 数据42存储器 64K×8 16 位 8 位存储芯片 16K×8 14 位 8 位在同一时间内四个芯片中只能有一个芯片被选中。3.字和位同时扩展字和位同时扩展组成容量 地址 数据存储器 64K×8 16 位 8 位存储芯片 16K×4 14 位 4 位字和位同时扩展是指既增加存储字的数量，又增加存储字长。当构成一个容量较大的存储器时，往往需要在字数方向和位数方向上同时扩展，这将是前两种扩展的组合，实现起来也较为容易。如用16K×4 的SRAM 组成64K×8 的存储器，需要8 个芯片，如上表所示。43（ 二）存储器与 CPU 的连接存储芯片与CPU 芯片相连时，特别要注意片与片之间的地址线、数据线和控制线的连接。1.地址线的连接存储芯片的容量不同，其地址线数也不同，CPU的地址线数往往比存储芯片的地址线数多。通常总是将CPU 地址线的低位与存储芯片的地址线相连。CPU 地址线的高位或在存储芯片扩充时用，或做其他用途，如片选信号等。2.数据线的连接CPU 的数据线数与存储芯片的数据线数也不一定相等。此时，必须对存储芯片扩位，使其数据位数与CPU 
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的数据线数相等。3.读/写命令线的连接CPU 读/写命令线一般可直接与存储芯片的读/写控制端相连，通常高电平为读，低电平为写。4.片选线的连接44片选线的连接是CPU 与存储芯片正确工作的关键。存储器由许多存储芯片组成，哪一片被选中完全取决于该存储芯片的片选控制端---cs是否能接收到来自CPU 的片选有效信号。5.合理选择存储芯片合理选择存储芯片主要是指存储芯片类型（RAM 或ROM）和数量的选择。通常选用ROM存放系统程序、标准子程序和各类常数等。RAM 则是为用户编程而设置的。此外，在考虑芯片数量时，要尽量使连线简单方便。【习题演练】1.用存储容量为16K×1 位的存储器芯片来组成一个 64K×8 位的存储器，则在字方向和位方向上分别扩展了（ ）倍。A.4 和2B.8 和4C.2 和445D.4 和81.【答案】D。解析：用64K 除以16K等于4，用8 除以1 等于8。2.RAM 芯片并联时可以使（ ）。A.存储器存储字长增加B.存储器地址范围增加C.存储器速度增加D.降低存储器的平均价格2.【答案】A。解析：并联时可以增加存储器的存储字长。知识点 9、死锁死锁是指多个进程在运行过程中因争夺资源而造成
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。如下图所示，有两个资源R1 和R2 供进程P1和P2 共享，P1 已占用资源R1，P2 已占用资源R2，46此时若 P2 继续要求R1,P1 要求R2，则 P1 和 P2 之间便会形成僵局，它们都在等待对方释放自己所需的资源，但同时又不释放自己已占用的资源，从而进入死锁状态。P1R2P2死锁示例（一 ）死锁产生的原因产生死锁的原因可归结为如下两点：1.竞争资源47R1当系统中供多个进程共享的资源如打印机、公用队列等，其数目不足以满足诸进程的需要时，会引起诸进程对资源的竞争而产生死锁。2.进程间推进顺序非法进程在运行过程中，请求和释放资源的顺序不当，也同样会导致产生进程死锁。（ 二）死锁产生的必要条件死锁的发生必须具备下列四个必要条件：1.互斥条件指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。2.请求和保持条件指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此48时请求进程阻塞，但又对自己已获得
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的其它资源保持不放。3.不剥夺条件指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。4.环路等待条件指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，…，Pn}中的P0 正在等待一个P1 占用的资源；P1 正在等待P2 占用的资源，……，Pn正在等待已被P0 占用的资源。（ 三）死锁的处理为保证系统中各进程的正常运行，应事先采取必要的措施，来预防发生死锁。系统已经出现死锁后，则应及时检测到死锁的发生，并采取适当措施来解除死锁。目前，处理死锁的方法可归结为以下四种：1.预防死锁49这是一种较简单和直观的事先预防的方法。该方法是通过设置某些限制条件，破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。2.避免死锁该方法同样是属于事先预防的策略，但它并不须事先采取各种限制措施去破坏产生死锁的四个必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。3.检测死锁这种方法并不须事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机制，及时地检测出死锁的发
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 生，并精确地确定与死锁有关的进程和资源；然后，采取适当措施，从系统中将已发生的死锁清除掉。4.解除死锁这是与检测死锁相配套的一种措施。当检测到系统中已发生死锁时，须将进程从死锁状态中解脱50出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。【习题演练】1.以下各种情况中，属于死锁现象的是（ ）。A.某进程执行了死循环B.某进程为了得到某资源，等待了很长的时间C.某进程为了得到某资源，等待了无限的时间D.操作系统故障1.【答案】C。解析：死锁是指多个进程在运行过程中因争夺资源而造成的一种僵局，若无外力作用，它们都将无法再向前推进。由死锁概念可知，只有C 选项符合。2.死锁预防是保证系统不进入死锁状态的静态策略，其解决方法是破坏产生死锁的四个必要条件之一。下列方法中破坏了“循环等待”条件的是( )。51A.银行家算法B.一次性分配策略C.剥夺资源法D.资源有序分配法2.【答案】D。解析：资源有序分配法可以破坏“循环等待”条件。3.产生系统死锁的原因可能是由于（ ）。A.进程释放资源B.一个进程进入死循环C.多个进程竞争资源，出现了循环
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 等待D.多个进程竞争共享型设备3.【答案】C。解析：产生系统死锁的原因可能是多个进程竞争资源，从而出现了循环等待。52知识点 10、处理机调度的层次（ 一）作业调度作业调度又称高级调度，或宏观调度，根据某种算法，把外存上处于后备队列中的作业调入内存。（ 二）中级调度中级调度又称中程调度，将那些暂时不能运行的进程调至外存上去等待，此时的进程状态称为挂起状态。中级调度实际上就是存储器管理中的对换功能。（ 三）进程调度进程调度又称低级调度，或微观调度，它决定就绪队列中的哪个进程应获得处理机。53进程调度的方式有两种：非抢占方式和抢占方式。抢占方式基于的原则有三个：优先权原则、短作业/进程优先原则、时间片原则。【习题演练】1.操作系统中的高级调度是指（ ）。A.线程调度B.作业调度C.进程内、外存交换调D.进程调度1.【答案】B。解析：高级调度又称为作业调度、宏观调度或者长程调度，其主要任务是按照一定的原则从外存上处于后备状态的作业中选择一个或者多个，给它们分配内存、输入输出设备等必要的资源，并建立相应的进程，以使作业具有获得竞争处理器的权利。2.CPU 的调度分为高级、中级和低级三种，其中低级调度是指（ ）调度。5
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4A.作业B.交换C.进程D.线程2.【答案】C。解析：进程调度又称低级调度。知识点 11、调度算法（ 一 ）先来先服务调度算法先来先服务（First Come First Served，FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS 算法比较有利于长作业（进程），而不利于短作业（进程）。（ 二）短作业/进程优先调度算法短作业 / 进程优 先调度算法（ShortestJob/Process First，SJ/PF），是指对短作业或短进程55优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先（SJF）的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。而短进程优先（SPF）调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。需要注意的是短进程优先调度算法中，每次选择的是已进入系统的、要求服务时间最短的进程。SJ/PF 调度算法的缺点在于：该算法对长作业不利；完全未考虑作业的紧迫程度，因而不能保证紧迫性作业/进程会被及时处理；由于
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 作业/进程的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。56（ 三 ）高优先权优先调度算法作为作业调度算法，此算法常被用于批处理系统中，作为进程调度算法，还可用于实时系统中。对于最高优先权优先调度算法，其关键在于：它是使用静态优先权，还是用动态优先权，以及如何确定进程的优先权。1.静态优先权静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。确定进程优先权的依据：进程类型、进程对资源的需求和用户需求。2.动态优先权动态优先权是指在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。动态优先权的变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间57= 响应时间/要求服务时间= 响应比这种算法即为高响应比优先调度算法（HighestResponse-ratio Next，HRN），它既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折中。但每次要进行调度之前，都须先做响应比的计算，这会增加系统开销。
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: （ 四 ）基于时间片的轮转调度算法1.时间片轮转法其基本思想是为每一个进程分配一个时间段，该时间段被称为时间片，即允许该进程运行的时间。每个进程只能依次循环轮流运行，如果时间片结束时进程还在运行，CPU 将剥夺该进程的使用权转而将CPU 分配给另一个进程。如果进程在时间片结束之前阻塞或结束，CPU 当即进行切换。为了实现进程的循环执行，将每次被中止运行的进程存入就绪58队列的末尾，同时将CPU 分配给就绪队列中的队首进程。该算法是一种简单而又公平的算法，使用非常广泛。2.多级反馈队列调度算法前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。【习题演练】1.为了对紧急进程或重要进程进行调度，调度算法应采用（ ）。A.先进先出调度算法B.优先数法59C.最短作业优先调度D.定时轮转法1.【答案】B。解析：为了对紧急进程或重要进程进行调度，可遵
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 循优先权准则，采用优先数法。2.按照作业到达的先后次序调度作业，排队等待时间最长的作业被优先调度，这是指（ ）调度算法。A.先来先服务B.最短作业优先C.定时轮转法D.优先数法2.【答案】A。解析：先来先服务按作业进入的先后次序安排。优点是实现简单，缺点是不利于运行时间短的作业。3.以下（ ）调度算法对CPU 繁忙型进程有利。A.FCFSB.时间片轮转60C.多级反馈队列D.短进程优先3.【答案】A。解析：CPU 繁忙型进程占用CPU时间比较多，更接近于长进程，故选A，FCFS 算法有利于长进程。知识点 12、内存的连续分配连续分配方式，是指为一个用户程序分配一个连续的内存空间。它又可进一步分为：单一连续分配、固定分区分配、动态分区分配以及动态重定位分区分配四种。（ 一）单一连续分配单一连续分配是最简单的一种存储管理方式，只能用于单用户、单任务的操作系统中。它将内存分为系统区和用户区两部分，系统区仅提供给OS使用，通常是放在内存的低址部分；用户区是指除61系统区以外的全部内存空间，提供给用户使用，其中仅能存放一道作业。（ 二）固定分区分配固定分区分配是最早的多道程序的存储管理方式，是指系统先把内存划分成若干个
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 大小固定的分区，一旦划分好，在系统运行期间便不再重新划分。为了满足不同程序的存储需求，各分区的大小可以不等，也可以相等，但在每个分区中只装入一道作业。采用固定分区分配方法存在以下缺点：（1）由于预先规定了分区的大小，使得大作业无法装入，用户不得不采取其他技术加以补救，增加了用户的负担；（2）内存利用率不高，作业很少能恰好填满分区；（3）固定分区无法实现动态扩充内存空间的要求；62（4）由于分区个数在系统初启时确定，因此会限制多道运行的程序个数，特别不适于分时系统交互型用户及内存变化很大的情形。（ 三）动态分区分配动态分区分配算法根据进程的实际需要，动态地分配内存空间。在实现可变分区分配时，涉及到分区分配中所用的数据结构、分区分配算法和分区的分配与回收操作三个问题。常用的分配算法主要有以下几种：首次适应算法、循环首次适应算法、最佳适应算法、最坏适应算法。1.首次适应算法该算法将空闲分区按起始地址递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，直至找到第一个能满足要求的空闲分区为止，并按作业的大小从该分区中分割出一块内存空间分配给请求者，剩余的部分仍留在空闲分区表63或链中。该算法优先使用内存低
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 址部分的空闲分区，从而能在高址部分保留较大的空闲分区，但它会在内存的低端留下很多难以利用的小空闲分区，而每次分配时，对空闲分区的查找都必须经过这些分区，从而会增加查找的开销。2.循环首次适应算法该算法由首次适应算法演变而成，每次分配均从上次分配的位置之后开始查找，并将第一个能满足要求的空闲分区分割并分配出去。其特点是内存中的空闲分区分布得更均匀，从而减少查找空闲分区的开销，但它会使存储器中缺乏大的空闲分区。3.最佳适应算法该算法将空闲分区按大小递增的次序排列，每次分配均从空闲分区表或空闲分区链首开始顺序查找，并将第一个能满足要求的空闲分区分割并分配出去。该算法尽管被称为“最佳”，但情况并非总是如此，因为每次分配后所切割下来的剩余部分总64是最小的，它会在内存中留下大量难以利用的小空闲分区。4.最坏适应算法该算法将空闲分区按大小递减的次序排列。当作业申请一个空闲区时，先检查空闲分区链（表）的第一个空闲区是否大于或等于所要求的内存长度，若该空闲区长度小于要求，则分配失败，否则分配相应的存储空间给用户，然后修改和调整空闲分区链（表）。该算法的优点是产生碎片的几率最小，缺点主要是使内存中缺乏大的空闲区。（四 ）可重定
2025-08-10 14:53:58.803 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 位分区分配在动态分区分配方式中，经过一段时间的分配和回收后，内存中会产生很多小的空闲分区。此时，可能有用户程序因找不到足够大的空闲分区而难以装入，但所有空闲分区容量的总和却足以满足该程序的要求。65上述这些不能被利用的空闲分区可采用以下办法加以解决：将内存中的所有作业进行移动，从而将原来分散的多个空闲分区移到同一处拼接成一个大的空闲分区，以装入用户的作业。这种技术被称为“拼接”或“紧凑”。可重定位分区分配方式就是在动态分区分配方式的基础上增加紧凑功能，即在找不到足够大的空闲分区、而空闲分区总和却能满足用户的要求时，对内存空间进行紧凑。由于紧凑时，作业要在内存中移动位置，因此，它需要得到动态重定位技术的支持，这也是它被称为动态重定位分区分配的原因。【习题演练】1.分区存储管理中的首次适应算法，要求把空闲区按照（ ）的次序登记在空闲区表中。A.大小递减B.大小递增C.地址递减66D.地址递增1.【答案】D。解析：首次适应算法要求对空闲分区按地址从小到大的顺序排列。2.可重定位内存的分区分配目的为（ ）。A.解决碎片问题B.便于多作业共享内存C.回收空白区方便D.便于用户干预2.【答案】A。解析：可重定位内存的分区
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 增加了紧凑的功能，通常在找不到足够大的空闲分区来满足用户需求时使用，解决了碎片问题。3.在以下存储管理方案中，不适用于多道程序设计系统的是（ ）。A.单一连续分配B.固定式分区分配C.可变式分区分配D.页式存储管理673.【答案】A。解析：单一连续分配只能用于单用户、单任务的操作系统。知识点 13、基本的分页存储管理在分页存储管理方式中，如果不具备页面对换功能，则称为基本的分页存储管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。（ 一）页面与页表基本的分页存储管理方式中，系统将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。相应地，将内存空间分成若干个与页面同样大小的块，称为物理块或页框。内存的分配以块为单位，并允许将一个进程的若干页分别装入到多个不相邻的物理块中。68为了地址映射的方便，页面的大小通常设置成2 的幂。如果页面的大小为2k 字节，逻辑地址的长度为 n 位，则分页系统的地址结构如下图所示，可将线性的逻辑地址分成两部分：右边的 k 位为页内位移量（即页内地址）W，左边的n-k 位为页号P。n-1 k k-1 0页号P 位移量W分页地址中的地址结构在进
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 程运行时，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页面映射表，简称页表，进程的每个页占页表的一个表项，其中记录了相应页对应的内存块的块号，以及用于分页保护的存取控制信息。下图给出了分页系统的一个内存分配实例，其中页面大小为4K，用户作业的大小为11K。由于进程的最后一页不足一块，因此造成了存放该页的物69理块中部分空间的浪费，这部分被浪费的空间被称为“页内碎片”。分页系统中的内存分配（ 二）地址变换机构页式存储管理系统中，逻辑地址到物理地址的转换是在进程执行的过程中，由硬件地址变换机构借助于页表自动进行的。1.基本的地址变换机构通常将作业的页表存放在内存中，而在系统中只设置一个页表寄存器PTR（Page-Table Register），当一进程因CPU 调度而转入执行状态时，其页表的70内存始址和长度将从该进程的 PCB 中装入页表寄存器。当进程要访问某个逻辑地址中的指令或数据时，地址变换机构自动地将逻辑地址分为页号和页内地址两部分，并将页号与页表寄存器中的页表长度进行比较，若页号大于或等于页表长度，便产生越界中断，否则便以页号为索引去检索页表，从中得到该页的物理块号，送入物理地址寄存
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 器与页内地址拼接，形成对应的物理地址。2.具有快表的地址变换机构由于页表存放在内存中，故CPU 每存取一个指令或数据时都要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次才根据物理地址存取指令或数据，这使得计算机的处理速度降低近1/2。为了提高地址变换速度，可在地址变换机构中增设一个具有并行查寻能力的特殊高速缓冲寄存器，又称为“联想寄存器”或“快表”，用以存放当前访问的那些页表项。71在进行地址转换时，地址变换机构自动将逻辑地址中的页号并行地与快表中的所有页号进行比较，若其中有与此相匹配的页号，便可直接从快表中读出该页对应的物理块号，并送到物理地址寄存器中。如果在快表中未找到对应的页号，则仍需访问内存中的页表来进行地址转换，同时还必须将得到的页表项与页号—起装入到快表中，若快表已满，则还需根据置换算法淘汰某个快表项，以装入新的内容。（ 三）多级页表现代的大多数计算机系统都支持非常大的逻辑地址空间，此时，页表就变得非常大，要为它分配一大段连续的内存空间将变得十分困难。对于该问题，可利用将页表进行分页，并离散地将各个页表存放到内存块中的办法加以解决，此时，必须为离散分配的页表再建立一张页表，称为外层
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 页表，用来记录存放各页表页的内存块号，从72而形成了两级页表。在使用两级页表的分页系统中，每次访问一个数据需访问三次内存，故同样需增设快表来有效地提高访问速度。如果外层页表仍十分大，则可以将它再进行分页，并离散地存放到内存中，然后再通过一张第二级的外层页表来记录存放各外层页表页的内存块号，这样，便形成了三级页表，并可进一步形成更多级的页表。【习题演练】1.碎片现象的存在使得（ ）。A.内存空间利用率降低B.内存空间利用率提高C.内存空间利用率得以改善D.内存空间利用率不影响1.【答案】A。解析：碎片会占用计算机的内存，使部分内存空间不能满足程序运行的最低标准，从而不能被使用，降低内存的使用效率。732.基本分页存储管理中，若没有引入快表，则每次从主存取指令或取操作数，要（ ）访问主存。A.1 次B.2 次C.3 次D.4 次2.【答案】B。解析：要两次访问内存：第一次是访问内存中的页表，以形成物理地址；第二次根据物理地址存取指令或操作数。知识点 14、基本的分段存储管理用户通常喜欢将自己的作业按逻辑关系划分成若干段，然后通过段名和段内地址来访问相应的程序或数据，还希望能以段为单位对程序和数据进行共享和保护，并
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 要求分段能动态增长。分页系统虽然能较好地解决动态分区的碎片问题，却难以满足74用户的上述要求，因此又引入了分段式存储管理方式。在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息，如主程序段、子程序段、数据段等。每个段都有自己的名字，都从 0 开始编址，并采用一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，故各段长度不等。整个作业的地址空间由于是分成多个段，因而是二维的，即其逻辑地址由段号和段内地址所组成。分段地址中的地址具有如下图的结构：段号 段内地址31 16 15 0分段地址中的地址结构在该地址结构中，允许一个作业最长有64K个段，每个段的最大长度为64KB。75（ 一）段表在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地放入内存不同的分区。系统中为每个进程建立一张段映射表，简称“段表”。每个段在表中占有一个表项，其中记录了该段在内存中的起始地址和段的长度。段表可以存放在一组寄存器中，但更常多的是放在内存中。在配置了段表后，执行中的进程可通过查找段表找到每个段所对应的内存区。故段表是用于实现从逻辑段到物理内存区的映射。（ 二）地址变换机
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 构为了实现从进程的逻辑地址到物理地址的变换功能，在系统中设置了一个段表寄存器，用于存放正在执行进程的段表始址和长度。在进行地址转换时，地址变换机构将逻辑地址中的段号与段表寄存76器中的段表长度进行比较，若段号不小于段表长度，便产生越界中断；否则便以段号为索引去检索段表，从中得到该段的基址和长度；接着检查段内地址是否超过段长，若超过，则发出越界中断信号；若未超过，则将该段的基址与段内地址相加，从而得到对应的物理地址。（ 三 ）分页和分段的主要区别分页和分段系统都采用离散分配方式，且都要通过地址映射机构来实现地址变换，这是它们的相同之处，其不同主要表现在以下三个方面：①页是信息的物理单位，分页是为提高内存的利用率；段则是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要。②页的大小固定且由系统决定，在系统中只能有一种大小的页面；而段的长度却不固定，取决于用户所编写的程序，通常由编译程序在编译时，根据信息的性质来划分。77③分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址；而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名，又需给出段内地址。（ 四）
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 段页式存储管理方式为了既能像分页系统那样有效地利用内存，又能像分段系统那样满足用户多方面的需要，操作系统中又引入了段页式存储管理方式。段页式系统的基本原理，是先将用户程序分成若干个段，再把每个段分成若干个页。在段页式系统中，其地址结构由段号、段内页号及页内地址三部分所组成。在段页式系统中，为获得一条指令或数据须三次访问内存。第一次访问是访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中78取出该页所在的物理块号，并将该块号与页内地址一起形成物理地址；第三次访问是取指令或数据。【习题演练】1.页是（ ）单位，由（ ）划分，它的长度（ ）。A.逻辑，系统，定长B.逻辑，用户，不定长C.物理，用户，不定长D.物理，系统，定长1.【答案】D。解析：页是物理单位，由系统划分，它的长度固定。2.下列方法中，解决碎片问题最好的存储管理方法是（ ）。A.基本页式存储管理B.基本分段存储管理C.固定大小分区管理D.不同大小分区管理792.【答案】A。解析：离散分配方式将一个作业离散地存放到内存中，从而使系统无须紧凑便能很好地解决碎片问题，而离散分配方式中，分页是为解决碎片问题，提高内存的利用率，分段的目的则是为了
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 能更好地满足用户的需要，故选A。3.分段管理提供（ ）维的地址结构。A.1B.2C.3D.43.【答案】B。解析：分段存储管理的地址空间是二维的，标识一个地址时，既需给出段名，又需给出段内地址。80知识点 15、虚拟存储器（一）局部性原理程序局部性原理是指程序在执行时将呈现出局部性规律，即在一较短时间内，程序的执行仅局限于某个部分；相应地，它所访问的存储空间也局限于某个区域。局限性还表现在下述两方面：1.时间局限性如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过，则不久以后该数据可能再次被访问。产生时间局限性的典型原因是由于在程序中存在着大量的循环操作。2.空间局限性一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。81基于局部性原理产生了虚拟存储器。（ 二）虚拟存储器的实现虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。虚拟存储器的实现，建
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 立在离散分配的存储管理方式的基础上。目前，所有的虚拟存储器都是采用下述方式之一实现的：1.请求分页系统在分页系统的基础上，增加了请求调页功能和页面置换功能，便形成页式虚拟存储系统。它允许只装入少数页面的程序及数据，便启动运行。之后再通过调页功能及页面置换功能，陆续地把即将要运行的页面调入内存，同时把暂不运行的页面换出到外存上。822.请求分段系统在分段系统的基础上，增加了请求调段及分段置换功能后，便形成段式虚拟存储系统。它允许只装入少数而非所有段的用户程序和数据，即可启动运行。之后再通过调段功能和段的置换功能将暂不运行的段调出，同时调入即将运行的段。（ 三）虚拟存储器的特征虚拟存储器具有多次性、对换性和虚拟性三大主要特征。1.多次性多次性是指虚拟存储器将一个作业分成多次调入内存。多次性是虚拟存储器最重要的特征，任何其它的存储管理方式都不具有这一特征。2.对换性在作业运行期间，虚拟存储器允许将内存中暂时不能运行的进程或暂时不用的程序或数据，调出到外存上，以便腾出足够的内存空间，再把具备运83行条件的进程或进程所需要的程序和数据调入内存。如果对换是以整个进程为单位的，便称之为“整体对换”或“进程对换”。这种对换被
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 广泛地应用于分时系统中，其目的是用来解决内存紧张问题，并可进一步提高内存的利用率。而相应的，如果对换是以“页”或“段”为单位进行的，则分别称之为“页面对换”或“分段对换”，又统称为“部分对换”。它们是实现虚拟存储器的基础。3.虚拟性虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。虚拟性是实现虚拟存储器的最重要的目标。虚拟性是以多次性和对换性为基础的，仅当系统允许将作业分多次调入内存，并能将内存中暂时不运行的程序和数据换至盘上时，才有可能实现虚拟存储器；而多次性和对换性又必须建立在离散分配的基础上。84（ 四 ）请求分页存储管理方式请求分页系统是建立在基本分页存储管理基础上的，增加了请求调页功能和页面置换功能。请求分页便成为目前最常用的一种实现虚拟存储器的方式。为了确定所缺的页面调入内存的时机，可采取预调页策略或请求调页策略：1.预调页策略如果进程的许多页是存放在外存的一个连续区域中，则一次调入若干个相邻的页，会比一次调入一页更高效些。但如果调入的一批页面中的大多数都未被访问，则又是低效的。可采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。这种策
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 略主要用于进程的首次调入时，由程序员指出应该先调入哪些页。2.请求调页策略85当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便立即提出请求，由OS 将其所需页面调入内存。由请求调页策略所确定调入的页，是一定会被访问的，再加之请求调页策略比较易于实现，故在目前的虚拟存储器中大多采用此策略。【习题演练】1.实现虚拟存储器的目的是（ ）。A.实现存储保护B.实现程序浮动C.扩充辅存容量D.扩充主存容量1.【答案】D。解析：实现虚拟存储器的目的是为了扩充主存容量。2.虚拟存储器的最大容量是由（ ）决定的。A.计算机系统的地址结构和外存空间B.页表长度86C.内存空间D.逻辑空间2.【答案】A。解析：虚存容量不是无限的，最大容量受外存可利用的总容量和计算机总线地址结构的限制。3.具有虚拟存储功能的管理方法包括（ ）。A.可变分区存储管理B.分页式存储管理C.请求分段存储管理D.段页式存储管理3.【答案】C。解析：虚拟存储功能涉及内存的存储空间扩充问题。请求分段存储管理：作业可以装入不连续的存储空间中，且作业不要求全部装入内存就可以运行，因此具有空间扩充功能；段页式存储管理：作业虽然可以装入不连续
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的存储空间中，但是作业仍要求全部装入才可运行，因此不具备空间扩充功能。87知识点 16、页面置换算法置换算法的好坏直接影响系统的性能。若采用的置换算法不合适，可能出现这样的现象：刚被换出的页，很快又被访问，为把它调入而换出另一页，之后又访问刚被换出的页……如此频繁地更换页面，以致系统的大部分时间花费在页面的调度和传输上。此时，系统看起来很忙，但实际效率却很低。这种现象称为“抖动”。好的页面置换算法能够适当降低页面更换频率（减少缺页率），尽量避免系统“抖动”。为评价一个算法的优劣，可将该算法应用于一个特定的存储访问序列上，并且计算缺页数量，存储访问序列也叫页面走向。（一）最佳（OPT）置换算法最佳置换算法（Optimal，OPT）是选择不再访问的页面或者是在未来最长时间内不再被访问的页88面予以淘汰。最佳页面置换算法是在理论上提出的一种算法，具有最好的性能，但实现是困难的，因为它需要人们预先知道一个进程在整个运行过程中页面走向的全部情况。不过，这个算法可用来衡量其他算法的优劣。（ 二 ）先进先出（FIFO） 页面置换算法FIFO 算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰，该算法的
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 出发点是最早调入内存中的页面，其不再被使用的可能性会比较高。其实现简单、直观，对按线性顺序访问的程序比较合适，面对其他情况则效率不高，因为经常被访问的页面，往往在内存中因停留得最久而被淘汰。一般而言，对于任一作业或进程，如果给它分配的内存页面数越接近于它所要求的页面数，则发生缺页的次数会越少。在极限情况下，这个推论是成立的，如果给一个进程分配了它所要求的全部页89面，则不会发生缺页现象。但是，使用 FIFO 算法时，在给进程或作业分配满足它所要求的页面数时，有时会出现分配的页面数增多，缺页次数反而增加的奇怪现象，这种现象称为Belady 现象。（ 三）最近最久未使用（LRU） 置换算法LRU 算法是根据页面调入内存后的使用情况进行决策的。由于无法预测各页面将来的使用情况，只能以“最近的过去”作为“最近的将来”的近似，选择在最近一段时间里最久没有使用过的页面予以置换。因此，LRU 算法是与每个页面最后使用的时间有关的，当必须置换一个页面时，LRU 算法选择过去一段时间内最久未使用的页面。LRU 置换算法是一种比较好的算法，但需要硬件的支持：移位寄存器或栈。关于确定最后使用时间的问题，对于移位寄存器而言，当进程访
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 问某物理块时，要将相应寄存器的位置成“1”。此时，定时信号将每隔一定时间将90寄存器右移一位。如果把 n 位寄存器的数看做是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。对于栈而言，每当访问一个页面时，便将它的页面号从栈中移出，压入栈顶。因此栈顶始终是最新被访问页面的编号，而栈底则是最近最久未使用页面的页面号。（ 四）Clock 置换算法LRU 算法是较好的一种算法，但它要求有较多的硬件支持，故在实际应用中大多采用LRU 的近似算法。Clock 算法就是用得较多的一种LRU 近似算法。Clock 置换算法采用循环队列机制构造页面队列，形成类似于钟表面的环形表，队列指针相当于钟表面上的表针，指向可能要淘汰的页面。它在存储分块表的每一表项中增加一个访问位，操作系统定期地将它们置为 0。当某一页被访问时，由硬件91将该位置为 1。过一段时间后，通过检查这些位可以确定哪些页使用过，哪些页自上次置0 后还未使用过，可把该位是0 的页淘汰出去，因为在最近一段时间里它未被访问过。由于该算法是循环地检查各页面的使用情况，故称为Clock 算法。但因该算法只有一位访问位，只能用它表示该页是否已经使
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用过，而置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法（Not Recently Used，NRU）。【习题演练】1.在请求调页中可采用多种置换算法，其中LRU 是（ ）置换算法。A.最佳B.最近最久未用C.最近未用D.最少使用921.【答案】B 。解析：LRU 是最近最久未用置换算法。2.Clock 置换算法又称为（ ）。A.最久驻留置换算法B.最近最久未使用置换算法C.最近未使用置换算法D.最少使用置换算法2.【答案】C。解析：最近未使用算法是Clock置换算法。知识点 17、线性表（ 一）概念线性表是最基本、最简单、也是最常用的一种数据结构。线性表是具有n （n≥0）个类型相同的数据元素组成的有限序列。93线性表的长度：线性表中元素的个数。空表：长度为0 的线性表。（ 二）特点线性表中一定存在唯一的“第一元素”。线性表中一定存在唯一的“最后元素”。除最后一个元素之外，均有唯一的后继（后件）。除第一个元素之外，均有唯一的前驱（前件）。（ 三）表示方式1.线性表的顺序表示线性表中的数据元素是用一组地址连续的存储单元依次存储的。顺序表是在计算机内存中以数组的形式保存的线性表，是指用一组地址连续的
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 存储单元依次存储数据元素的线性结构。线性表采用顺序存储的方式存储就称之为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。942.线性表的链式表示（1）线性链表用一组任意的存储单元存储线性表的数据元素，存储单元不一定是连续的，可以连续，也可以不连续。（2）循环链表循环链表中最后一个结点的后继指针指向头结点，使整个链表形成一个环形。（3）双向链表在双向链表中，每个结点有两个指针域，一个指向它的直接后继，另一个指向它的直接前驱。【习题演练】1.下列有关线性表的叙述中，正确的是（ ）。A.线性表中的元素之间是线性关系B.线性表中至少有一个元素C.线性表中任何一个元素有且仅有一个直接前驱95D.线性表中任何一个元素有且仅有一个直接后继1.【答案】A。解析：线性表可以为空，并且线性表中的第一个结点是没有前驱结点的，最后一个结点没有后继结点。知识点 18、栈和队列（ 一）栈的定义1.栈的定义栈是一种只能在一端进行插入或删除操作的线性表。栈中的数据元素是线性关系。栈顶：允许进行插入或删除操作的一端。栈底：不允许进行插入和删除操作，固定不变的一端。入栈：栈的插入操作。出栈：栈的删除操作。962.栈的
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 特点先进后出（First In Last Out，简称FILO）、后进先出（Last In First Out，简称LIFO）。3.栈的存储结构（1）顺序栈使用顺序存储结构存储栈。（2）链式栈使用链式存储结构存储栈。（ 二）队列的定义1.队列的定义97队列是一种运算受限制的线性表，元素的添加在表的一端进行，而元素的删除在表的另一端进行。队头：允许删除元素的一端。队尾：允许添加元素的一端。入队：向队列添加元素。出队：从队列中删除元素。2.队列的特点先进先出（FIFO）（先入队的元素先出队，后入队的元素后出队）。3.存储结构顺序队：使用顺序存储结构的队列。链队：使用链式存储结构的队列。98【习题演练】1. 下述有关栈和队列的区别，说法错误的是( )。A.栈是限定只能在表的一端进行插入和删除操作B.队列是限定只能在表的一端进行插入和在另一端进行删除操作C.栈和队列都属于线性表D.栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（n）1.【答案】D。解析：栈的插入操作时间复杂度都是O（1），队列的插入操作时间复杂度是O（1）。因为都是在端点处进行的操作。2.为解决计算机主机与打印机之间速度不匹配问题，
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是( )。99A.栈B.队列C.树D.图2.【答案】B。解析：主机将数据依次写入，打印机依次取出，应该属于先进先出的特点，既使用的逻辑结构是队列。知识点 19、树（ 一）定义树形结构是一种重要的非线性结构，树是n 个结点的有限集合，在任一棵非空树中：（1）有且仅有一个称为根的结点。（2）其余结点可分为m 个互不相交的集合，而且这些集合中的每一集合都本身又是一棵树，称为根的子树，因此树是递归结构。100（ 二）基本术语结点：包含一个数据元素及若干指向其子树的分支。结点的度数：结点的非空子树个数。树的度：树中各节点中度的最大值。分支结点：度不为0 的结点。叶子结点：度为0 的结点。孩子：结点的子树的根。双亲：结点的直接前驱。兄弟：同一个双亲的孩子之间互为兄弟。堂兄弟：双亲在同一层的结点互为堂兄弟。祖先：从根到某结点的路径上的所有结点，都是这个结点的祖先。子孙：以某结点为根的子树中的所有结点，都是该结点的子孙。层次：从根开始，根为第一层，根的孩子为第二层，以此类推。101树的深度（或者高度）：树
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 中结点的最大层数。结点的深度和高度：结点的深度是从根结点算起的，根结点的深度为 1；结点高度是从最底层的叶子结点算起的，最底层叶子结点的高度为 1。有序树：子树按照一定的次序从左向右排列，相对次序不能随意变换。无序树：子树无一定的次序排列，相对次序可以随意变换。丰满树：即理想平衡树，要求除最底层外，其他层都是满的。森林：是由零个或多个不相交的树所组成的集合。【习题演练】1.如果在数据结构中每个数据元素只可能有一个直接前驱，但可有多个直接后继，则该结构是( )。A.栈102B.队列C.树D.图1.【答案】C。解析：树结构的每个结点都有一个前驱，但可以有多个后继。知识点 20、二叉树（ 一）定义二叉树是一个连通的无环图，并且每一个顶点的度不大于 2。有根二叉树还要满足根结点的度不大于 2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2 个子结点。（ 二）主要性质①二叉树的第 i 层上至多有2i- 1 个结点。②深度为k 的二叉树至多有2k- 1 个结点。103（补充概念：a.满二叉树：深度为k，有2k- 1 个结点。b.完全二叉树：给满二叉树的结点编号，从上至下，从左至右，n 个结点的完全二叉树中结点在对应
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 满二叉树中的编号正好是从 1 到n。③叶子结点 n0，度为2 的结点为n2，则n0 =n2+1。④n个结点的完全二叉树深度为 l㎀ g2n」+1。⑤n 个结点的完全二叉树，结点按层次编号。a.i 的双亲是1 n/2，如果i =1时为根（无双亲）。b.i 的左孩子是2i，如果2i>n，则无左孩子。c.i 的右孩子是2i + 1，如果2i + 1>n 则无右孩子。（ 三）存储结构1.顺序存储结构顺序存储结构即用一个数组来存储一棵二叉树，这种存储方式最适合于完全二叉树，用于存储104一般二叉树则会浪费大量的存储空间。将完全二叉树中的结点值按编号依次存入一个一维数组中，即完成了一棵二叉树的顺序存储。例：结点 A B C D E数组下标 0 1 2 3 4 52.链式存储结构二叉树中的每个结点用一个链结点来存放，结点结构如下：lchild data rchild其中，data 表示结点数据域，用于存储对应的数据元素；lchild 和 rchild 分别表示左指针域和右指针域，分别用于存储左孩子结点和右孩子结点的位置。（ 四）遍历算法若以L、D、R 分别表示遍历左子树、遍历根结点和遍历右子树，则有六种遍历方案：DLR、L
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: DR、LRD.DRL、RDL、RLD。若规定先左后右，则只有105前三种情况，分别是：DLR--先（根）序遍历；LDR--中（根）序遍历；LRD--后（根）序遍历。【习题演练】1.设非空二叉树中度数为0 的结点数为n0，度数为 1 的结点数为n1，度数为2 的结点数为n2，则下列等式成立的是（ ）。A.n0=n1+n2B.n0=2n1+1C.n0=n2+1D.n0=n1+11.【答案】C。解析：二叉树中度为0 的结点个数等于度为2 的结点个数加一。2.一棵树高为k 的完全二叉树至少有（ ）个结点。A.2k- 1B.2k- 1- 1C.2k- 1106D.2k2.【答案】C。解析：完全二叉树层次最小为k时，前k- 1 层都是满的，第k 层有一个结点。3.深度为 5 的完全二叉树的结点数不可能是( )。A.15B.16C.17D.183.【答案】A。解析：深度为5 的完全二叉树结点最多为二的 5 次方减一个，即31 个，最少为 16个。4.二叉树的先序遍历和中序遍历如下：先序遍历：EFHIGJK，中序遍历：HFIEJKG，则二叉树根结点为（ ）。A.EB.FC.G107D.H4.【答案】A。解析：先序遍历顺序为根
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 左右，所以树根为E。知识点 21、图（ 一）图的定义图是由顶点集V 和集合E（边的集合）组成的，可以定义为G=（V，E）。V 是顶点的非空有穷集合，E 是可空的边的有穷集合。（ 二）图的术语1.无向图对于一个图，若每条边都是没有方向的，则称该图为无向图。如下图：108对于此无向图，(Vi，Vj)和(Vj，Vi)表示的是同一条边。无向图的顶点集和边集分别表示为：V(G)={V1，V2，V3，V4，V5}E(G)={(V1，V2)，(V1，V4)，(V2，V3)，(V2，V5)，(V3，V4)，(V3，V5)，(V4，V5)}2.有向图对于一个图，若每条边都是有方向的，则称该图为有向图。如下图：109在此有向图中，<Vi，Vj>和<Vj，Vi>是两条不同的有向边。有向边又称为弧。终端点也称为弧头，初始点也称为弧尾。有向图的顶点集和边集分别表示为：V(G)={V1，V2，V3}E(G)={<V1，V2>，<V2，V3>，<V3，V1>，<V1，V3>}3.无向完全图和有向完全图具有n(n- 1)/2 条边的无向图为无向完全图。具有n(n- 1)条边的有向图称为有向完全图。4.稀疏图有很少条边或弧的图。5.稠密图有很
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 多条边或弧的图1106.顶点图中的数据元素通常称为顶点。7.顶点的度无向图中，顶点的度表示以该顶点作为端点的边的数目。有向图中，顶点的度分为入度和出度。入度表示以该顶点为终点的边的数目，出度是以该顶点为起点的边的数目，该顶点的度等于其入度、出度之和。8.回路、环指一条路径的起点和终点为一个顶点。9.连通图在无向图中，如果从顶点v1 到顶点v2 有路径，则称v1 和v2 是连通的。如果图中任意两个顶点都是连通的，则称图是连通图。10.连通分量指的是无向图中的极大连通子图。11.强连通图111在有向图G 中，对任意一对顶点vi 和vj（vi≠vj），若从vi 到vj 和从vj 到vi 都存在路径，则称G 是强连通图。12.强连通分量有向图中的极大强连通子图称为有向图的强连通分量。（ 三）遍历算法从图的某一顶点出发，访问图中其余顶点，且使每个顶点仅被访问一次，这一过程称为图的遍历。图的遍历分为深度优先搜索遍历和广度优先搜索遍历。1.广度优先广度优先搜索类似于树的按层次遍历。选取图中任意一个顶点Vi作为出发点，按照下列步骤遍历图。（1）首先访问出发点Vi。112（2）接着依次访问Vi的所有未被访问过的邻接点Vi1，V
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: i2，Vi3，ⅆ , Vit并均标记为已访问过。（3）然后再按照Vi1，Vi2，ⅆ , Vit的次序，访问每一个顶点的所有未被访问过的顶点，并均标记为已访问过。（4）依此类推，直到图中所有和初始出发点Vi有路径相通的顶点都被访问过为止。2.深度优先深度优先搜索（DFS）类似于树的先序遍历。【习题演练】1.具有n 个结点的连通图至少有（ ）条边。A.n-1B.nC.n（n- 1）/2D.2n1.【答案】A。解析：具有n 个结点的连通图至少有n-1 条边。1132.在有向图中每个顶点的度等于该顶点的( ) 。A.入度B.出度C.入度与出度之和D.入度与出度之差2.【答案】C。解析：有向图的某个顶点v，把以 v 为终点的边的数目称为v 的入度；以v 为始点的边的数目称为v 的出度；v 的度则定义为该顶点的入度和出度之和。3.设连通图G 中的边集E={（a，b），（a，e），（a，c），（b，e），（e，d），（d，f），（f，c）}，则从顶点a 出发可以得到一种深度优先遍历的顶点序列为（ ）。A.abedfcB.acfebdC.aebdfcD.aedfcb1143.【答案】A。图的深度优先遍历类似于树的前序遍历。采
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 用的搜索方法的特点是尽可能先对纵深方向进行搜索。知识点 22、数据模型（ 一）数据模型的概念数据模型是对现实世界数据特征的抽象。也就是说，数据模型是用来描述数据、组织数据和对数据进行操作的。（ 二）两类数据模型在数据库中模型主要分为两大类：一类为概念模型；另一类为逻辑模型和物理模型。概念模型也称为信息模型，在数据库设计阶段，由设计员按照用户观点建模实现对现实世界的概念抽象。115http://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=8656077逻辑模型包括网状、层次、关系和对象模型等，由设计人员按照计算机观点建模实现概念模型到适应某DBMS 的逻辑模型的转变。再由DBMS 完成逻辑到物理模型的转变。物理模型是数据最底层的抽象，描述数据的存储方式和方法。（ 三 ）现实世界的数据化过程现实世界 信息世界 数据世界概念模型现实世界的数据化过程【习题演练】1.常见的逻辑模型有3 种，它们是（ ）。A.字段名、字段类型和记录116DBMS支持下的数据模型事物本身B.层次、关系和网状C.环状、层次和关系D.网状、关系和语义1.【答案】B。解析：常见的数据模型有3 
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 种，即按图论理论建立的层次结构模型和网状结构模型以及按关系理论建立的关系结构模型。知识点 23、概念模型概念模型用于信息世界的建模，是现实世界到信息世界的第一层抽象，是数据库设计人员进行数据库设计的有利工具，也是数据库设计人员和用户之间进行交流的语言。（ 一）常用术语1.实体117客观存在并且可以区分的具体事物或者抽象概念。例如，一个学生、一个宿舍、一个操作流程等等。2.属性属性是对客观事物特征的一种反映，是实体具有的某个特征。例如，学生实体中有学号属性、姓名属性、性别属性，年龄属性、所在系属性等。属性有属性名称和属性值之分，例如，姓名为属性名，则“李白”就是这个属性的值。3.码在现实生活中，实体是可以互相区分的，所以没有两个完全相同的实体，即不能够有两个实体在各自对应属性上的属性值都是相同的。4.域一个属性的取值范围被称为域。例如，性别属性的属性值只能为“男”或者只能为“女”。5.实体型118实体集的名称及其所有属性名的集合称为实体型。例如，学生（学号，姓名，性别，年龄，所在系）就是学生实体集的实体型。6.实体集所有属性名完全相同的实体集合在一起，称为实体集。比如说学生实体集，教师实体集等。（ 二）概念模型
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 的表示方法：实体-联系图E-R 图中文称为实体-联系图，它是概念模型中的一种表示形式。E-R 图主要包含三个概念，分别是：实体集、联系集和属性。1.实体-联系图的表示方法实体型：用矩形表示，矩形框内写明实体名。属性：用椭圆表示，并用无向边将其对应的实体型连接起来。联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或者M：N）。1192.联系两个实体集之间的联系可归纳为以下三类：（1）一对一联系（1:1）如果对于实体集A 中的每一个实体，实体集B中至多有一个（也可以没有）实体与之联系，反之亦然，则称实体集A 与实体集B 具有一对一关系，记为 1：1。例如，一个学校只能有一个校长；一个账号只能提供给一个人使用等。（2）一对多联系（1：N）和多对一联系（N：1）如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集B 中的每一个实体，实体集A 中至多只有一个实体与之联系，则称实体集A 与实体集B 有一对多的联系，记为 1：n。例如，一个工厂可以有若干个员工，而一个员工只能属于一个工厂；一个导师可以有若干个学
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 员，而一个学员只能属于一个导师等。（3）多对多联系（M：N）120如果对于实体集A 中的每一个实体，实体集B中有N 个实体（N>=0）与之联系，反之，对于实体集 B 中的每一个实体，实体集A 中也有M 个实体（M>=0）与之联系，则称实体集A 与实体集B具有多对多的联系，记为M：N。例如，一门课程可以被多个学生选择，一个学生可以选择多门课程等。【习题演练】1.下列实体类型的联系中，属于一对一联系的是（ ）。A.教研室对教师的所属联系B.父亲对孩子的联系C.省对省会的所属联系D.供应商与工程项目的供货联系1.【答案】C。解析：实体之间的联系分为：一对一、一对多和多对多。因为每一个省都只有一个省会，而一个省会只属于一个省，所以省和省会之121间是一对一的联系。而A 选项属于一对多的关系；B 选项属于一对多的关系；D 选项属于多对多的关系。2.在E-R 图中，用长方形表示（ ），用椭圆表示（ ）。A.联系、属性B.属性、实体C.实体、属性D.什么也不代表、实体2.【答案】C。解析：矩形表示实体，椭圆表示属性。3.关系模型中，候选码（ ）。A.可由多个任意属性组成B.至多由一个属性组成C.可由一个或多个其值能惟一标识
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 该关系模式中任何元组的属性组成D.以上都不是1223.【答案】C。解析：候选码可以是一个也可以是多个，但是必须能唯一标识元组。知识点 24、关系模型（ 一）简介关系数据模型是目前最重要的一种数据模型。关系数据库系统采用关系数据模型作为数据的组织方式。有层次数据模型和网状模型相比，关系模型概念简单、清晰，并且具有严格的数据基础，形成了关系数据理论，操作也直观、容易，因此易学易用。支持关系数据模型的DBMS 称为关系型数据库管理系统RDBMS。与其他数据模型相同，关系数据模型也是由数据结构、数据操作和完整性约束三个部分组成。123（ 二）关系模型的性质列是同质的，即同一列的分量值应该出自相同的域。列名是唯一的，即在同一个关系中不能出现完全相同的两个属性名称。行的顺序无关，即元组与元组之间互换位置，不相互影响。列的顺序无关，即列于列之间互换位置，不相互影响。任何两行不能完全相同，即不能出现两个完全相同的元组。分量必须是原子量，即是不可分的基本数据项。【习题演练】1.下列叙述正确的为（ ）。A.关系中元组没有先后顺序，属性有先后顺序B.关系中元组有先后顺序，属性没有先后顺序124C.关系中元组没有先后顺序，属性也没有
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 先后顺序D.关系中元组有先后顺序，属性也有先后顺序1.【答案】C。解析：关系中元组的顺序无关，属性的顺序也无关。知识点 25、关系操作和完整性约束（一 ）基本的关系操作1.查询操作关系的查询表达能力很强，是关系操作最主要的部分。查询操作又可以分为：选择、投影、连接、除、并、差、交、笛卡尔积等。2.更新操作更新操作又可以分为：插入、删除、修改。3.基本操作125关系的基本操作有五种，分别是：选择、投影、并、差、笛卡尔积。其他操作是可以用基本操作来定义和导出的。就像乘法可以用加法定义和导出一样。4.关系操作的特点关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应地，非关系数据模型的数据操作方式则为一次一记录的方式。（ 二）关系的三类完整性关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作是关系的两个不变性，应该由关系系统自动支持。用户定义的完整性是应用领域需要遵循的约束条件，体现了具体领域中的语义约束。1.实体完整性126（1）规则若属性（指一个或者一组属性）A 是基本关系R 的
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 主属性，则A 不能取空值。按照实体完整性规则的规定基本关系的主码都不能取空值。如果主码由若干属性组成，则所有这些主属性都不能取空值。（2）具体说明①实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。②现实世界中的实体是可以区分的，即它们具有某种唯一性标识。③相应地，关系模型中以主码作为唯一标识。④主码中的属性即主属性不能取空值。如果主属性取空值，就说明存在某个不可标识的实体，即存在不可区分的实体，这与②点相矛盾，因此这个规则称为实体完整性。2.参照完整性127若属性（或属性组）F 是基本关系R 的外码，它与基本关系S 的主码Ks相对应（基本关系R和S不一定是不同的关系），则对于R 中每个元组在F上的值必须为：①或者取空值（F 的每个属性值均为空值）；②或者等于 S 中某个元组的主码值。3.用户自定义完整性任何关系数据库系统都应该支持实体完整性和参照完整性。这是关系模型所要求的。除此之外，不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性就是针对某一具体关系数据库的约束条件。它反映某一具体应用所涉及的数据必须满足的语义要求。例如某个属性必须取值唯一
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、某个非主属性也不能取空值等。【习题演练】1281.若属性A是关系R 的主属性，则A不能为空，该规则称为（ ）。A.实体完整性规则B.属性完整性规则C.参照完整性规则D.用户定义完整性规则1.【答案】A。解析：数据完整性包括：实体完整性、参照完整型和用户定义完整性。实体完整性即规定主键不能为空。2.关系模型有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。定义外键实现的是（ ）完整性。A.实体完整性B.参照完整性C.用户定义的完整性D.实体完整性、参照完整性和用户定义的完整性1292.【答案】B。解析：定义外键实现的是参照完整性。知识点 26、SQL 常用语句SQL（Structured Query Language），即结构化查询语言，是关系数据库的标准语言。当前，几乎所有的关系数据库管理系统软件都支持 SQL，许多软件厂商对 SQL 的基本命令集还进行了不同程度的扩充和修改。SQL 集数据查询、数据操纵、数据定义和数据控制功能于一体，是一个综合的、通用的、功能极强、简洁易学的语言。（ 一）数据查询1.语句格式SELECT [ALL|DISTINCT] column_listFROM table_
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: list130[WHERE search_condition][GROUP BY group_by_list][HAVING search_condition][ORDER BY order_list[ASC|DESC]]2.运算符算术比较运算符：=，<，<=，>，>=，<>，!>，!<逻辑运算符：AND、OR、NOT所属集合运算符：IN、NOT IN谓词：EXISTS（存在)、BETWEEN…AND（范围）、LIKE（匹配）、IS NULL（空值）3.统计函数常见的统计函数统计函数 描述COUNT（*） 计算记录的个数COUNT（[DISTINCT]列名） 对一列中的值计算个数SUM（[DISTINCT]列名） 求某一数值型列的总和AVG（[DISTINCT]列名） 求某一数值型列的平均值131统计函数 描述MAX（[DISTINCT]列名） 求某一列的最大值MIN（[DISTINCT]列名） 求某一列的最小值4.连接查询在查询的数据涉及到多个表时，必须用连接条件将这些表连接起来。5.嵌套查询在 SQL 语句中，可以将一个查询嵌入在另一个查询的WHERE 子句中，这类查询称为嵌套查询。一般内层的查询称为子查
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 询，将外层的查询称为父查询。嵌套的 SELECT 查询使得 SQL 可以实现各种复杂的查询，子查询必须用括号括起来。6.示例a.查询计算机系年龄在20 岁以下的学生姓名：SELECT SnameFROM StudentWHERE Sdept=’CS’ AND Sage<20；b.查询选修了3 门以上课程的学生学号：132SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*)>3;（ 二）数据更新1.INSERT 语句（1）语句格式INSERT INTO<表名>[（<属性名清单>）]VALUES（<常量清单>）;（2）实例：在Employee表中插入一职工记录。INSERT INTO EmployeeVALUES（’2032’，’张杉’，’男’，28，’工程师’，’01 ’）;2.UPDATE 语句（1）语句格式UPDATE<表名>133SET <列名>=<表达式>[,<列名>=<表达式>][WHERE<条件>];（2）实例：在工资表中，将所有职工的基本工资都增加500。UPDATE SalarySET Basepay=Basepay+500;3.DELETE 语句（1）语句格
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 式DELETE FROM <表名>[WHERE<条件>]（2）实例：从职工表中删除Eno（职工号）为1003 的记录。DELETE FROM EmployeeWHERE Eno=’1003’;【习题演练】1341.SQL 语言的标准库函数 COUNT 、SUM 、AVG、MAX 和MIN 等，不允许出现在下列哪个子句中（ ）。A.SELECTB.HAVINGC.WHERED.GROUP，HAVING1.【答案】C。解析：SQL 语言的标准库函数COUNT、SUM、AVG、MAX 和MIN 等，不允许出现在WHERE 子句中。2.在SQL 语句中，与X BETWEEN 20 AND 30等价的表达式是（ ）。A.X>=20 AND X<30B.X>=20 AND X<=30C.X>20 AND X<=30D.X>20 AND X<302.【答案】B。解析：BETWEEN A AND B 是指在 A-B 之间的范围，且包括A 和B 。故与X135BETWEEN 20 AND 30 等价的表达式是 X>=20AND X<=30。3.一个查询的结果成为另一个查询的条件，这种查询被称为（ ）。A.内查询B.连接查询C.
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 自查询D.子查询3.【答案】D。解析：一个查询的结果成为另一个查询的条件，这种查询被称为子查询，也叫嵌套查询。4.在考试表中，要将58 分、59 分的分数调整到60 分，下列SQL 语句中能实现的是（ ）。A.UPDATE 考试表 SET 分数 = 60 HAVING分数>=58 AND 分数<60B.UPDATE 考试表 SET 分数 = 60 WHERE分数>=58 AND 分数<60136C.UPDATE 考试表 SET 分数 = 60 WHERE分数 IN(58,59)D.UPDATE 考试表 SET 分数 = 60 WHERE分数 BETWEEN 58 AND 594.【答案】C。解析：由题知至包含58 分和59分，符合题意的只有C 选项。知识点 27、计算机网络分类（一）按作用范围1.局域网（LAN）局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网是封闭型的，137http://baike.baidu.com/view/
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 7886.htmhttp://baike.baidu.com/view/4321959.htmhttp://baike.baidu.com/view/281640.htm可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。2.城域网（MAN）城域网（Metropolitan Area Network）是在一个城市范围内所建立的计算机通信网，简称MAN。属于宽带局域网。由于采用具有有源交换元件的局域网技术，网中传输时延较小，它的传输媒介主要采用光缆，传输速率在 100 兆比特/秒以上。3.广域网（WAN）广域网（WAN，Wide Area Network）也称远程网（Long Haul Network）。通常跨接很大的物理范围，所覆盖的范围从几十公里到几千公里，它能连接多个城市或国家，或横跨几个洲并能提供远距离通信，形成国际性的远程网络。（ 二）按拓扑结构1.星型拓扑结构138星型拓扑结构是一种以中央结点为中心，把若干外围结点连接起来的辐射式互联结构，各结点与中央结点通过点与点方式连接，中央结点执行集中式通信控制策略，因此中央结点相当复杂，负担也重。2.树型拓扑结构树型拓扑结构是一种层次结构，
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 结点按层次连接，信息交换主要在上下结点之间进行，相邻结点或同层结点之间一般不进行数据交换。3.总线型拓扑结构总线型拓扑结构是采用单根传输作为共用的传输介质，将网络中所有的计算机通过相应的硬件接口和电缆直接连接到这根共享的总线上。使用总线型拓扑结构需解决的是确保用户使用媒体发送数据时不能冲突。在点到点的链路配置时，如果链路是半双工操作，只需使用简单的机制便可保证两个用户轮流工作。在一点到多点方式中，对线路的访问依靠控制139http://baike.baidu.com/view/47398.htmhttp://baike.baidu.com/view/420833.htm端的探询来确定。采取分布式访问控制策略来协调网络上计算机数据的发送。4.环型拓扑结构环型拓扑结构是使用公共电缆组成一个封闭的环，各结点直接连到环上，信息沿着环按一定方向从一个结点传送到另一个结点。环接口一般由发送器、接收器、控制器、线控制器和线接收器组成。5.网状拓扑结构网状拓扑结构，这种拓扑结构主要指各结点通过传输线相互连接起来，并且每一个结点至少与其他两个结点相连。网状拓扑结构具有较高的可靠性，但其结构复杂，实现起来费用较高，不易管理和维护
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，不常用于局域网。（ 三）按使用范围1.公用网一般是国家的邮电部门建造的网络。“公用”的意思就是从所有愿意按邮电部门规定交纳费用的140人都可以使用。因此，公用网也可以称为公众网，例如CHINANET、CERNET 等。2.专用网“专用网”是某个部门为本单位的特殊工作的需要而建立的网络。专用网指专用于一些保密性要求较高的部门的网络，比如企业内部专用网、军队专用网，尤其是涉及国家机密的部门。这种网络不向本单位以外的人提供服务。例如，军队、铁路、电力等系统均有本系统的专用网。【习题演练】1.局域网常用的基本拓扑结构有（ ）、环型和星型。A.层次型B.总线型C.交换型D.分组型1411.【答案】B。解析：局域网常用的拓扑结构有星型、环型、树型、总线型。网状型通常应用于广域网。知识点 28、网络地址（ 一）物理地址网卡物理地址存储器中存储单元对应实际地址称物理地址。MAC（介质访问控制）地址是识别LAN（局域网）结点的标识。网卡的物理地址通常是由网卡生产厂家烧入网卡的EPROM（一种闪存芯片，通常可以通过程序擦写），它存储的是传输数据时真正赖以标识发出数据的电脑和接收数据的主机的地址。物理地址一般记作 06-2E-1
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 4-F9-5A-23，48 比特的不同组合。142（ 二）IP 地址是为网络每台计算机分配的唯一标识，为了使连入网络的众多计算机主机在通信时能够互相识别，网络中的每一台主机都有唯一的32 位地址。IP 地址一般用小数点隔开的十进制数，即点分十进制表示，如202.120.70.23。以点分十进制的形式表示IP 地址时，用小数点将 IP 地址分为四部分，每个部分的范围为0～255。每一类地址都由两个固定长度的字段组成，其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络，而另一个字段则是主机号host-id，它标志该主机（或路由器）。两级的IP 地址可以记为：IP 地址：：= { <网络号>，<主机号>}（ 三）IP 地址分类汇总143IP 地址分类类型 IP 范围 私有IPA 1-126 10.0.0.1-10.255.255.255B 128-191 172.16.0.1- 172.31.255.255C 192-223 192.168.0.1- 192.168.255.255D 224-239E 240-254（ 四）特殊的 IP 地址主机号全为 1 表示本网段的内部广播地址，不能分给计
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 算机使用。主机号全为0 表示本网络的网段，计算机所在网络。127 开头的本地回环地址，主要测试TCP/IP 协议正确性。D 类地址为组播地址。主要是路由协议OSPF等使用。14410.0.0.110.255.255.255172.16.0.1172.31.255.255192.168.0.1192.168.255.255E 类地址用于研究使用。169.254.*.*的地址是当计算机自动获取IP 地址失败后的标识，但不能用于计算机之间的通信。（五）IPv6 地址IPv6 是InternetProtocoLVersion 6 的缩写，是下一代 IP 地址，用于替代现行版本 IP 协议（IPv4）的下一代 IP 协议，目的是为解决 IP 地址紧缺的问题。扩大地址的可用空间，满足计算机网路增长的需求。IPv6 将地址32 位（IPv4）增大到了 128 位二进制，使得地址数量变为原来的2 的96 次方倍，地址数量更多，适应未来网络扩展的需求。【习题演练】1.以下IP地址中，属于A 类地址的是（ ）。A.52.213. 12.23B.210.123.23. 12145C.223.123.213.23D.156.123.
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 32. 121.【答案】A。解析：A 类地址的第一个部分范围是 1～126，符合的只有A 选项。2.IPv4 地址和IPv6 地址的位数分别为（ ）。A.4，6B.8，16C.16，24D.32，1282.【答案】D。解析：IPv4 地址和Ipv6 地址的位数分别为32，128。知识点 29、子网掩码（ 一）概念子网掩码是一种用来指明一个 IP 地址的网络位和主机位，知道了 IP 地址的网络位，就可以确定146计算机 IP 地址所在的网络，知道了主机位就可以确定该 IP 地址所在网络的位置。（ 二）功能子网掩码不能单独存在，它必须结合 IP 地址一起使用。子网掩码是一个32 位地址，一般在书写的时候也是点分十进制表示。在子网掩码中，1 表示网络位，0 表示主机位。（ 三）默认子网掩码A 类网络的子网掩码为255.0.0.0，B 类网络的子网掩码为 255.255.0.0，C 类网络的子网掩码为255.255.255.0。（ 四）求网络号主机号全为0 的地址表示网络号。第一步把IP 地址转化为二进制。147255.0.0.0255.255.0.0255.255.255.0第二步把子网掩码转化为二进制。第三步保留
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 子网掩码中 1 所对应的部分，主机位用0 填充。第四步转为点分十进制。（五） 求主机号第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 0 所对应的部分。（六） 求广播号主机号全为 1 的地址表示广播号。第一步把IP 地址转化为二进制。第二步把子网掩码转化为二进制。第三步保留子网掩码中 1 所对应的部分，主机位用 1 填充。第四步转为点分十进制。148（七） 子网划分计算形成子网的数量计算：从主机位借位当网络位来使用。借位数 子网个数 借位数 子网个数1 21 = 2 4 24 =162 22 = 4 5 25 =323 23 =8 6 26 = 64【习题演练】1.以下关于子网掩码的作用，错误的是（ ）。A.标识 IP 地址的网络部分和主机部分B.主机部分对应的子网掩码部分全为“0”C.网络部分对应的子网掩码部分全为“1”D.通过子网掩码标识网络的类型1491.【答案】D。解析：子网掩码是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机位。其中主机部分对应的子网掩码部分全为0，网络部分全为 1。2.一个子网掩码是 255.255.240.0
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，这个子网能拥有的最大主机数是（ ）。A.240B.255C.4094D.655342.【答案】C。解析：255.255.240.0，将子网掩码中的240 转换为二进制，240=11110000，所以进行子网划分的时候借走了4 位主机位充当网络位，能够形成 2^4= 16 个子网，每个子网中的 IP 数量2^ 12=4096 ，但是能够分配给计算机使用的只有4096-2=4094。150255.255.240.0知识点 30、网络设备（一）局域网设备1.中继器中继器（Repeater）是局域网互连的最简单设备，工作在OSI 体系结构的物理层，它接收并识别网络信号，然后再生信号并将其发送到网络的其他分支上。信号在传输线路上传输的时候，受到距离、噪音、电阻等影响，使得信号传输的距离不能是长到无限远，在传输一定距离后，信号需要加强。如果在线路中间插入放大器，则伴随信号的放大，噪音也被放大了。中继器的功能是对接收信号进行再生和发送。2.集线器集线器属于物理层设备。集线器是有多个端口的中继器，简称HUB。151集线器在创建网络时，一般是以星型或树型拓扑结构为主。集线器没有MAC地址表，采用广播方式发送，当网络中的主机数
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 量过多的时候，就会在网络生成广播风暴。以集线器为主要网络设备的网络被称为共享式以太网。3.网卡网络接口卡NIC（Network Interface Card）又称网卡或网络适配器。网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。4.网桥在数据链路层扩展局域网是使用网桥。网桥工作在数据链路层，它根据MAC 帧的目的地址对收到的帧进行转发。152网桥不隔绝广播风暴。5.交换机以太网交换机的每个接口都直接与主机相连，并且一般都工作在全双工方式。交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。（ 二）广域网设备1.网关网关（Gateway）又称网间连接器、协议转换器。网关在网络层以上实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。2.路由器153路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，以最佳路径，按前后顺序发送信号。3.调制解调器调制解调器（modem）是一种计算机硬件，它能把计算机的数字信号翻译成可沿普通电话线传送的模拟信号，是家用电话拨号上网的必不可上少的设备。调制：将数字信号转化为模拟信号。解调：将模拟信号转化为数字信号。【习题演练】1.集线器是工作在（ ）的设备。A.物理层B.链路层C.网络层D.运输层1541.【答案】A。解析：中继器和集线器就是物理层的设备。2.在下列网间连接器中，（ ）在数据链路层实现网络互连。A.中继器B.网桥C.路由器D.网关2.【答案】B。解析：网桥是数据链路层的设备，中继器是物理层设备，路由器是网络层设备，网关在传输层及其以上实现网络互联。155知识点 31、信息加密技术（ 一）信息加密信息加密是指使有用的信息变为看上去似为无用的乱码，使攻击者无法读懂信息的内容从而保护信息。任何一个加密系统至少由下面四个部分组成：1.未加密的信息，也称明文。2.加密后的信息，也称密文。3.加密解密设备或算法。4.加密解密的密钥。发送方用加密密钥，通过加密设备或算法，将信息加密后发送出去。接收方在收到密文后，用解密密钥将密文解密，恢复为明文。如果传输中有人窃取，他只能
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 得到无法理解的密文，从而对信息起到保密作用。156其中，密钥是唯一能够控制明文与密文之间变换的关键，通常是一随机字符串，在计算机上实现的数据加密算法，其加密或解密变换是由一个密钥来控制的。（ 二）对称加密1.概念对称密码体制是指如果一个加密系统的加密密钥和解密密钥相同，或者虽然不相同，但是由其中的任意一个可以很容易地推导出另一个，即密钥是双方共享的，则该系统所采用的就是对称密码体制。2.加密过程3.对称加密算法特点157对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。不足之处是，交易双方都使用同样钥匙，安全性得不到保证。每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一钥匙，这会使得发收信双方所拥有的钥匙数量呈几何级数增长，密钥管理成为用户的负担。对称加密算法在分布式网络系统上使用较为困难，主要是因为密钥管理困难，使用成本较高。常见的对称加密算法：DES 算法，3DES 算法，TDEA 算法，Blowfish 算法，RC5 算法， IDEA 算法。（ 三）非对称密钥加密1.概念公钥密码体制指一个加密系统的加密密钥和解密密钥是不一样的，或者说不能由一个推导出另一158个。其中一个称为公
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 钥用于加密，是公开的，另一个称为私钥用于解密，是保密的。公钥密码体制解决了密钥的管理和发布问题，每个用户都可以把自己的公开密钥进行公开，如发布到一个公钥数据库中。2.工作原理A要给B发送信息时，A用B 的公钥加密信息，因为A 知道B 的公钥。A 将这个消息发给B。B 收到这个消息后，B 用自己的私钥解密A 的消息。其他所有收到这个报文的人都无法解密，因为只有B 才有B 的私钥。3.RSA 算法159RSA 是Rivest、Shamire 和Adleman 于 1978 年在美国麻省理工学院研制出来的，它是一种比较典型的公开密钥加密算法。【习题演练】1.在数据加密技术中，将待加密的报文称为( )。A.密文B.正文C.短文D.明文1.【答案】D。解析：待加密的报文称为明文。2.在公钥密码体制中，公开的是（ ）。A.公钥和私钥B.公钥和算法C.明文和密文D.加密密钥和解密密钥1602.【答案】B。解析：公钥加密算法是计算机网络中经常使用的算法，能跟好的保证网络安全。其中有两个秘钥，公钥和算法是公开的，可以在服务器上查找到，这样方便用于加密。私钥是用户自己保存的一种密钥。3. 以下关于对称与非对称加密算法叙述中正确的
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 是（ ）。A.对称加密比非对称加密的安全性好B.对称加密比非对称加密的解密速度慢C.非对称加密算法中公钥是公开的，算法是保密的D.非对称加密与对称加密相比，用户需要保管的密钥数量少3.【答案】D。解析：非对称加密使用了一对密钥，即公钥与私钥，公钥是公开的，私钥个人持有，不公开，故D 选择正确。161知识点 32、计算机病毒（ 一）计算机病毒的概念广义上，能够引起计算机故障、破坏计算机数据的程序都可称为计算机病毒；狭义上，计算机病毒是指编制者在计算机程序中插入的破坏计算机或者毁坏数据，影响计算机的使用，并能自我复制的一组计算机指令或者程序代码。（ 二）计算机病毒的特性目前，计算机病毒有数十万种，各有其不同的特征，但总的说来，计算机病毒又有明显的共性。计算机病毒主要有以下几种特征：1.传染性传染性是计算机病毒的基本特征。计算机病毒能通过自我复制来感染正常的文件，达到破坏计算162机系统正常运行的目的。但传染性是有条件的，只有病毒程序被执行之后才具有传染性，才能感染其他文件。2.破坏性任何计算机病毒只要侵入计算机系统，都会对系统及应用程序产生不同程度的影响和破坏，轻则降低计算机的工作效率，占用系统资源，重则破坏数据
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: ，删除文件，甚至导致系统崩溃，给用户造成不可挽回的损失。3.寄生性虽然计算机病毒是一种程序，但这种程序通常不是以独立文件的形式存在的，它寄生在合法的程序之中。这些合法的程序可以是系统引导程序、可执行程序、一般应用程序等。现在的某些病毒本身就是一个完整的程序，如广义病毒中的网络蠕虫。4.欺骗性黑客常常会把带有病毒程序的名字起成一些用户比较关心的程序名字。1635.隐蔽性和潜伏性计算机病毒要有效的传染和传播，就应该尽量在用户能够觉察的范围之外进行。6.衍生性既然计算机病毒是一段特殊的程序，了解病毒程序的人就可以根据其个人意图随意改动，从而衍生出另一种不同于原版病毒的新病毒。7.可触发性编制计算机病毒的人，一般都为病毒程序设定了一些触发条件，例如系统时钟的某个时间或日期、系统运行了某些程序等。一旦条件满足，计算机病毒就会“发作”，使系统遭到破坏。（ 三）计算机病毒的传播方式计算机病毒的传播方式主要有：（1）移动存储设备传播；（2）计算机网络传播；（3）电子邮件传播。164【习题演练】1.计算机病毒是可以造成计算机故障的（ ）。A.一种微生物B.一种特殊的程序C.一块特殊芯片D.一个程序逻辑错误1.【答案】B。解析：
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 计算机病毒指人为编制的一段具有破坏性的，能够自我复制的程序或者代码。2.计算机病毒具有破坏性、（ ）、潜伏性和传染性等特点。A.必然性B.再生性C.隐蔽性D.易读性2.【答案】C。解析：计算机病毒具有寄生性、传染性、潜伏性、隐蔽性。1653.根据统计，当前计算机病毒扩散最快的途径是（ ）。A.软件复制B.网络传播C.磁盘拷贝D.运行游戏软件3.【答案】B。解析：计算机病毒扩散最快的是网络传播，需要提前安装使用杀毒软件来做好防范。166目录知识点 1 、进制转换知识点 2 、常见数据编码知识点 3 、机器数知识点 4 、补码溢出知识点 5 、寻址方式知识点 6 、存储芯片容量的计算知识点 7 、DRAM 的刷新知识点 8、存储器与 CPU 的扩展连接知识点 9 、死锁知识点 10 、处理机调度的层次知识点 11 、调度算法知识点 12 、内存的连续分配知识点 13 、基本的分页存储管理知识点 14 、基本的分段存储管理知识点 15 、虚拟存储器知识点 16 、页面置换算法知识点 17 、线性表知识点 18 、栈和队列知识点 19 、树知识点 20 、二叉树知识点 21 、图知识点 22 、数据模型知识点 23 
2025-08-10 14:53:58.804 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG com.yizhaoqi.smartpai.service.ParseService - 文本块: 、概念模型知识点 24 、关系模型知识点 25 、关系操作和完整性约束知识点 26 、SQL 常用语句知识点 27 、计算机网络分类知识点 28 、网络地址知识点 29 、子网掩码知识点 30 、网络设备知识点 31 、信息加密技术知识点 32 、计算机病毒
2025-08-10 14:53:58.952 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.service.ParseService - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:58.952 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.y.smartpai.consumer.FileProcessingConsumer - 文件解析完成，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
2025-08-10 14:53:58.952 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  c.yizhaoqi.smartpai.service.VectorizationService - 开始向量化文件，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf, userId: 1, orgTag: PRIVATE_sy, isPublic: false
2025-08-10 14:53:58.956 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] INFO  com.yizhaoqi.smartpai.client.EmbeddingClient - 开始生成向量，文本数量: 435
2025-08-10 14:53:58.957 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:53:58.957 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:53:59.156 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] [2f214867-17] Response 400 BAD_REQUEST
2025-08-10 14:53:59.157 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] [2f214867-17] Read 312 bytes
2025-08-10 14:54:00.170 [parallel-13] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:54:00.172 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:54:00.360 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] [2f214867-18] Response 400 BAD_REQUEST
2025-08-10 14:54:00.361 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] [2f214867-18] Read 312 bytes
2025-08-10 14:54:01.364 [parallel-14] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:54:01.366 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:54:01.538 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] [2f214867-19] Response 400 BAD_REQUEST
2025-08-10 14:54:01.539 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] [2f214867-19] Read 312 bytes
2025-08-10 14:54:02.542 [parallel-15] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] HTTP POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
2025-08-10 14:54:02.542 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] Encoding [{input=[一 根据所给图表，回答下列问题。国家电网·必会考点——计算机类目录知识点 1、进制转换................................................. (truncated)...]
2025-08-10 14:54:02.774 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] [2f214867-20] Response 400 BAD_REQUEST
2025-08-10 14:54:02.776 [reactor-http-nio-7] DEBUG org.springframework.web.HttpLogging - [7b30abb6] [2f214867-20] Read 312 bytes
2025-08-10 14:54:02.776 [reactor-http-nio-7] DEBUG o.s.web.reactive.function.client.ExchangeFunctions - [7b30abb6] Cancel signal (to close connection)
2025-08-10 14:54:02.776 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR com.yizhaoqi.smartpai.client.EmbeddingClient - 调用向量化 API 失败: Retries exhausted: 3/3
reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	at java.base/java.lang.Thread.run(Thread.java:840)
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:54:02.777 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.yizhaoqi.smartpai.service.VectorizationService - 向量化失败，fileMd5: efda0d8454f290ed66cbcdf9aa2ac5bf
java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:54:02.778 [org.springframework.kafka.KafkaListenerEndpointContainer#0-0-C-1] ERROR c.y.smartpai.consumer.FileProcessingConsumer - Error processing task: FileProcessingTask(fileMd5=efda0d8454f290ed66cbcdf9aa2ac5bf, filePath=http://localhost:9000/uploads/merged/%E5%9B%BD%E5%AE%B6%E7%94%B5%E7%BD%91%C2%B7%E5%BF%85%E4%BC%9A%E8%80%83%E7%82%B9-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B1%BB.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=minioadmin%2F20250810%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20250810T065327Z&X-Amz-Expires=3600&X-Amz-SignedHeaders=host&X-Amz-Signature=c80c2fa60fcd59d007f0b4eab7bcff02a5533b224ca13cb4ad1864b39addf1ec, fileName=国家电网·必会考点-计算机类.pdf, userId=1, orgTag=PRIVATE_sy, isPublic=false)
java.lang.RuntimeException: 向量化失败
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:79)
	at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:569)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
	at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
	at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
	at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
	at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
	at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
	at io.micrometer.observation.Observation.observe(Observation.java:564)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
	at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
	at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.lang.RuntimeException: 向量生成失败
	at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:62)
	at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
	... 26 common frames omitted
Caused by: reactor.core.Exceptions$RetryExhaustedException: Retries exhausted: 3/3
	at reactor.core.Exceptions.retryExhausted(Exceptions.java:308)
	at reactor.util.retry.RetryBackoffSpec.lambda$static$0(RetryBackoffSpec.java:68)
	at reactor.util.retry.RetryBackoffSpec.lambda$null$4(RetryBackoffSpec.java:608)
	at reactor.core.publisher.FluxConcatMapNoPrefetch$FluxConcatMapNoPrefetchSubscriber.onNext(FluxConcatMapNoPrefetch.java:183)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.SinkManyEmitterProcessor.drain(SinkManyEmitterProcessor.java:476)
	at reactor.core.publisher.SinkManyEmitterProcessor.tryEmitNext(SinkManyEmitterProcessor.java:273)
	at reactor.core.publisher.SinkManySerialized.tryEmitNext(SinkManySerialized.java:100)
	at reactor.core.publisher.InternalManySink.emitNext(InternalManySink.java:27)
	at reactor.core.publisher.FluxRetryWhen$RetryWhenMainSubscriber.onError(FluxRetryWhen.java:194)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.Operators$MultiSubscriptionSubscriber.onError(Operators.java:2236)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onError(FluxOnAssembly.java:544)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onError(MonoFlatMap.java:180)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:106)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.FluxOnErrorResume$ResumeSubscriber.onError(FluxOnErrorResume.java:103)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.secondError(MonoFlatMap.java:241)
	at reactor.core.publisher.MonoFlatMap$FlatMapInner.onError(MonoFlatMap.java:315)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onError(MonoIgnoreThen.java:280)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:232)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.onComplete(MonoIgnoreThen.java:204)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onComplete(FluxOnErrorReturn.java:169)
	at reactor.core.publisher.MonoIgnoreElements$IgnoreElementsSubscriber.onComplete(MonoIgnoreElements.java:89)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onComplete(FluxMapFuseable.java:152)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onComplete(FluxOnAssembly.java:549)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.Operators.complete(Operators.java:137)
	at reactor.netty.channel.FluxReceive.startReceiver(FluxReceive.java:179)
	at reactor.netty.channel.FluxReceive.subscribe(FluxReceive.java:145)
	at reactor.core.publisher.InternalFluxOperator.subscribe(InternalFluxOperator.java:68)
	at reactor.netty.ByteBufFlux.subscribe(ByteBufFlux.java:340)
	at reactor.core.publisher.Mono.subscribe(Mono.java:4576)
	at reactor.core.publisher.MonoIgnoreThen$ThenIgnoreMain.subscribeNext(MonoIgnoreThen.java:265)
	at reactor.core.publisher.MonoIgnoreThen.subscribe(MonoIgnoreThen.java:51)
	at reactor.core.publisher.MonoFlatMap$FlatMapMain.onNext(MonoFlatMap.java:165)
	at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:122)
	at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
	at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
	at reactor.core.publisher.FluxOnAssembly$OnAssemblySubscriber.onNext(FluxOnAssembly.java:539)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
	at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
	at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
	at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
	at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
	at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
	at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
	at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
	at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
	at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
	at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
	at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
	at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
	at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
	at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
	at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
	at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
	at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
	at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
	at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
	at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
	at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
	... 1 common frames omitted
	Suppressed: java.lang.Exception: #block terminated with an error
		at reactor.core.publisher.BlockingSingleSubscriber.blockingGet(BlockingSingleSubscriber.java:146)
		at reactor.core.publisher.Mono.block(Mono.java:1807)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.callApiOnce(EmbeddingClient.java:80)
		at com.yizhaoqi.smartpai.client.EmbeddingClient.embed(EmbeddingClient.java:55)
		at com.yizhaoqi.smartpai.service.VectorizationService.vectorize(VectorizationService.java:57)
		at com.yizhaoqi.smartpai.consumer.FileProcessingConsumer.processTask(FileProcessingConsumer.java:61)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
		at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
		at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
		at java.base/java.lang.reflect.Method.invoke(Method.java:569)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:169)
		at org.springframework.kafka.listener.adapter.KotlinAwareInvocableHandlerMethod.doInvoke(KotlinAwareInvocableHandlerMethod.java:45)
		at org.springframework.messaging.handler.invocation.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:119)
		at org.springframework.kafka.listener.adapter.HandlerAdapter.invoke(HandlerAdapter.java:70)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invokeHandler(MessagingMessageListenerAdapter.java:420)
		at org.springframework.kafka.listener.adapter.MessagingMessageListenerAdapter.invoke(MessagingMessageListenerAdapter.java:384)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:85)
		at org.springframework.kafka.listener.adapter.RecordMessagingMessageListenerAdapter.onMessage(RecordMessagingMessageListenerAdapter.java:50)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeOnMessage(KafkaMessageListenerContainer.java:2800)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeOnMessage(KafkaMessageListenerContainer.java:2778)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.lambda$doInvokeRecordListener$53(KafkaMessageListenerContainer.java:2701)
		at io.micrometer.observation.Observation.observe(Observation.java:564)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeRecordListener(KafkaMessageListenerContainer.java:2699)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.doInvokeWithRecords(KafkaMessageListenerContainer.java:2541)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeRecordListener(KafkaMessageListenerContainer.java:2430)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeListener(KafkaMessageListenerContainer.java:2085)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.invokeIfHaveRecords(KafkaMessageListenerContainer.java:1461)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.pollAndInvoke(KafkaMessageListenerContainer.java:1426)
		at org.springframework.kafka.listener.KafkaMessageListenerContainer$ListenerConsumer.run(KafkaMessageListenerContainer.java:1296)
		at java.base/java.util.concurrent.CompletableFuture$AsyncRun.run(CompletableFuture.java:1804)
		... 1 common frames omitted
Caused by: org.springframework.web.reactive.function.client.WebClientResponseException$BadRequest: 400 Bad Request from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings
	at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
	Suppressed: reactor.core.publisher.FluxOnAssembly$OnAssemblyException: 
Error has been observed at the following site(s):
	*__checkpoint ⇢ 400 BAD_REQUEST from POST https://dashscope.aliyuncs.com/compatible-mode/v1/embeddings [DefaultWebClient]
Original Stack Trace:
		at org.springframework.web.reactive.function.client.WebClientResponseException.create(WebClientResponseException.java:321)
		at org.springframework.web.reactive.function.client.DefaultClientResponse.lambda$createException$1(DefaultClientResponse.java:214)
		at reactor.core.publisher.FluxMap$MapSubscriber.onNext(FluxMap.java:106)
		at reactor.core.publisher.FluxOnErrorReturn$ReturnSubscriber.onNext(FluxOnErrorReturn.java:162)
		at reactor.core.publisher.FluxDefaultIfEmpty$DefaultIfEmptySubscriber.onNext(FluxDefaultIfEmpty.java:122)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableSubscriber.onNext(FluxMapFuseable.java:129)
		at reactor.core.publisher.FluxContextWrite$ContextWriteSubscriber.onNext(FluxContextWrite.java:107)
		at reactor.core.publisher.FluxMapFuseable$MapFuseableConditionalSubscriber.onNext(FluxMapFuseable.java:299)
		at reactor.core.publisher.FluxFilterFuseable$FilterFuseableConditionalSubscriber.onNext(FluxFilterFuseable.java:337)
		at reactor.core.publisher.Operators$BaseFluxToMonoOperator.completePossiblyEmpty(Operators.java:2097)
		at reactor.core.publisher.MonoCollect$CollectSubscriber.onComplete(MonoCollect.java:145)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.core.publisher.FluxPeek$PeekSubscriber.onComplete(FluxPeek.java:260)
		at reactor.core.publisher.FluxMap$MapSubscriber.onComplete(FluxMap.java:144)
		at reactor.netty.channel.FluxReceive.onInboundComplete(FluxReceive.java:413)
		at reactor.netty.channel.ChannelOperations.onInboundComplete(ChannelOperations.java:455)
		at reactor.netty.channel.ChannelOperations.terminate(ChannelOperations.java:509)
		at reactor.netty.http.client.HttpClientOperations.onInboundNext(HttpClientOperations.java:819)
		at reactor.netty.channel.ChannelOperationsHandler.channelRead(ChannelOperationsHandler.java:115)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.codec.MessageToMessageDecoder.channelRead(MessageToMessageDecoder.java:107)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.CombinedChannelDuplexHandler$DelegatingChannelHandlerContext.fireChannelRead(CombinedChannelDuplexHandler.java:436)
		at io.netty.handler.codec.ByteToMessageDecoder.fireChannelRead(ByteToMessageDecoder.java:346)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:318)
		at io.netty.channel.CombinedChannelDuplexHandler.channelRead(CombinedChannelDuplexHandler.java:251)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:442)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.handler.ssl.SslHandler.unwrap(SslHandler.java:1515)
		at io.netty.handler.ssl.SslHandler.decodeJdkCompatible(SslHandler.java:1378)
		at io.netty.handler.ssl.SslHandler.decode(SslHandler.java:1427)
		at io.netty.handler.codec.ByteToMessageDecoder.decodeRemovalReentryProtection(ByteToMessageDecoder.java:530)
		at io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:469)
		at io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:290)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:444)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.AbstractChannelHandlerContext.fireChannelRead(AbstractChannelHandlerContext.java:412)
		at io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(DefaultChannelPipeline.java:1357)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:440)
		at io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext.java:420)
		at io.netty.channel.DefaultChannelPipeline.fireChannelRead(DefaultChannelPipeline.java:868)
		at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:166)
		at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:788)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:724)
		at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:650)
		at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:562)
		at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:997)
		at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
		at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
		at java.base/java.lang.Thread.run(Thread.java:840)
2025-08-10 14:54:53.327 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/users/me
2025-08-10 14:54:53.333 [http-nio-8081-exec-6] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/users/me
2025-08-10 14:54:53.333 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/users/me", parameters={}
2025-08-10 14:54:53.333 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.UserController#getCurrentUser(String)
2025-08-10 14:54:53.336 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:54:53.336 [http-nio-8081-exec-6] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={id=1, username=admin, role=ADMIN, orgTags=[default, admin], primaryOrg=default, cre (truncated)...]
2025-08-10 14:54:53.337 [http-nio-8081-exec-6] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:54:53.589 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 14:54:53.594 [http-nio-8081-exec-8] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11
2025-08-10 14:54:53.594 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/conversation?userid=1&start_date=2025-08-03&end_date=2025-08-11", parameters={masked}
2025-08-10 14:54:53.594 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getAllConversations(String, String, String, String)
2025-08-10 14:54:53.599 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:54:53.599 [http-nio-8081-exec-8] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data=[{role=user, content=解释一下社区论坛项目, timestamp=2025-08-10T10:40:56, username=admin}, {ro (truncated)...]
2025-08-10 14:54:53.599 [http-nio-8081-exec-8] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 14:54:53.667 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Securing GET /api/v1/admin/users/list?page=1&size=999&orgTag=default
2025-08-10 14:54:53.671 [http-nio-8081-exec-9] DEBUG org.springframework.security.web.FilterChainProxy - Secured GET /api/v1/admin/users/list?page=1&size=999&orgTag=default
2025-08-10 14:54:53.671 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - GET "/api/v1/admin/users/list?page=1&size=999&orgTag=default", parameters={masked}
2025-08-10 14:54:53.671 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.a.RequestMappingHandlerMapping - Mapped to com.yizhaoqi.smartpai.controller.AdminController#getUserList(String, String, String, Integer, int, int)
2025-08-10 14:54:53.676 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Using 'application/json', given [application/json, text/plain, */*] and supported [application/json, application/*+json]
2025-08-10 14:54:53.676 [http-nio-8081-exec-9] DEBUG o.s.w.s.m.m.annotation.HttpEntityMethodProcessor - Writing [{code=200, data={number=1, size=999, totalPages=1, content=[{primaryOrg=default, createdAt=2025-08-0 (truncated)...]
2025-08-10 14:54:53.677 [http-nio-8081-exec-9] DEBUG org.springframework.web.servlet.DispatcherServlet - Completed 200 OK
2025-08-10 15:20:53.305 [SpringApplicationShutdownHook] INFO  o.s.boot.web.embedded.tomcat.GracefulShutdown - Commencing graceful shutdown. Waiting for active requests to complete
2025-08-10 15:20:53.482 [tomcat-shutdown] INFO  o.s.boot.web.embedded.tomcat.GracefulShutdown - Graceful shutdown complete
2025-08-10 15:20:55.599 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown initiated...
2025-08-10 15:20:55.602 [SpringApplicationShutdownHook] INFO  com.zaxxer.hikari.HikariDataSource - HikariPool-1 - Shutdown completed.
2025-08-10 15:20:55.603 [SpringApplicationShutdownHook] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - Transport error in StandardWebSocketSession[id=476bbeca-570e-1667-e48d-dc06d7b13e68, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g]
java.io.IOException: java.nio.channels.ClosedChannelException
	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendMessageBlockInternal(WsRemoteEndpointImplBase.java:326)
	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendMessageBlock(WsRemoteEndpointImplBase.java:266)
	at org.apache.tomcat.websocket.WsSession.sendCloseMessage(WsSession.java:792)
	at org.apache.tomcat.websocket.WsSession.doClose(WsSession.java:589)
	at org.apache.tomcat.websocket.WsSession.doClose(WsSession.java:556)
	at org.apache.tomcat.websocket.WsSession.close(WsSession.java:544)
	at org.apache.tomcat.websocket.WsWebSocketContainer.destroy(WsWebSocketContainer.java:1024)
	at org.apache.tomcat.websocket.server.WsContextListener.contextDestroyed(WsContextListener.java:46)
	at org.apache.catalina.core.StandardContext.listenerStop(StandardContext.java:4052)
	at org.apache.catalina.core.StandardContext.stopInternal(StandardContext.java:4662)
	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:235)
	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1219)
	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1208)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)
	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145)
	at org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:814)
	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:235)
	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1219)
	at org.apache.catalina.core.ContainerBase$StopChild.call(ContainerBase.java:1208)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at org.apache.tomcat.util.threads.InlineExecutorService.execute(InlineExecutorService.java:75)
	at java.base/java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:145)
	at org.apache.catalina.core.ContainerBase.stopInternal(ContainerBase.java:814)
	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:235)
	at org.apache.catalina.core.StandardService.stopInternal(StandardService.java:471)
	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:235)
	at org.apache.catalina.core.StandardServer.stopInternal(StandardServer.java:915)
	at org.apache.catalina.util.LifecycleBase.stop(LifecycleBase.java:235)
	at org.apache.catalina.startup.Tomcat.stop(Tomcat.java:447)
	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.stopTomcat(TomcatWebServer.java:301)
	at org.springframework.boot.web.embedded.tomcat.TomcatWebServer.destroy(TomcatWebServer.java:374)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.doClose(ServletWebServerApplicationContext.java:177)
	at org.springframework.context.support.AbstractApplicationContext.close(AbstractApplicationContext.java:1126)
	at org.springframework.boot.SpringApplicationShutdownHook.closeAndWait(SpringApplicationShutdownHook.java:147)
	at java.base/java.lang.Iterable.forEach(Iterable.java:75)
	at org.springframework.boot.SpringApplicationShutdownHook.run(SpringApplicationShutdownHook.java:116)
	at java.base/java.lang.Thread.run(Thread.java:840)
Caused by: java.nio.channels.ClosedChannelException: null
	at org.apache.tomcat.util.net.NioChannel$1.write(NioChannel.java:273)
	at org.apache.tomcat.util.net.NioEndpoint$NioSocketWrapper$NioOperationState.run(NioEndpoint.java:1632)
	at org.apache.tomcat.util.net.SocketWrapperBase$OperationState.start(SocketWrapperBase.java:1051)
	at org.apache.tomcat.util.net.SocketWrapperBase.vectoredOperation(SocketWrapperBase.java:1440)
	at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:1366)
	at org.apache.tomcat.util.net.SocketWrapperBase.write(SocketWrapperBase.java:1337)
	at org.apache.tomcat.websocket.server.WsRemoteEndpointImplServer.doWrite(WsRemoteEndpointImplServer.java:171)
	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.writeMessagePart(WsRemoteEndpointImplBase.java:521)
	at org.apache.tomcat.websocket.WsRemoteEndpointImplBase.sendMessageBlockInternal(WsRemoteEndpointImplBase.java:313)
	... 37 common frames omitted
2025-08-10 15:20:55.603 [SpringApplicationShutdownHook] DEBUG o.s.w.s.handler.LoggingWebSocketHandlerDecorator - StandardWebSocketSession[id=476bbeca-570e-1667-e48d-dc06d7b13e68, uri=ws://localhost:8081/chat/eyJhbGciOiJIUzI1NiJ9.eyJwcmltYXJ5T3JnIjoiZGVmYXVsdCIsIm9yZ1RhZ3MiOiJkZWZhdWx0LGFkbWluIiwicm9sZSI6IkFETUlOIiwidG9rZW5JZCI6IjU3YjE1YzEwZjU0YzRmM2I5OTcxOGFiM2YzY2JhYzQxIiwidXNlcklkIjoiMSIsInN1YiI6ImFkbWluIiwiZXhwIjoxNzU0Nzk3MjE1fQ.zjjgHJaaZeNWDYfahW0pI7_qHCcTaoX93GS9E088w8g] closed with CloseStatus[code=1001, reason=The web application is stopping]
2025-08-10 15:20:55.604 [SpringApplicationShutdownHook] INFO  c.yizhaoqi.smartpai.handler.ChatWebSocketHandler - WebSocket连接已关闭，用户ID: admin，会话ID: 476bbeca-570e-1667-e48d-dc06d7b13e68，状态: CloseStatus[code=1001, reason=The web application is stopping]
